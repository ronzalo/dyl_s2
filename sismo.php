<?php 
/*Copyright (c) 2009,2010,2011,2012 Fabien Potencier

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is furnished
to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

 namespace { class Twig_Environment { const VERSION = '1.9.2-DEV'; protected $charset; protected $loader; protected $debug; protected $autoReload; protected $cache; protected $lexer; protected $parser; protected $compiler; protected $baseTemplateClass; protected $extensions; protected $parsers; protected $visitors; protected $filters; protected $tests; protected $functions; protected $globals; protected $runtimeInitialized; protected $loadedTemplates; protected $strictVariables; protected $unaryOperators; protected $binaryOperators; protected $templateClassPrefix = '__TwigTemplate_'; protected $functionCallbacks; protected $filterCallbacks; protected $staging; public function __construct(Twig_LoaderInterface $loader = null, $options = array()) { if (null !== $loader) { $this->setLoader($loader); } $options = array_merge(array( 'debug' => false, 'charset' => 'UTF-8', 'base_template_class' => 'Twig_Template', 'strict_variables' => false, 'autoescape' => 'html', 'cache' => false, 'auto_reload' => null, 'optimizations' => -1, ), $options); $this->debug = (bool) $options['debug']; $this->charset = $options['charset']; $this->baseTemplateClass = $options['base_template_class']; $this->autoReload = null === $options['auto_reload'] ? $this->debug : (bool) $options['auto_reload']; $this->extensions = array( 'core' => new Twig_Extension_Core(), 'escaper' => new Twig_Extension_Escaper($options['autoescape']), 'optimizer' => new Twig_Extension_Optimizer($options['optimizations']), ); $this->strictVariables = (bool) $options['strict_variables']; $this->runtimeInitialized = false; $this->setCache($options['cache']); $this->functionCallbacks = array(); $this->filterCallbacks = array(); $this->staging = array( 'functions' => array(), 'filters' => array(), 'tests' => array(), 'token_parsers' => array(), 'visitors' => array(), 'globals' => array(), ); } public function getBaseTemplateClass() { return $this->baseTemplateClass; } public function setBaseTemplateClass($class) { $this->baseTemplateClass = $class; } public function enableDebug() { $this->debug = true; } public function disableDebug() { $this->debug = false; } public function isDebug() { return $this->debug; } public function enableAutoReload() { $this->autoReload = true; } public function disableAutoReload() { $this->autoReload = false; } public function isAutoReload() { return $this->autoReload; } public function enableStrictVariables() { $this->strictVariables = true; } public function disableStrictVariables() { $this->strictVariables = false; } public function isStrictVariables() { return $this->strictVariables; } public function getCache() { return $this->cache; } public function setCache($cache) { $this->cache = $cache ? $cache : false; } public function getCacheFilename($name) { if (false === $this->cache) { return false; } $class = substr($this->getTemplateClass($name), strlen($this->templateClassPrefix)); return $this->getCache().'/'.substr($class, 0, 2).'/'.substr($class, 2, 2).'/'.substr($class, 4).'.php'; } public function getTemplateClass($name, $index = null) { return $this->templateClassPrefix.md5($this->loader->getCacheKey($name)).(null === $index ? '' : '_'.$index); } public function getTemplateClassPrefix() { return $this->templateClassPrefix; } public function render($name, array $context = array()) { return $this->loadTemplate($name)->render($context); } public function display($name, array $context = array()) { $this->loadTemplate($name)->display($context); } public function loadTemplate($name, $index = null) { $cls = $this->getTemplateClass($name, $index); if (isset($this->loadedTemplates[$cls])) { return $this->loadedTemplates[$cls]; } if (!class_exists($cls, false)) { if (false === $cache = $this->getCacheFilename($name)) { eval('?>'.$this->compileSource($this->loader->getSource($name), $name)); } else { if (!is_file($cache) || ($this->isAutoReload() && !$this->isTemplateFresh($name, filemtime($cache)))) { $this->writeCacheFile($cache, $this->compileSource($this->loader->getSource($name), $name)); } } } if (!$this->runtimeInitialized) { $this->initRuntime(); } return $this->loadedTemplates[$cls] = new $cls($this); } public function isTemplateFresh($name, $time) { foreach ($this->extensions as $extension) { $r = new ReflectionObject($extension); if (filemtime($r->getFileName()) > $time) { return false; } } return $this->loader->isFresh($name, $time); } public function resolveTemplate($names) { if (!is_array($names)) { $names = array($names); } foreach ($names as $name) { if ($name instanceof Twig_Template) { return $name; } try { return $this->loadTemplate($name); } catch (Twig_Error_Loader $e) { } } if (1 === count($names)) { throw $e; } throw new Twig_Error_Loader(sprintf('Unable to find one of the following templates: "%s".', implode('", "', $names))); } public function clearTemplateCache() { $this->loadedTemplates = array(); } public function clearCacheFiles() { if (false === $this->cache) { return; } foreach (new RecursiveIteratorIterator(new RecursiveDirectoryIterator($this->cache), RecursiveIteratorIterator::LEAVES_ONLY) as $file) { if ($file->isFile()) { @unlink($file->getPathname()); } } } public function getLexer() { if (null === $this->lexer) { $this->lexer = new Twig_Lexer($this); } return $this->lexer; } public function setLexer(Twig_LexerInterface $lexer) { $this->lexer = $lexer; } public function tokenize($source, $name = null) { return $this->getLexer()->tokenize($source, $name); } public function getParser() { if (null === $this->parser) { $this->parser = new Twig_Parser($this); } return $this->parser; } public function setParser(Twig_ParserInterface $parser) { $this->parser = $parser; } public function parse(Twig_TokenStream $tokens) { return $this->getParser()->parse($tokens); } public function getCompiler() { if (null === $this->compiler) { $this->compiler = new Twig_Compiler($this); } return $this->compiler; } public function setCompiler(Twig_CompilerInterface $compiler) { $this->compiler = $compiler; } public function compile(Twig_NodeInterface $node) { return $this->getCompiler()->compile($node)->getSource(); } public function compileSource($source, $name = null) { try { return $this->compile($this->parse($this->tokenize($source, $name))); } catch (Twig_Error $e) { $e->setTemplateFile($name); throw $e; } catch (Exception $e) { throw new Twig_Error_Runtime(sprintf('An exception has been thrown during the compilation of a template ("%s").', $e->getMessage()), -1, $name, $e); } } public function setLoader(Twig_LoaderInterface $loader) { $this->loader = $loader; } public function getLoader() { return $this->loader; } public function setCharset($charset) { $this->charset = $charset; } public function getCharset() { return $this->charset; } public function initRuntime() { $this->runtimeInitialized = true; foreach ($this->getExtensions() as $extension) { $extension->initRuntime($this); } } public function hasExtension($name) { return isset($this->extensions[$name]); } public function getExtension($name) { if (!isset($this->extensions[$name])) { throw new Twig_Error_Runtime(sprintf('The "%s" extension is not enabled.', $name)); } return $this->extensions[$name]; } public function addExtension(Twig_ExtensionInterface $extension) { $this->extensions[$extension->getName()] = $extension; $this->parsers = null; $this->visitors = null; $this->filters = null; $this->tests = null; $this->functions = null; $this->globals = null; } public function removeExtension($name) { unset($this->extensions[$name]); $this->parsers = null; $this->visitors = null; $this->filters = null; $this->tests = null; $this->functions = null; $this->globals = null; } public function setExtensions(array $extensions) { foreach ($extensions as $extension) { $this->addExtension($extension); } } public function getExtensions() { return $this->extensions; } public function addTokenParser(Twig_TokenParserInterface $parser) { $this->staging['token_parsers'][] = $parser; $this->parsers = null; } public function getTokenParsers() { if (null === $this->parsers) { $this->parsers = new Twig_TokenParserBroker(); if (isset($this->staging['token_parsers'])) { foreach ($this->staging['token_parsers'] as $parser) { $this->parsers->addTokenParser($parser); } } foreach ($this->getExtensions() as $extension) { $parsers = $extension->getTokenParsers(); foreach ($parsers as $parser) { if ($parser instanceof Twig_TokenParserInterface) { $this->parsers->addTokenParser($parser); } elseif ($parser instanceof Twig_TokenParserBrokerInterface) { $this->parsers->addTokenParserBroker($parser); } else { throw new Twig_Error_Runtime('getTokenParsers() must return an array of Twig_TokenParserInterface or Twig_TokenParserBrokerInterface instances'); } } } } return $this->parsers; } public function getTags() { $tags = array(); foreach ($this->getTokenParsers()->getParsers() as $parser) { if ($parser instanceof Twig_TokenParserInterface) { $tags[$parser->getTag()] = $parser; } } return $tags; } public function addNodeVisitor(Twig_NodeVisitorInterface $visitor) { $this->staging['visitors'][] = $visitor; $this->visitors = null; } public function getNodeVisitors() { if (null === $this->visitors) { foreach ($this->getExtensions() as $extension) { foreach ($extension->getNodeVisitors() as $visitor) { $this->addNodeVisitor($visitor); } } $this->visitors = $this->staging['visitors']; } return $this->visitors; } public function addFilter($name, Twig_FilterInterface $filter) { $this->staging['filters'][$name] = $filter; $this->filters = null; } public function getFilter($name) { if (null === $this->filters) { $this->getFilters(); } if (isset($this->filters[$name])) { return $this->filters[$name]; } foreach ($this->filters as $pattern => $filter) { $pattern = str_replace('\\*', '(.*?)', preg_quote($pattern, '#'), $count); if ($count) { if (preg_match('#^'.$pattern.'$#', $name, $matches)) { array_shift($matches); $filter->setArguments($matches); return $filter; } } } foreach ($this->filterCallbacks as $callback) { if (false !== $filter = call_user_func($callback, $name)) { return $filter; } } return false; } public function registerUndefinedFilterCallback($callable) { $this->filterCallbacks[] = $callable; } public function getFilters() { if (null === $this->filters) { foreach ($this->getExtensions() as $extension) { foreach ($extension->getFilters() as $name => $filter) { $this->addFilter($name, $filter); } } $this->filters = $this->staging['filters']; } return $this->filters; } public function addTest($name, Twig_TestInterface $test) { $this->staging['tests'][$name] = $test; $this->tests = null; } public function getTests() { if (null === $this->tests) { foreach ($this->getExtensions() as $extension) { foreach ($extension->getTests() as $name => $test) { $this->addTest($name, $test); } } $this->tests = $this->staging['tests']; } return $this->tests; } public function addFunction($name, Twig_FunctionInterface $function) { $this->staging['functions'][$name] = $function; $this->functions = null; } public function getFunction($name) { if (null === $this->functions) { $this->getFunctions(); } if (isset($this->functions[$name])) { return $this->functions[$name]; } foreach ($this->functions as $pattern => $function) { $pattern = str_replace('\\*', '(.*?)', preg_quote($pattern, '#'), $count); if ($count) { if (preg_match('#^'.$pattern.'$#', $name, $matches)) { array_shift($matches); $function->setArguments($matches); return $function; } } } foreach ($this->functionCallbacks as $callback) { if (false !== $function = call_user_func($callback, $name)) { return $function; } } return false; } public function registerUndefinedFunctionCallback($callable) { $this->functionCallbacks[] = $callable; } public function getFunctions() { if (null === $this->functions) { foreach ($this->getExtensions() as $extension) { foreach ($extension->getFunctions() as $name => $function) { $this->addFunction($name, $function); } } $this->functions = $this->staging['functions']; } return $this->functions; } public function addGlobal($name, $value) { $this->staging['globals'][$name] = $value; $this->globals = null; } public function getGlobals() { if (null === $this->globals) { $this->globals = isset($this->staging['globals']) ? $this->staging['globals'] : array(); foreach ($this->getExtensions() as $extension) { $this->globals = array_merge($this->globals, $extension->getGlobals()); } } return $this->globals; } public function mergeGlobals(array $context) { foreach ($this->getGlobals() as $key => $value) { if (!array_key_exists($key, $context)) { $context[$key] = $value; } } return $context; } public function getUnaryOperators() { if (null === $this->unaryOperators) { $this->initOperators(); } return $this->unaryOperators; } public function getBinaryOperators() { if (null === $this->binaryOperators) { $this->initOperators(); } return $this->binaryOperators; } public function computeAlternatives($name, $items) { $alternatives = array(); foreach ($items as $item) { $lev = levenshtein($name, $item); if ($lev <= strlen($name) / 3 || false !== strpos($item, $name)) { $alternatives[$item] = $lev; } } asort($alternatives); return array_keys($alternatives); } protected function initOperators() { $this->unaryOperators = array(); $this->binaryOperators = array(); foreach ($this->getExtensions() as $extension) { $operators = $extension->getOperators(); if (!$operators) { continue; } if (2 !== count($operators)) { throw new InvalidArgumentException(sprintf('"%s::getOperators()" does not return a valid operators array.', get_class($extension))); } $this->unaryOperators = array_merge($this->unaryOperators, $operators[0]); $this->binaryOperators = array_merge($this->binaryOperators, $operators[1]); } } protected function writeCacheFile($file, $content) { $dir = dirname($file); if (!is_dir($dir)) { if (false === @mkdir($dir, 0777, true) && !is_dir($dir)) { throw new RuntimeException(sprintf("Unable to create the cache directory (%s).", $dir)); } } elseif (!is_writable($dir)) { throw new RuntimeException(sprintf("Unable to write in the cache directory (%s).", $dir)); } $tmpFile = tempnam(dirname($file), basename($file)); if (false !== @file_put_contents($tmpFile, $content)) { if (@rename($tmpFile, $file) || (@copy($tmpFile, $file) && unlink($tmpFile))) { @chmod($file, 0666 & ~umask()); return; } } throw new Twig_Error_Runtime(sprintf('Failed to write cache file "%s".', $file)); } } } namespace { class Twig_Error extends Exception { protected $lineno; protected $filename; protected $rawMessage; protected $previous; public function __construct($message, $lineno = -1, $filename = null, Exception $previous = null) { if (version_compare(PHP_VERSION, '5.3.0', '<')) { $this->previous = $previous; parent::__construct(''); } else { parent::__construct('', 0, $previous); } $this->lineno = $lineno; $this->filename = $filename; if (-1 === $this->lineno || null === $this->filename) { $this->guessTemplateInfo(); } $this->rawMessage = $message; $this->updateRepr(); } public function getRawMessage() { return $this->rawMessage; } public function getTemplateFile() { return $this->filename; } public function setTemplateFile($filename) { $this->filename = $filename; $this->updateRepr(); } public function getTemplateLine() { return $this->lineno; } public function setTemplateLine($lineno) { $this->lineno = $lineno; $this->updateRepr(); } public function __call($method, $arguments) { if ('getprevious' == strtolower($method)) { return $this->previous; } throw new BadMethodCallException(sprintf('Method "Twig_Error::%s()" does not exist.', $method)); } protected function updateRepr() { $this->message = $this->rawMessage; $dot = false; if ('.' === substr($this->message, -1)) { $this->message = substr($this->message, 0, -1); $dot = true; } if (null !== $this->filename) { if (is_string($this->filename) || (is_object($this->filename) && method_exists($this->filename, '__toString'))) { $filename = sprintf('"%s"', $this->filename); } else { $filename = json_encode($this->filename); } $this->message .= sprintf(' in %s', $filename); } if ($this->lineno >= 0) { $this->message .= sprintf(' at line %d', $this->lineno); } if ($dot) { $this->message .= '.'; } } protected function guessTemplateInfo() { $template = null; foreach (debug_backtrace() as $trace) { if (isset($trace['object']) && $trace['object'] instanceof Twig_Template && 'Twig_Template' !== get_class($trace['object'])) { $template = $trace['object']; } } if (null !== $template && null === $this->filename) { $this->filename = $template->getTemplateName(); } if (null === $template || $this->lineno > -1) { return; } $r = new ReflectionObject($template); $file = $r->getFileName(); $exceptions = array($e = $this); while (($e instanceof self || method_exists($e, 'getPrevious')) && $e = $e->getPrevious()) { $exceptions[] = $e; } while ($e = array_pop($exceptions)) { $traces = $e->getTrace(); while ($trace = array_shift($traces)) { if (!isset($trace['file']) || !isset($trace['line']) || $file != $trace['file']) { continue; } foreach ($template->getDebugInfo() as $codeLine => $templateLine) { if ($codeLine <= $trace['line']) { $this->lineno = $templateLine; return; } } } } } } } namespace { class Twig_Error_Loader extends Twig_Error { } } namespace { class Twig_Error_Runtime extends Twig_Error { } } namespace { class Twig_Error_Syntax extends Twig_Error { } } namespace { interface Twig_ExtensionInterface { function initRuntime(Twig_Environment $environment); function getTokenParsers(); function getNodeVisitors(); function getFilters(); function getTests(); function getFunctions(); function getOperators(); function getGlobals(); function getName(); } } namespace { abstract class Twig_Extension implements Twig_ExtensionInterface { public function initRuntime(Twig_Environment $environment) { } public function getTokenParsers() { return array(); } public function getNodeVisitors() { return array(); } public function getFilters() { return array(); } public function getTests() { return array(); } public function getFunctions() { return array(); } public function getOperators() { return array(); } public function getGlobals() { return array(); } } } namespace { if (!defined('ENT_SUBSTITUTE')) { define('ENT_SUBSTITUTE', 8); } class Twig_Extension_Core extends Twig_Extension { protected $dateFormats = array('F j, Y H:i', '%d days'); protected $numberFormat = array(0, '.', ','); protected $timezone = null; public function setDateFormat($format = null, $dateIntervalFormat = null) { if (null !== $format) { $this->dateFormats[0] = $format; } if (null !== $dateIntervalFormat) { $this->dateFormats[1] = $dateIntervalFormat; } } public function getDateFormat() { return $this->dateFormats; } public function setTimezone($timezone) { $this->timezone = $timezone instanceof DateTimeZone ? $timezone : new DateTimeZone($timezone); } public function getTimezone() { return $this->timezone; } public function setNumberFormat($decimal, $decimalPoint, $thousandSep) { $this->numberFormat = array($decimal, $decimalPoint, $thousandSep); } public function getNumberFormat() { return $this->numberFormat; } public function getTokenParsers() { return array( new Twig_TokenParser_For(), new Twig_TokenParser_If(), new Twig_TokenParser_Extends(), new Twig_TokenParser_Include(), new Twig_TokenParser_Block(), new Twig_TokenParser_Use(), new Twig_TokenParser_Filter(), new Twig_TokenParser_Macro(), new Twig_TokenParser_Import(), new Twig_TokenParser_From(), new Twig_TokenParser_Set(), new Twig_TokenParser_Spaceless(), new Twig_TokenParser_Flush(), new Twig_TokenParser_Do(), new Twig_TokenParser_Embed(), ); } public function getFilters() { $filters = array( 'date' => new Twig_Filter_Function('twig_date_format_filter', array('needs_environment' => true)), 'date_modify' => new Twig_Filter_Function('twig_date_modify_filter', array('needs_environment' => true)), 'format' => new Twig_Filter_Function('sprintf'), 'replace' => new Twig_Filter_Function('strtr'), 'number_format' => new Twig_Filter_Function('twig_number_format_filter', array('needs_environment' => true)), 'abs' => new Twig_Filter_Function('abs'), 'url_encode' => new Twig_Filter_Function('twig_urlencode_filter'), 'json_encode' => new Twig_Filter_Function('twig_jsonencode_filter'), 'convert_encoding' => new Twig_Filter_Function('twig_convert_encoding'), 'title' => new Twig_Filter_Function('twig_title_string_filter', array('needs_environment' => true)), 'capitalize' => new Twig_Filter_Function('twig_capitalize_string_filter', array('needs_environment' => true)), 'upper' => new Twig_Filter_Function('strtoupper'), 'lower' => new Twig_Filter_Function('strtolower'), 'striptags' => new Twig_Filter_Function('strip_tags'), 'trim' => new Twig_Filter_Function('trim'), 'nl2br' => new Twig_Filter_Function('nl2br', array('pre_escape' => 'html', 'is_safe' => array('html'))), 'join' => new Twig_Filter_Function('twig_join_filter'), 'sort' => new Twig_Filter_Function('twig_sort_filter'), 'merge' => new Twig_Filter_Function('twig_array_merge'), 'reverse' => new Twig_Filter_Function('twig_reverse_filter', array('needs_environment' => true)), 'length' => new Twig_Filter_Function('twig_length_filter', array('needs_environment' => true)), 'slice' => new Twig_Filter_Function('twig_slice', array('needs_environment' => true)), 'default' => new Twig_Filter_Node('Twig_Node_Expression_Filter_Default'), '_default' => new Twig_Filter_Function('_twig_default_filter'), 'keys' => new Twig_Filter_Function('twig_get_array_keys_filter'), 'escape' => new Twig_Filter_Function('twig_escape_filter', array('needs_environment' => true, 'is_safe_callback' => 'twig_escape_filter_is_safe')), 'e' => new Twig_Filter_Function('twig_escape_filter', array('needs_environment' => true, 'is_safe_callback' => 'twig_escape_filter_is_safe')), ); if (function_exists('mb_get_info')) { $filters['upper'] = new Twig_Filter_Function('twig_upper_filter', array('needs_environment' => true)); $filters['lower'] = new Twig_Filter_Function('twig_lower_filter', array('needs_environment' => true)); } return $filters; } public function getFunctions() { return array( 'range' => new Twig_Function_Function('range'), 'constant' => new Twig_Function_Function('constant'), 'cycle' => new Twig_Function_Function('twig_cycle'), 'random' => new Twig_Function_Function('twig_random', array('needs_environment' => true)), 'date' => new Twig_Function_Function('twig_date_converter', array('needs_environment' => true)), ); } public function getTests() { return array( 'even' => new Twig_Test_Node('Twig_Node_Expression_Test_Even'), 'odd' => new Twig_Test_Node('Twig_Node_Expression_Test_Odd'), 'defined' => new Twig_Test_Node('Twig_Node_Expression_Test_Defined'), 'sameas' => new Twig_Test_Node('Twig_Node_Expression_Test_Sameas'), 'none' => new Twig_Test_Node('Twig_Node_Expression_Test_Null'), 'null' => new Twig_Test_Node('Twig_Node_Expression_Test_Null'), 'divisibleby' => new Twig_Test_Node('Twig_Node_Expression_Test_Divisibleby'), 'constant' => new Twig_Test_Node('Twig_Node_Expression_Test_Constant'), 'empty' => new Twig_Test_Function('twig_test_empty'), 'iterable' => new Twig_Test_Function('twig_test_iterable'), ); } public function getOperators() { return array( array( 'not' => array('precedence' => 50, 'class' => 'Twig_Node_Expression_Unary_Not'), '-' => array('precedence' => 500, 'class' => 'Twig_Node_Expression_Unary_Neg'), '+' => array('precedence' => 500, 'class' => 'Twig_Node_Expression_Unary_Pos'), ), array( 'b-and' => array('precedence' => 5, 'class' => 'Twig_Node_Expression_Binary_BitwiseAnd', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT), 'b-xor' => array('precedence' => 5, 'class' => 'Twig_Node_Expression_Binary_BitwiseXor', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT), 'b-or' => array('precedence' => 5, 'class' => 'Twig_Node_Expression_Binary_BitwiseOr', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT), 'or' => array('precedence' => 10, 'class' => 'Twig_Node_Expression_Binary_Or', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT), 'and' => array('precedence' => 15, 'class' => 'Twig_Node_Expression_Binary_And', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT), '==' => array('precedence' => 20, 'class' => 'Twig_Node_Expression_Binary_Equal', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT), '!=' => array('precedence' => 20, 'class' => 'Twig_Node_Expression_Binary_NotEqual', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT), '<' => array('precedence' => 20, 'class' => 'Twig_Node_Expression_Binary_Less', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT), '>' => array('precedence' => 20, 'class' => 'Twig_Node_Expression_Binary_Greater', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT), '>=' => array('precedence' => 20, 'class' => 'Twig_Node_Expression_Binary_GreaterEqual', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT), '<=' => array('precedence' => 20, 'class' => 'Twig_Node_Expression_Binary_LessEqual', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT), 'not in' => array('precedence' => 20, 'class' => 'Twig_Node_Expression_Binary_NotIn', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT), 'in' => array('precedence' => 20, 'class' => 'Twig_Node_Expression_Binary_In', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT), '..' => array('precedence' => 25, 'class' => 'Twig_Node_Expression_Binary_Range', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT), '+' => array('precedence' => 30, 'class' => 'Twig_Node_Expression_Binary_Add', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT), '-' => array('precedence' => 30, 'class' => 'Twig_Node_Expression_Binary_Sub', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT), '~' => array('precedence' => 40, 'class' => 'Twig_Node_Expression_Binary_Concat', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT), '*' => array('precedence' => 60, 'class' => 'Twig_Node_Expression_Binary_Mul', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT), '/' => array('precedence' => 60, 'class' => 'Twig_Node_Expression_Binary_Div', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT), '//' => array('precedence' => 60, 'class' => 'Twig_Node_Expression_Binary_FloorDiv', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT), '%' => array('precedence' => 60, 'class' => 'Twig_Node_Expression_Binary_Mod', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT), 'is' => array('precedence' => 100, 'callable' => array($this, 'parseTestExpression'), 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT), 'is not' => array('precedence' => 100, 'callable' => array($this, 'parseNotTestExpression'), 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT), '**' => array('precedence' => 200, 'class' => 'Twig_Node_Expression_Binary_Power', 'associativity' => Twig_ExpressionParser::OPERATOR_RIGHT), ), ); } public function parseNotTestExpression(Twig_Parser $parser, $node) { return new Twig_Node_Expression_Unary_Not($this->parseTestExpression($parser, $node), $parser->getCurrentToken()->getLine()); } public function parseTestExpression(Twig_Parser $parser, $node) { $stream = $parser->getStream(); $name = $stream->expect(Twig_Token::NAME_TYPE)->getValue(); $arguments = null; if ($stream->test(Twig_Token::PUNCTUATION_TYPE, '(')) { $arguments = $parser->getExpressionParser()->parseArguments(); } $class = $this->getTestNodeClass($parser->getEnvironment(), $name); return new $class($node, $name, $arguments, $parser->getCurrentToken()->getLine()); } protected function getTestNodeClass(Twig_Environment $env, $name) { $testMap = $env->getTests(); if (isset($testMap[$name]) && $testMap[$name] instanceof Twig_Test_Node) { return $testMap[$name]->getClass(); } return 'Twig_Node_Expression_Test'; } public function getName() { return 'core'; } } function twig_cycle($values, $i) { if (!is_array($values) && !$values instanceof ArrayAccess) { return $values; } return $values[$i % count($values)]; } function twig_random(Twig_Environment $env, $values = null) { if (null === $values) { return mt_rand(); } if (is_int($values) || is_float($values)) { return $values < 0 ? mt_rand($values, 0) : mt_rand(0, $values); } if ($values instanceof Traversable) { $values = iterator_to_array($values); } elseif (is_string($values)) { if ('' === $values) { return ''; } if (null !== $charset = $env->getCharset()) { if ('UTF-8' != $charset) { $values = twig_convert_encoding($values, 'UTF-8', $charset); } $values = preg_split('/(?<!^)(?!$)/u', $values); if ('UTF-8' != $charset) { foreach ($values as $i => $value) { $values[$i] = twig_convert_encoding($value, $charset, 'UTF-8'); } } } else { return $values[mt_rand(0, strlen($values) - 1)]; } } if (!is_array($values)) { return $values; } if (0 === count($values)) { throw new Twig_Error_Runtime('The random function cannot pick from an empty array.'); } return $values[array_rand($values, 1)]; } function twig_date_format_filter(Twig_Environment $env, $date, $format = null, $timezone = null) { if (null === $format) { $formats = $env->getExtension('core')->getDateFormat(); $format = $date instanceof DateInterval ? $formats[1] : $formats[0]; } if ($date instanceof DateInterval || $date instanceof DateTime) { if (null !== $timezone) { $date = clone $date; $date->setTimezone($timezone instanceof DateTimeZone ? $timezone : new DateTimeZone($timezone)); } return $date->format($format); } return twig_date_converter($env, $date, $timezone)->format($format); } function twig_date_modify_filter(Twig_Environment $env, $date, $modifier) { if ($date instanceof DateTime) { $date = clone $date; } else { $date = twig_date_converter($env, $date); } $date->modify($modifier); return $date; } function twig_date_converter(Twig_Environment $env, $date = null, $timezone = null) { if (!$date instanceof DateTime) { $asString = (string) $date; if (ctype_digit($asString) || (!empty($asString) && '-' === $asString[0] && ctype_digit(substr($asString, 1)))) { $date = new DateTime('@'.$date); } else { $date = new DateTime($date); } } else { $date = clone $date; } if (null !== $timezone) { if ($timezone instanceof DateTimeZone) { $date->setTimezone($timezone); } else { $date->setTimezone(new DateTimeZone($timezone)); } } elseif (($timezone = $env->getExtension('core')->getTimezone()) instanceof DateTimeZone) { $date->setTimezone($timezone); } else { $date->setTimezone(new DateTimeZone(date_default_timezone_get())); } return $date; } function twig_number_format_filter(Twig_Environment $env, $number, $decimal = null, $decimalPoint = null, $thousandSep = null) { $defaults = $env->getExtension('core')->getNumberFormat(); if (null === $decimal) { $decimal = $defaults[0]; } if (null === $decimalPoint) { $decimalPoint = $defaults[1]; } if (null === $thousandSep) { $thousandSep = $defaults[2]; } return number_format((float) $number, $decimal, $decimalPoint, $thousandSep); } function twig_urlencode_filter($url, $raw = false) { if ($raw) { return rawurlencode($url); } return urlencode($url); } if (version_compare(PHP_VERSION, '5.3.0', '<')) { function twig_jsonencode_filter($value, $options = 0) { if ($value instanceof Twig_Markup) { $value = (string) $value; } elseif (is_array($value)) { array_walk_recursive($value, '_twig_markup2string'); } return json_encode($value); } } else { function twig_jsonencode_filter($value, $options = 0) { if ($value instanceof Twig_Markup) { $value = (string) $value; } elseif (is_array($value)) { array_walk_recursive($value, '_twig_markup2string'); } return json_encode($value, $options); } } function _twig_markup2string(&$value) { if ($value instanceof Twig_Markup) { $value = (string) $value; } } function twig_array_merge($arr1, $arr2) { if (!is_array($arr1) || !is_array($arr2)) { throw new Twig_Error_Runtime('The merge filter only works with arrays or hashes.'); } return array_merge($arr1, $arr2); } function twig_slice(Twig_Environment $env, $item, $start, $length = null, $preserveKeys = false) { if ($item instanceof Traversable) { $item = iterator_to_array($item, false); } if (is_array($item)) { return array_slice($item, $start, $length, $preserveKeys); } $item = (string) $item; if (function_exists('mb_get_info') && null !== $charset = $env->getCharset()) { return mb_substr($item, $start, null === $length ? mb_strlen($item, $charset) - $start : $length, $charset); } return null === $length ? substr($item, $start) : substr($item, $start, $length); } function twig_join_filter($value, $glue = '') { if ($value instanceof Traversable) { $value = iterator_to_array($value, false); } return implode($glue, (array) $value); } function _twig_default_filter($value, $default = '') { if (twig_test_empty($value)) { return $default; } return $value; } function twig_get_array_keys_filter($array) { if (is_object($array) && $array instanceof Traversable) { return array_keys(iterator_to_array($array)); } if (!is_array($array)) { return array(); } return array_keys($array); } function twig_reverse_filter(Twig_Environment $env, $item, $preserveKeys = false) { if (is_object($item) && $item instanceof Traversable) { return array_reverse(iterator_to_array($item), $preserveKeys); } if (is_array($item)) { return array_reverse($item, $preserveKeys); } if (null !== $charset = $env->getCharset()) { $string = (string) $item; if ('UTF-8' != $charset) { $item = twig_convert_encoding($string, 'UTF-8', $charset); } preg_match_all('/./us', $item, $matches); $string = implode('', array_reverse($matches[0])); if ('UTF-8' != $charset) { $string = twig_convert_encoding($string, $charset, 'UTF-8'); } return $string; } return strrev((string) $item); } function twig_sort_filter($array) { asort($array); return $array; } function twig_in_filter($value, $compare) { if (is_array($compare)) { return in_array($value, $compare); } elseif (is_string($compare)) { if (!strlen((string) $value)) { return empty($compare); } return false !== strpos($compare, (string) $value); } elseif (is_object($compare) && $compare instanceof Traversable) { return in_array($value, iterator_to_array($compare, false)); } return false; } function twig_escape_filter(Twig_Environment $env, $string, $strategy = 'html', $charset = null, $autoescape = false) { if ($autoescape && is_object($string) && $string instanceof Twig_Markup) { return $string; } if (!is_string($string) && !(is_object($string) && method_exists($string, '__toString'))) { return $string; } if (null === $charset) { $charset = $env->getCharset(); } $string = (string) $string; switch ($strategy) { case 'js': if ('UTF-8' != $charset) { $string = twig_convert_encoding($string, 'UTF-8', $charset); } if (0 == strlen($string) ? false : (1 == preg_match('/^./su', $string) ? false : true)) { throw new Twig_Error_Runtime('The string to escape is not a valid UTF-8 string.'); } $string = preg_replace_callback('#[^a-zA-Z0-9,\._]#Su', '_twig_escape_js_callback', $string); if ('UTF-8' != $charset) { $string = twig_convert_encoding($string, $charset, 'UTF-8'); } return $string; case 'css': if ('UTF-8' != $charset) { $string = twig_convert_encoding($string, 'UTF-8', $charset); } if (0 == strlen($string) ? false : (1 == preg_match('/^./su', $string) ? false : true)) { throw new Twig_Error_Runtime('The string to escape is not a valid UTF-8 string.'); } $string = preg_replace_callback('#[^a-zA-Z0-9]#Su', '_twig_escape_css_callback', $string); if ('UTF-8' != $charset) { $string = twig_convert_encoding($string, $charset, 'UTF-8'); } return $string; case 'html_attr': if ('UTF-8' != $charset) { $string = twig_convert_encoding($string, 'UTF-8', $charset); } if (0 == strlen($string) ? false : (1 == preg_match('/^./su', $string) ? false : true)) { throw new Twig_Error_Runtime('The string to escape is not a valid UTF-8 string.'); } $string = preg_replace_callback('#[^a-zA-Z0-9,\.\-_]#Su', '_twig_escape_html_attr_callback', $string); if ('UTF-8' != $charset) { $string = twig_convert_encoding($string, $charset, 'UTF-8'); } return $string; case 'html': static $htmlspecialcharsCharsets = array( 'iso-8859-1' => true, 'iso8859-1' => true, 'iso-8859-15' => true, 'iso8859-15' => true, 'utf-8' => true, 'cp866' => true, 'ibm866' => true, '866' => true, 'cp1251' => true, 'windows-1251' => true, 'win-1251' => true, '1251' => true, 'cp1252' => true, 'windows-1252' => true, '1252' => true, 'koi8-r' => true, 'koi8-ru' => true, 'koi8r' => true, 'big5' => true, '950' => true, 'gb2312' => true, '936' => true, 'big5-hkscs' => true, 'shift_jis' => true, 'sjis' => true, '932' => true, 'euc-jp' => true, 'eucjp' => true, 'iso8859-5' => true, 'iso-8859-5' => true, 'macroman' => true, ); if (isset($htmlspecialcharsCharsets[strtolower($charset)])) { return htmlspecialchars($string, ENT_QUOTES | ENT_SUBSTITUTE, $charset); } $string = twig_convert_encoding($string, 'UTF-8', $charset); $string = htmlspecialchars($string, ENT_QUOTES | ENT_SUBSTITUTE, 'UTF-8'); return twig_convert_encoding($string, $charset, 'UTF-8'); case 'url': if (version_compare(PHP_VERSION, '5.3.0', '<')) { return str_replace('%7E', '~', rawurlencode($string)); } return rawurlencode($string); default: throw new Twig_Error_Runtime(sprintf('Invalid escaping strategy "%s" (valid ones: html, js, url, css, and html_attr).', $strategy)); } } function twig_escape_filter_is_safe(Twig_Node $filterArgs) { foreach ($filterArgs as $arg) { if ($arg instanceof Twig_Node_Expression_Constant) { return array($arg->getAttribute('value')); } return array(); } return array('html'); } if (function_exists('mb_convert_encoding')) { function twig_convert_encoding($string, $to, $from) { return mb_convert_encoding($string, $to, $from); } } elseif (function_exists('iconv')) { function twig_convert_encoding($string, $to, $from) { return iconv($from, $to, $string); } } else { function twig_convert_encoding($string, $to, $from) { throw new Twig_Error_Runtime('No suitable convert encoding function (use UTF-8 as your encoding or install the iconv or mbstring extension).'); } } function _twig_escape_js_callback($matches) { $char = $matches[0]; if (!isset($char[1])) { return '\\x'.strtoupper(substr('00'.bin2hex($char), -2)); } $char = twig_convert_encoding($char, 'UTF-16BE', 'UTF-8'); return '\\u'.strtoupper(substr('0000'.bin2hex($char), -4)); } function _twig_escape_css_callback($matches) { $char = $matches[0]; if (!isset($char[1])) { $hex = ltrim(strtoupper(bin2hex($char)), '0'); if (0 === strlen($hex)) { $hex = '0'; } return '\\'.$hex.' '; } $char = twig_convert_encoding($char, 'UTF-16BE', 'UTF-8'); return '\\'.ltrim(strtoupper(bin2hex($char)), '0').' '; } function _twig_escape_html_attr_callback($matches) { static $entityMap = array( 34 => 'quot', 38 => 'amp', 60 => 'lt', 62 => 'gt', ); $chr = $matches[0]; $ord = ord($chr); if (($ord <= 0x1f && $chr != "\t" && $chr != "\n" && $chr != "\r") || ($ord >= 0x7f && $ord <= 0x9f)) { return '&#xFFFD;'; } if (strlen($chr) == 1) { $hex = strtoupper(substr('00'.bin2hex($chr), -2)); } else { $chr = twig_convert_encoding($chr, 'UTF-16BE', 'UTF-8'); $hex = strtoupper(substr('0000'.bin2hex($chr), -4)); } $int = hexdec($hex); if (array_key_exists($int, $entityMap)) { return sprintf('&%s;', $entityMap[$int]); } return sprintf('&#x%s;', $hex); } if (function_exists('mb_get_info')) { function twig_length_filter(Twig_Environment $env, $thing) { return is_scalar($thing) ? mb_strlen($thing, $env->getCharset()) : count($thing); } function twig_upper_filter(Twig_Environment $env, $string) { if (null !== ($charset = $env->getCharset())) { return mb_strtoupper($string, $charset); } return strtoupper($string); } function twig_lower_filter(Twig_Environment $env, $string) { if (null !== ($charset = $env->getCharset())) { return mb_strtolower($string, $charset); } return strtolower($string); } function twig_title_string_filter(Twig_Environment $env, $string) { if (null !== ($charset = $env->getCharset())) { return mb_convert_case($string, MB_CASE_TITLE, $charset); } return ucwords(strtolower($string)); } function twig_capitalize_string_filter(Twig_Environment $env, $string) { if (null !== ($charset = $env->getCharset())) { return mb_strtoupper(mb_substr($string, 0, 1, $charset), $charset). mb_strtolower(mb_substr($string, 1, mb_strlen($string, $charset), $charset), $charset); } return ucfirst(strtolower($string)); } } else { function twig_length_filter(Twig_Environment $env, $thing) { return is_scalar($thing) ? strlen($thing) : count($thing); } function twig_title_string_filter(Twig_Environment $env, $string) { return ucwords(strtolower($string)); } function twig_capitalize_string_filter(Twig_Environment $env, $string) { return ucfirst(strtolower($string)); } } function twig_ensure_traversable($seq) { if ($seq instanceof Traversable || is_array($seq)) { return $seq; } return array(); } function twig_test_empty($value) { if ($value instanceof Countable) { return 0 == count($value); } return false === $value || (empty($value) && '0' != $value); } function twig_test_iterable($value) { return $value instanceof Traversable || is_array($value); } } namespace { class Twig_Extension_Escaper extends Twig_Extension { protected $defaultStrategy; public function __construct($defaultStrategy = 'html') { $this->setDefaultStrategy($defaultStrategy); } public function getTokenParsers() { return array(new Twig_TokenParser_AutoEscape()); } public function getNodeVisitors() { return array(new Twig_NodeVisitor_Escaper()); } public function getFilters() { return array( 'raw' => new Twig_Filter_Function('twig_raw_filter', array('is_safe' => array('all'))), ); } public function setDefaultStrategy($defaultStrategy) { if (true === $defaultStrategy) { $defaultStrategy = 'html'; } $this->defaultStrategy = $defaultStrategy; } public function getDefaultStrategy($filename) { if (!is_string($this->defaultStrategy) && is_callable($this->defaultStrategy)) { return call_user_func($this->defaultStrategy, $filename); } return $this->defaultStrategy; } public function getName() { return 'escaper'; } } function twig_raw_filter($string) { return $string; } } namespace { class Twig_Extension_Optimizer extends Twig_Extension { protected $optimizers; public function __construct($optimizers = -1) { $this->optimizers = $optimizers; } public function getNodeVisitors() { return array(new Twig_NodeVisitor_Optimizer($this->optimizers)); } public function getName() { return 'optimizer'; } } } namespace { interface Twig_FilterInterface { function compile(); function needsEnvironment(); function needsContext(); function getSafe(Twig_Node $filterArgs); function getPreservesSafety(); function getPreEscape(); function setArguments($arguments); function getArguments(); } } namespace { abstract class Twig_Filter implements Twig_FilterInterface { protected $options; protected $arguments = array(); public function __construct(array $options = array()) { $this->options = array_merge(array( 'needs_environment' => false, 'needs_context' => false, 'pre_escape' => null, 'preserves_safety' => null, ), $options); } public function setArguments($arguments) { $this->arguments = $arguments; } public function getArguments() { return $this->arguments; } public function needsEnvironment() { return $this->options['needs_environment']; } public function needsContext() { return $this->options['needs_context']; } public function getSafe(Twig_Node $filterArgs) { if (isset($this->options['is_safe'])) { return $this->options['is_safe']; } if (isset($this->options['is_safe_callback'])) { return call_user_func($this->options['is_safe_callback'], $filterArgs); } return null; } public function getPreservesSafety() { return $this->options['preserves_safety']; } public function getPreEscape() { return $this->options['pre_escape']; } } } namespace { class Twig_Filter_Function extends Twig_Filter { protected $function; public function __construct($function, array $options = array()) { parent::__construct($options); $this->function = $function; } public function compile() { return $this->function; } } } namespace { class Twig_Filter_Method extends Twig_Filter { protected $extension; protected $method; public function __construct(Twig_ExtensionInterface $extension, $method, array $options = array()) { parent::__construct($options); $this->extension = $extension; $this->method = $method; } public function compile() { return sprintf('$this->env->getExtension(\'%s\')->%s', $this->extension->getName(), $this->method); } } } namespace { interface Twig_FunctionInterface { function compile(); function needsEnvironment(); function needsContext(); function getSafe(Twig_Node $filterArgs); function setArguments($arguments); function getArguments(); } } namespace { abstract class Twig_Function implements Twig_FunctionInterface { protected $options; protected $arguments = array(); public function __construct(array $options = array()) { $this->options = array_merge(array( 'needs_environment' => false, 'needs_context' => false, ), $options); } public function setArguments($arguments) { $this->arguments = $arguments; } public function getArguments() { return $this->arguments; } public function needsEnvironment() { return $this->options['needs_environment']; } public function needsContext() { return $this->options['needs_context']; } public function getSafe(Twig_Node $functionArgs) { if (isset($this->options['is_safe'])) { return $this->options['is_safe']; } if (isset($this->options['is_safe_callback'])) { return call_user_func($this->options['is_safe_callback'], $functionArgs); } return array(); } } } namespace { class Twig_Function_Function extends Twig_Function { protected $function; public function __construct($function, array $options = array()) { parent::__construct($options); $this->function = $function; } public function compile() { return $this->function; } } } namespace { class Twig_Function_Method extends Twig_Function { protected $extension; protected $method; public function __construct(Twig_ExtensionInterface $extension, $method, array $options = array()) { parent::__construct($options); $this->extension = $extension; $this->method = $method; } public function compile() { return sprintf('$this->env->getExtension(\'%s\')->%s', $this->extension->getName(), $this->method); } } } namespace { interface Twig_LoaderInterface { function getSource($name); function getCacheKey($name); function isFresh($name, $time); } } namespace { class Twig_Markup implements Countable { protected $content; protected $charset; public function __construct($content, $charset) { $this->content = (string) $content; $this->charset = $charset; } public function __toString() { return $this->content; } public function count() { return function_exists('mb_get_info') ? mb_strlen($this->content, $this->charset) : strlen($this->content); } } } namespace { interface Twig_TemplateInterface { const ANY_CALL = 'any'; const ARRAY_CALL = 'array'; const METHOD_CALL = 'method'; function render(array $context); function display(array $context, array $blocks = array()); function getEnvironment(); } } namespace { abstract class Twig_Template implements Twig_TemplateInterface { static protected $cache = array(); protected $parent; protected $parents; protected $env; protected $blocks; protected $traits; public function __construct(Twig_Environment $env) { $this->env = $env; $this->blocks = array(); $this->traits = array(); } abstract public function getTemplateName(); public function getEnvironment() { return $this->env; } public function getParent(array $context) { if (null !== $this->parent) { return $this->parent; } $parent = $this->doGetParent($context); if (false === $parent) { return false; } elseif ($parent instanceof Twig_Template) { $name = $parent->getTemplateName(); $this->parents[$name] = $parent; $parent = $name; } elseif (!isset($this->parents[$parent])) { $this->parents[$parent] = $this->env->loadTemplate($parent); } return $this->parents[$parent]; } protected function doGetParent(array $context) { return false; } public function isTraitable() { return true; } public function displayParentBlock($name, array $context, array $blocks = array()) { $name = (string) $name; if (isset($this->traits[$name])) { $this->traits[$name][0]->displayBlock($name, $context, $blocks); } elseif (false !== $parent = $this->getParent($context)) { $parent->displayBlock($name, $context, $blocks); } else { throw new Twig_Error_Runtime(sprintf('The template has no parent and no traits defining the "%s" block', $name), -1, $this->getTemplateName()); } } public function displayBlock($name, array $context, array $blocks = array()) { $name = (string) $name; if (isset($blocks[$name])) { $b = $blocks; unset($b[$name]); call_user_func($blocks[$name], $context, $b); } elseif (isset($this->blocks[$name])) { call_user_func($this->blocks[$name], $context, $blocks); } elseif (false !== $parent = $this->getParent($context)) { $parent->displayBlock($name, $context, array_merge($this->blocks, $blocks)); } } public function renderParentBlock($name, array $context, array $blocks = array()) { ob_start(); $this->displayParentBlock($name, $context, $blocks); return ob_get_clean(); } public function renderBlock($name, array $context, array $blocks = array()) { ob_start(); $this->displayBlock($name, $context, $blocks); return ob_get_clean(); } public function hasBlock($name) { return isset($this->blocks[(string) $name]); } public function getBlockNames() { return array_keys($this->blocks); } public function getBlocks() { return $this->blocks; } public function display(array $context, array $blocks = array()) { $this->displayWithErrorHandling($this->env->mergeGlobals($context), $blocks); } public function render(array $context) { $level = ob_get_level(); ob_start(); try { $this->display($context); } catch (Exception $e) { while (ob_get_level() > $level) { ob_end_clean(); } throw $e; } return ob_get_clean(); } protected function displayWithErrorHandling(array $context, array $blocks = array()) { try { $this->doDisplay($context, $blocks); } catch (Twig_Error $e) { throw $e; } catch (Exception $e) { throw new Twig_Error_Runtime(sprintf('An exception has been thrown during the rendering of a template ("%s").', $e->getMessage()), -1, null, $e); } } abstract protected function doDisplay(array $context, array $blocks = array()); final protected function getContext($context, $item, $ignoreStrictCheck = false) { if (!array_key_exists($item, $context)) { if ($ignoreStrictCheck || !$this->env->isStrictVariables()) { return null; } throw new Twig_Error_Runtime(sprintf('Variable "%s" does not exist', $item)); } return $context[$item]; } protected function getAttribute($object, $item, array $arguments = array(), $type = Twig_TemplateInterface::ANY_CALL, $isDefinedTest = false, $ignoreStrictCheck = false) { $item = ctype_digit((string) $item) ? (int) $item : (string) $item; if (Twig_TemplateInterface::METHOD_CALL !== $type) { if ((is_array($object) && array_key_exists($item, $object)) || ($object instanceof ArrayAccess && isset($object[$item])) ) { if ($isDefinedTest) { return true; } return $object[$item]; } if (Twig_TemplateInterface::ARRAY_CALL === $type) { if ($isDefinedTest) { return false; } if ($ignoreStrictCheck || !$this->env->isStrictVariables()) { return null; } if (is_object($object)) { throw new Twig_Error_Runtime(sprintf('Key "%s" in object (with ArrayAccess) of type "%s" does not exist', $item, get_class($object))); } elseif (is_array($object)) { throw new Twig_Error_Runtime(sprintf('Key "%s" for array with keys "%s" does not exist', $item, implode(', ', array_keys($object)))); } else { throw new Twig_Error_Runtime(sprintf('Impossible to access a key ("%s") on a "%s" variable', $item, gettype($object))); } } } if (!is_object($object)) { if ($isDefinedTest) { return false; } if ($ignoreStrictCheck || !$this->env->isStrictVariables()) { return null; } throw new Twig_Error_Runtime(sprintf('Item "%s" for "%s" does not exist', $item, is_array($object) ? 'Array' : $object)); } $class = get_class($object); if (Twig_TemplateInterface::METHOD_CALL !== $type) { if (isset($object->$item) || array_key_exists($item, $object)) { if ($isDefinedTest) { return true; } if ($this->env->hasExtension('sandbox')) { $this->env->getExtension('sandbox')->checkPropertyAllowed($object, $item); } return $object->$item; } } if (!isset(self::$cache[$class]['methods'])) { self::$cache[$class]['methods'] = array_change_key_case(array_flip(get_class_methods($object))); } $lcItem = strtolower($item); if (isset(self::$cache[$class]['methods'][$lcItem])) { $method = $item; } elseif (isset(self::$cache[$class]['methods']['get'.$lcItem])) { $method = 'get'.$item; } elseif (isset(self::$cache[$class]['methods']['is'.$lcItem])) { $method = 'is'.$item; } elseif (isset(self::$cache[$class]['methods']['__call'])) { $method = $item; } else { if ($isDefinedTest) { return false; } if ($ignoreStrictCheck || !$this->env->isStrictVariables()) { return null; } throw new Twig_Error_Runtime(sprintf('Method "%s" for object "%s" does not exist', $item, get_class($object))); } if ($isDefinedTest) { return true; } if ($this->env->hasExtension('sandbox')) { $this->env->getExtension('sandbox')->checkMethodAllowed($object, $method); } $ret = call_user_func_array(array($object, $method), $arguments); if ($object instanceof Twig_TemplateInterface) { return $ret === '' ? '' : new Twig_Markup($ret, $this->env->getCharset()); } return $ret; } static public function clearCache() { self::$cache = array(); } } } namespace Symfony\Component\Console\Helper { interface HelperInterface { public function setHelperSet(HelperSet $helperSet = null); public function getHelperSet(); public function getName(); } } namespace Symfony\Component\Console\Helper { abstract class Helper implements HelperInterface { protected $helperSet = null; public function setHelperSet(HelperSet $helperSet = null) { $this->helperSet = $helperSet; } public function getHelperSet() { return $this->helperSet; } } } namespace Symfony\Component\Console\Helper { use Symfony\Component\Console\Command\Command; class HelperSet { private $helpers; private $command; public function __construct(array $helpers = array()) { $this->helpers = array(); foreach ($helpers as $alias => $helper) { $this->set($helper, is_int($alias) ? null : $alias); } } public function set(HelperInterface $helper, $alias = null) { $this->helpers[$helper->getName()] = $helper; if (null !== $alias) { $this->helpers[$alias] = $helper; } $helper->setHelperSet($this); } public function has($name) { return isset($this->helpers[$name]); } public function get($name) { if (!$this->has($name)) { throw new \InvalidArgumentException(sprintf('The helper "%s" is not defined.', $name)); } return $this->helpers[$name]; } public function setCommand(Command $command = null) { $this->command = $command; } public function getCommand() { return $this->command; } } } namespace Symfony\Component\Console\Helper { use Symfony\Component\Console\Output\OutputInterface; class DialogHelper extends Helper { private $inputStream; public function ask(OutputInterface $output, $question, $default = null) { $output->write($question); $ret = fgets($this->inputStream ?: STDIN, 4096); if (false === $ret) { throw new \RuntimeException('Aborted'); } $ret = trim($ret); return strlen($ret) > 0 ? $ret : $default; } public function askConfirmation(OutputInterface $output, $question, $default = true) { $answer = 'z'; while ($answer && !in_array(strtolower($answer[0]), array('y', 'n'))) { $answer = $this->ask($output, $question); } if (false === $default) { return $answer && 'y' == strtolower($answer[0]); } return !$answer || 'y' == strtolower($answer[0]); } public function askAndValidate(OutputInterface $output, $question, $validator, $attempts = false, $default = null) { $error = null; while (false === $attempts || $attempts--) { if (null !== $error) { $output->writeln($this->getHelperSet()->get('formatter')->formatBlock($error->getMessage(), 'error')); } $value = $this->ask($output, $question, $default); try { return call_user_func($validator, $value); } catch (\Exception $error) { } } throw $error; } public function setInputStream($stream) { $this->inputStream = $stream; } public function getInputStream() { return $this->inputStream; } public function getName() { return 'dialog'; } } } namespace Symfony\Component\Console\Helper { use Symfony\Component\Console\Formatter\OutputFormatter; class FormatterHelper extends Helper { public function formatSection($section, $message, $style = 'info') { return sprintf('<%s>[%s]</%s> %s', $style, $section, $style, $message); } public function formatBlock($messages, $style, $large = false) { $messages = (array) $messages; $len = 0; $lines = array(); foreach ($messages as $message) { $message = OutputFormatter::escape($message); $lines[] = sprintf($large ? '  %s  ' : ' %s ', $message); $len = max($this->strlen($message) + ($large ? 4 : 2), $len); } $messages = $large ? array(str_repeat(' ', $len)) : array(); foreach ($lines as $line) { $messages[] = $line.str_repeat(' ', $len - $this->strlen($line)); } if ($large) { $messages[] = str_repeat(' ', $len); } foreach ($messages as &$message) { $message = sprintf('<%s>%s</%s>', $style, $message, $style); } return implode("\n", $messages); } private function strlen($string) { if (!function_exists('mb_strlen')) { return strlen($string); } if (false === $encoding = mb_detect_encoding($string)) { return strlen($string); } return mb_strlen($string, $encoding); } public function getName() { return 'formatter'; } } } namespace Symfony\Component\Console\Command { use Symfony\Component\Console\Input\InputDefinition; use Symfony\Component\Console\Input\InputOption; use Symfony\Component\Console\Input\InputArgument; use Symfony\Component\Console\Input\InputInterface; use Symfony\Component\Console\Output\OutputInterface; use Symfony\Component\Console\Application; use Symfony\Component\Console\Helper\HelperSet; class Command { private $application; private $name; private $aliases; private $definition; private $help; private $description; private $ignoreValidationErrors; private $applicationDefinitionMerged; private $code; private $synopsis; private $helperSet; public function __construct($name = null) { $this->definition = new InputDefinition(); $this->ignoreValidationErrors = false; $this->applicationDefinitionMerged = false; $this->aliases = array(); if (null !== $name) { $this->setName($name); } $this->configure(); if (!$this->name) { throw new \LogicException('The command name cannot be empty.'); } } public function ignoreValidationErrors() { $this->ignoreValidationErrors = true; } public function setApplication(Application $application = null) { $this->application = $application; if ($application) { $this->setHelperSet($application->getHelperSet()); } else { $this->helperSet = null; } } public function setHelperSet(HelperSet $helperSet) { $this->helperSet = $helperSet; } public function getHelperSet() { return $this->helperSet; } public function getApplication() { return $this->application; } public function isEnabled() { return true; } protected function configure() { } protected function execute(InputInterface $input, OutputInterface $output) { throw new \LogicException('You must override the execute() method in the concrete command class.'); } protected function interact(InputInterface $input, OutputInterface $output) { } protected function initialize(InputInterface $input, OutputInterface $output) { } public function run(InputInterface $input, OutputInterface $output) { $this->getSynopsis(); $this->mergeApplicationDefinition(); try { $input->bind($this->definition); } catch (\Exception $e) { if (!$this->ignoreValidationErrors) { throw $e; } } $this->initialize($input, $output); if ($input->isInteractive()) { $this->interact($input, $output); } $input->validate(); if ($this->code) { return call_user_func($this->code, $input, $output); } return $this->execute($input, $output); } public function setCode(\Closure $code) { $this->code = $code; return $this; } private function mergeApplicationDefinition() { if (null === $this->application || true === $this->applicationDefinitionMerged) { return; } $currentArguments = $this->definition->getArguments(); $this->definition->setArguments($this->application->getDefinition()->getArguments()); $this->definition->addArguments($currentArguments); $this->definition->addOptions($this->application->getDefinition()->getOptions()); $this->applicationDefinitionMerged = true; } public function setDefinition($definition) { if ($definition instanceof InputDefinition) { $this->definition = $definition; } else { $this->definition->setDefinition($definition); } $this->applicationDefinitionMerged = false; return $this; } public function getDefinition() { return $this->definition; } protected function getNativeDefinition() { return $this->getDefinition(); } public function addArgument($name, $mode = null, $description = '', $default = null) { $this->definition->addArgument(new InputArgument($name, $mode, $description, $default)); return $this; } public function addOption($name, $shortcut = null, $mode = null, $description = '', $default = null) { $this->definition->addOption(new InputOption($name, $shortcut, $mode, $description, $default)); return $this; } public function setName($name) { $this->validateName($name); $this->name = $name; return $this; } public function getName() { return $this->name; } public function setDescription($description) { $this->description = $description; return $this; } public function getDescription() { return $this->description; } public function setHelp($help) { $this->help = $help; return $this; } public function getHelp() { return $this->help; } public function getProcessedHelp() { $name = $this->name; $placeholders = array( '%command.name%', '%command.full_name%' ); $replacements = array( $name, $_SERVER['PHP_SELF'].' '.$name ); return str_replace($placeholders, $replacements, $this->getHelp()); } public function setAliases($aliases) { foreach ($aliases as $alias) { $this->validateName($alias); } $this->aliases = $aliases; return $this; } public function getAliases() { return $this->aliases; } public function getSynopsis() { if (null === $this->synopsis) { $this->synopsis = trim(sprintf('%s %s', $this->name, $this->definition->getSynopsis())); } return $this->synopsis; } public function getHelper($name) { return $this->helperSet->get($name); } public function asText() { $messages = array( '<comment>Usage:</comment>', ' '.$this->getSynopsis(), '', ); if ($this->getAliases()) { $messages[] = '<comment>Aliases:</comment> <info>'.implode(', ', $this->getAliases()).'</info>'; } $messages[] = $this->getNativeDefinition()->asText(); if ($help = $this->getProcessedHelp()) { $messages[] = '<comment>Help:</comment>'; $messages[] = ' '.str_replace("\n", "\n ", $help)."\n"; } return implode("\n", $messages); } public function asXml($asDom = false) { $dom = new \DOMDocument('1.0', 'UTF-8'); $dom->formatOutput = true; $dom->appendChild($commandXML = $dom->createElement('command')); $commandXML->setAttribute('id', $this->name); $commandXML->setAttribute('name', $this->name); $commandXML->appendChild($usageXML = $dom->createElement('usage')); $usageXML->appendChild($dom->createTextNode(sprintf($this->getSynopsis(), ''))); $commandXML->appendChild($descriptionXML = $dom->createElement('description')); $descriptionXML->appendChild($dom->createTextNode(str_replace("\n", "\n ", $this->getDescription()))); $commandXML->appendChild($helpXML = $dom->createElement('help')); $helpXML->appendChild($dom->createTextNode(str_replace("\n", "\n ", $this->getProcessedHelp()))); $commandXML->appendChild($aliasesXML = $dom->createElement('aliases')); foreach ($this->getAliases() as $alias) { $aliasesXML->appendChild($aliasXML = $dom->createElement('alias')); $aliasXML->appendChild($dom->createTextNode($alias)); } $definition = $this->getNativeDefinition()->asXml(true); $commandXML->appendChild($dom->importNode($definition->getElementsByTagName('arguments')->item(0), true)); $commandXML->appendChild($dom->importNode($definition->getElementsByTagName('options')->item(0), true)); return $asDom ? $dom : $dom->saveXml(); } private function validateName($name) { if (!preg_match('/^[^\:]+(\:[^\:]+)*$/', $name)) { throw new \InvalidArgumentException(sprintf('Command name "%s" is invalid.', $name)); } } } } namespace Symfony\Component\Console\Command { use Symfony\Component\Console\Input\InputArgument; use Symfony\Component\Console\Input\InputOption; use Symfony\Component\Console\Input\InputInterface; use Symfony\Component\Console\Output\OutputInterface; use Symfony\Component\Console\Output\Output; use Symfony\Component\Console\Command\Command; class HelpCommand extends Command { private $command; protected function configure() { $this->ignoreValidationErrors(); $this ->setName('help') ->setDefinition(array( new InputArgument('command_name', InputArgument::OPTIONAL, 'The command name', 'help'), new InputOption('xml', null, InputOption::VALUE_NONE, 'To output help as XML'), )) ->setDescription('Displays help for a command') ->setHelp(<<<EOF
The <info>%command.name%</info> command displays help for a given command:

  <info>php %command.full_name% list</info>

You can also output the help as XML by using the <comment>--xml</comment> option:

  <info>php %command.full_name% --xml list</info>
EOF
) ; } public function setCommand(Command $command) { $this->command = $command; } protected function execute(InputInterface $input, OutputInterface $output) { if (null === $this->command) { $this->command = $this->getApplication()->get($input->getArgument('command_name')); } if ($input->getOption('xml')) { $output->writeln($this->command->asXml(), OutputInterface::OUTPUT_RAW); } else { $output->writeln($this->command->asText()); } $this->command = null; } } } namespace Symfony\Component\Console\Command { use Symfony\Component\Console\Input\InputArgument; use Symfony\Component\Console\Input\InputOption; use Symfony\Component\Console\Input\InputInterface; use Symfony\Component\Console\Output\OutputInterface; use Symfony\Component\Console\Output\Output; use Symfony\Component\Console\Command\Command; use Symfony\Component\Console\Input\InputDefinition; class ListCommand extends Command { protected function configure() { $this ->setName('list') ->setDefinition($this->createDefinition()) ->setDescription('Lists commands') ->setHelp(<<<EOF
The <info>%command.name%</info> command lists all commands:

  <info>php %command.full_name%</info>

You can also display the commands for a specific namespace:

  <info>php %command.full_name% test</info>

You can also output the information as XML by using the <comment>--xml</comment> option:

  <info>php %command.full_name% --xml</info>

It's also possible to get raw list of commands (useful for embedding command runner):

  <info>php %command.full_name% --raw</info>
EOF
) ; } protected function getNativeDefinition() { return $this->createDefinition(); } protected function execute(InputInterface $input, OutputInterface $output) { if ($input->getOption('xml')) { $output->writeln($this->getApplication()->asXml($input->getArgument('namespace')), OutputInterface::OUTPUT_RAW); } else { $output->writeln($this->getApplication()->asText($input->getArgument('namespace'), $input->getOption('raw'))); } } private function createDefinition() { return new InputDefinition(array( new InputArgument('namespace', InputArgument::OPTIONAL, 'The namespace name'), new InputOption('xml', null, InputOption::VALUE_NONE, 'To output help as XML'), new InputOption('raw', null, InputOption::VALUE_NONE, 'To output raw command list'), )); } } } namespace Symfony\Component\Console\Formatter { interface OutputFormatterInterface { public function setDecorated($decorated); public function isDecorated(); public function setStyle($name, OutputFormatterStyleInterface $style); public function hasStyle($name); public function getStyle($name); public function format($message); } } namespace Symfony\Component\Console\Formatter { class OutputFormatter implements OutputFormatterInterface { const FORMAT_PATTERN = '#(\\\\?)<(/?)([a-z][a-z0-9_=;-]+)?>((?:(?!\\\\?<).)*)#is'; private $decorated; private $styles = array(); private $styleStack; public static function escape($text) { return preg_replace('/([^\\\\]?)</is', '$1\\<', $text); } public function __construct($decorated = null, array $styles = array()) { $this->decorated = (Boolean) $decorated; $this->setStyle('error', new OutputFormatterStyle('white', 'red')); $this->setStyle('info', new OutputFormatterStyle('green')); $this->setStyle('comment', new OutputFormatterStyle('yellow')); $this->setStyle('question', new OutputFormatterStyle('black', 'cyan')); foreach ($styles as $name => $style) { $this->setStyle($name, $style); } $this->styleStack = new OutputFormatterStyleStack(); } public function setDecorated($decorated) { $this->decorated = (Boolean) $decorated; } public function isDecorated() { return $this->decorated; } public function setStyle($name, OutputFormatterStyleInterface $style) { $this->styles[strtolower($name)] = $style; } public function hasStyle($name) { return isset($this->styles[strtolower($name)]); } public function getStyle($name) { if (!$this->hasStyle($name)) { throw new \InvalidArgumentException('Undefined style: '.$name); } return $this->styles[strtolower($name)]; } public function format($message) { $message = preg_replace_callback(self::FORMAT_PATTERN, array($this, 'replaceStyle'), $message); return str_replace('\\<', '<', $message); } public function getStyleStack() { return $this->styleStack; } private function replaceStyle($match) { if ('\\' === $match[1]) { return $match[0]; } if ('' === $match[3]) { if ('/' === $match[2]) { $this->styleStack->pop(); return $this->applyStyle($this->styleStack->getCurrent(), $match[4]); } return '<>'.$match[4]; } if (isset($this->styles[strtolower($match[3])])) { $style = $this->styles[strtolower($match[3])]; } else { $style = $this->createStyleFromString($match[3]); if (false === $style) { return $match[0]; } } if ('/' === $match[2]) { $this->styleStack->pop($style); } else { $this->styleStack->push($style); } return $this->applyStyle($this->styleStack->getCurrent(), $match[4]); } private function createStyleFromString($string) { if (!preg_match_all('/([^=]+)=([^;]+)(;|$)/', strtolower($string), $matches, PREG_SET_ORDER)) { return false; } $style = new OutputFormatterStyle(); foreach ($matches as $match) { array_shift($match); if ('fg' == $match[0]) { $style->setForeground($match[1]); } elseif ('bg' == $match[0]) { $style->setBackground($match[1]); } else { $style->setOption($match[1]); } } return $style; } private function applyStyle(OutputFormatterStyleInterface $style, $text) { return $this->isDecorated() && strlen($text) > 0 ? $style->apply($text) : $text; } } } namespace Symfony\Component\Console\Formatter { interface OutputFormatterStyleInterface { public function setForeground($color = null); public function setBackground($color = null); public function setOption($option); public function unsetOption($option); public function setOptions(array $options); public function apply($text); } } namespace Symfony\Component\Console\Formatter { class OutputFormatterStyle implements OutputFormatterStyleInterface { private static $availableForegroundColors = array( 'black' => 30, 'red' => 31, 'green' => 32, 'yellow' => 33, 'blue' => 34, 'magenta' => 35, 'cyan' => 36, 'white' => 37 ); private static $availableBackgroundColors = array( 'black' => 40, 'red' => 41, 'green' => 42, 'yellow' => 43, 'blue' => 44, 'magenta' => 45, 'cyan' => 46, 'white' => 47 ); private static $availableOptions = array( 'bold' => 1, 'underscore' => 4, 'blink' => 5, 'reverse' => 7, 'conceal' => 8 ); private $foreground; private $background; private $options = array(); public function __construct($foreground = null, $background = null, array $options = array()) { if (null !== $foreground) { $this->setForeground($foreground); } if (null !== $background) { $this->setBackground($background); } if (count($options)) { $this->setOptions($options); } } public function setForeground($color = null) { if (null === $color) { $this->foreground = null; return; } if (!isset(static::$availableForegroundColors[$color])) { throw new \InvalidArgumentException(sprintf( 'Invalid foreground color specified: "%s". Expected one of (%s)', $color, implode(', ', array_keys(static::$availableForegroundColors)) )); } $this->foreground = static::$availableForegroundColors[$color]; } public function setBackground($color = null) { if (null === $color) { $this->background = null; return; } if (!isset(static::$availableBackgroundColors[$color])) { throw new \InvalidArgumentException(sprintf( 'Invalid background color specified: "%s". Expected one of (%s)', $color, implode(', ', array_keys(static::$availableBackgroundColors)) )); } $this->background = static::$availableBackgroundColors[$color]; } public function setOption($option) { if (!isset(static::$availableOptions[$option])) { throw new \InvalidArgumentException(sprintf( 'Invalid option specified: "%s". Expected one of (%s)', $option, implode(', ', array_keys(static::$availableOptions)) )); } if (false === array_search(static::$availableOptions[$option], $this->options)) { $this->options[] = static::$availableOptions[$option]; } } public function unsetOption($option) { if (!isset(static::$availableOptions[$option])) { throw new \InvalidArgumentException(sprintf( 'Invalid option specified: "%s". Expected one of (%s)', $option, implode(', ', array_keys(static::$availableOptions)) )); } $pos = array_search(static::$availableOptions[$option], $this->options); if (false !== $pos) { unset($this->options[$pos]); } } public function setOptions(array $options) { $this->options = array(); foreach ($options as $option) { $this->setOption($option); } } public function apply($text) { $codes = array(); if (null !== $this->foreground) { $codes[] = $this->foreground; } if (null !== $this->background) { $codes[] = $this->background; } if (count($this->options)) { $codes = array_merge($codes, $this->options); } return sprintf("\033[%sm%s\033[0m", implode(';', $codes), $text); } } } namespace Symfony\Component\Console\Formatter { class OutputFormatterStyleStack { private $styles; private $emptyStyle; public function __construct(OutputFormatterStyleInterface $emptyStyle = null) { $this->emptyStyle = $emptyStyle ?: new OutputFormatterStyle(); $this->reset(); } public function reset() { $this->styles = array(); } public function push(OutputFormatterStyleInterface $style) { $this->styles[] = $style; } public function pop(OutputFormatterStyleInterface $style = null) { if (empty($this->styles)) { return $this->emptyStyle; } if (null === $style) { return array_pop($this->styles); } foreach (array_reverse($this->styles, true) as $index => $stackedStyle) { if ($style->apply('') === $stackedStyle->apply('')) { $this->styles = array_slice($this->styles, 0, $index); return $stackedStyle; } } throw new \InvalidArgumentException('Incorrectly nested style tag found.'); } public function getCurrent() { if (empty($this->styles)) { return $this->emptyStyle; } return $this->styles[count($this->styles)-1]; } public function setEmptyStyle(OutputFormatterStyleInterface $emptyStyle) { $this->emptyStyle = $emptyStyle; return $this; } public function getEmptyStyle() { return $this->emptyStyle; } } } namespace Symfony\Component\Console\Input { interface InputInterface { public function getFirstArgument(); public function hasParameterOption($values); public function getParameterOption($values, $default = false); public function bind(InputDefinition $definition); public function validate(); public function getArguments(); public function getArgument($name); public function setArgument($name, $value); public function hasArgument($name); public function getOptions(); public function getOption($name); public function setOption($name, $value); public function hasOption($name); public function isInteractive(); public function setInteractive($interactive); } } namespace Symfony\Component\Console\Input { abstract class Input implements InputInterface { protected $definition; protected $options; protected $arguments; protected $interactive = true; public function __construct(InputDefinition $definition = null) { if (null === $definition) { $this->definition = new InputDefinition(); } else { $this->bind($definition); $this->validate(); } } public function bind(InputDefinition $definition) { $this->arguments = array(); $this->options = array(); $this->definition = $definition; $this->parse(); } abstract protected function parse(); public function validate() { if (count($this->arguments) < $this->definition->getArgumentRequiredCount()) { throw new \RuntimeException('Not enough arguments.'); } } public function isInteractive() { return $this->interactive; } public function setInteractive($interactive) { $this->interactive = (Boolean) $interactive; } public function getArguments() { return array_merge($this->definition->getArgumentDefaults(), $this->arguments); } public function getArgument($name) { if (!$this->definition->hasArgument($name)) { throw new \InvalidArgumentException(sprintf('The "%s" argument does not exist.', $name)); } return isset($this->arguments[$name]) ? $this->arguments[$name] : $this->definition->getArgument($name)->getDefault(); } public function setArgument($name, $value) { if (!$this->definition->hasArgument($name)) { throw new \InvalidArgumentException(sprintf('The "%s" argument does not exist.', $name)); } $this->arguments[$name] = $value; } public function hasArgument($name) { return $this->definition->hasArgument($name); } public function getOptions() { return array_merge($this->definition->getOptionDefaults(), $this->options); } public function getOption($name) { if (!$this->definition->hasOption($name)) { throw new \InvalidArgumentException(sprintf('The "%s" option does not exist.', $name)); } return isset($this->options[$name]) ? $this->options[$name] : $this->definition->getOption($name)->getDefault(); } public function setOption($name, $value) { if (!$this->definition->hasOption($name)) { throw new \InvalidArgumentException(sprintf('The "%s" option does not exist.', $name)); } $this->options[$name] = $value; } public function hasOption($name) { return $this->definition->hasOption($name); } } } namespace Symfony\Component\Console\Input { class ArgvInput extends Input { private $tokens; private $parsed; public function __construct(array $argv = null, InputDefinition $definition = null) { if (null === $argv) { $argv = $_SERVER['argv']; } array_shift($argv); $this->tokens = $argv; parent::__construct($definition); } protected function setTokens(array $tokens) { $this->tokens = $tokens; } protected function parse() { $parseOptions = true; $this->parsed = $this->tokens; while (null !== $token = array_shift($this->parsed)) { if ($parseOptions && '' == $token) { $this->parseArgument($token); } elseif ($parseOptions && '--' == $token) { $parseOptions = false; } elseif ($parseOptions && 0 === strpos($token, '--')) { $this->parseLongOption($token); } elseif ($parseOptions && '-' === $token[0]) { $this->parseShortOption($token); } else { $this->parseArgument($token); } } } private function parseShortOption($token) { $name = substr($token, 1); if (strlen($name) > 1) { if ($this->definition->hasShortcut($name[0]) && $this->definition->getOptionForShortcut($name[0])->acceptValue()) { $this->addShortOption($name[0], substr($name, 1)); } else { $this->parseShortOptionSet($name); } } else { $this->addShortOption($name, null); } } private function parseShortOptionSet($name) { $len = strlen($name); for ($i = 0; $i < $len; $i++) { if (!$this->definition->hasShortcut($name[$i])) { throw new \RuntimeException(sprintf('The "-%s" option does not exist.', $name[$i])); } $option = $this->definition->getOptionForShortcut($name[$i]); if ($option->acceptValue()) { $this->addLongOption($option->getName(), $i === $len - 1 ? null : substr($name, $i + 1)); break; } else { $this->addLongOption($option->getName(), true); } } } private function parseLongOption($token) { $name = substr($token, 2); if (false !== $pos = strpos($name, '=')) { $this->addLongOption(substr($name, 0, $pos), substr($name, $pos + 1)); } else { $this->addLongOption($name, null); } } private function parseArgument($token) { $c = count($this->arguments); if ($this->definition->hasArgument($c)) { $arg = $this->definition->getArgument($c); $this->arguments[$arg->getName()] = $arg->isArray()? array($token) : $token; } elseif ($this->definition->hasArgument($c - 1) && $this->definition->getArgument($c - 1)->isArray()) { $arg = $this->definition->getArgument($c - 1); $this->arguments[$arg->getName()][] = $token; } else { throw new \RuntimeException('Too many arguments.'); } } private function addShortOption($shortcut, $value) { if (!$this->definition->hasShortcut($shortcut)) { throw new \RuntimeException(sprintf('The "-%s" option does not exist.', $shortcut)); } $this->addLongOption($this->definition->getOptionForShortcut($shortcut)->getName(), $value); } private function addLongOption($name, $value) { if (!$this->definition->hasOption($name)) { throw new \RuntimeException(sprintf('The "--%s" option does not exist.', $name)); } $option = $this->definition->getOption($name); if (null === $value && $option->acceptValue()) { $next = array_shift($this->parsed); if ('-' !== $next[0]) { $value = $next; } else { array_unshift($this->parsed, $next); } } if (null === $value) { if ($option->isValueRequired()) { throw new \RuntimeException(sprintf('The "--%s" option requires a value.', $name)); } $value = $option->isValueOptional() ? $option->getDefault() : true; } if ($option->isArray()) { $this->options[$name][] = $value; } else { $this->options[$name] = $value; } } public function getFirstArgument() { foreach ($this->tokens as $token) { if ($token && '-' === $token[0]) { continue; } return $token; } } public function hasParameterOption($values) { $values = (array) $values; foreach ($this->tokens as $v) { if (in_array($v, $values)) { return true; } } return false; } public function getParameterOption($values, $default = false) { $values = (array) $values; $tokens = $this->tokens; while ($token = array_shift($tokens)) { foreach ($values as $value) { if (0 === strpos($token, $value)) { if (false !== $pos = strpos($token, '=')) { return substr($token, $pos + 1); } return array_shift($tokens); } } } return $default; } } } namespace Symfony\Component\Console\Input { class ArrayInput extends Input { private $parameters; public function __construct(array $parameters, InputDefinition $definition = null) { $this->parameters = $parameters; parent::__construct($definition); } public function getFirstArgument() { foreach ($this->parameters as $key => $value) { if ($key && '-' === $key[0]) { continue; } return $value; } } public function hasParameterOption($values) { $values = (array) $values; foreach ($this->parameters as $k => $v) { if (!is_int($k)) { $v = $k; } if (in_array($v, $values)) { return true; } } return false; } public function getParameterOption($values, $default = false) { $values = (array) $values; foreach ($this->parameters as $k => $v) { if (is_int($k) && in_array($v, $values)) { return true; } elseif (in_array($k, $values)) { return $v; } } return $default; } protected function parse() { foreach ($this->parameters as $key => $value) { if (0 === strpos($key, '--')) { $this->addLongOption(substr($key, 2), $value); } elseif ('-' === $key[0]) { $this->addShortOption(substr($key, 1), $value); } else { $this->addArgument($key, $value); } } } private function addShortOption($shortcut, $value) { if (!$this->definition->hasShortcut($shortcut)) { throw new \InvalidArgumentException(sprintf('The "-%s" option does not exist.', $shortcut)); } $this->addLongOption($this->definition->getOptionForShortcut($shortcut)->getName(), $value); } private function addLongOption($name, $value) { if (!$this->definition->hasOption($name)) { throw new \InvalidArgumentException(sprintf('The "--%s" option does not exist.', $name)); } $option = $this->definition->getOption($name); if (null === $value) { if ($option->isValueRequired()) { throw new \InvalidArgumentException(sprintf('The "--%s" option requires a value.', $name)); } $value = $option->isValueOptional() ? $option->getDefault() : true; } $this->options[$name] = $value; } private function addArgument($name, $value) { if (!$this->definition->hasArgument($name)) { throw new \InvalidArgumentException(sprintf('The "%s" argument does not exist.', $name)); } $this->arguments[$name] = $value; } } } namespace Symfony\Component\Console\Input { class InputArgument { const REQUIRED = 1; const OPTIONAL = 2; const IS_ARRAY = 4; private $name; private $mode; private $default; private $description; public function __construct($name, $mode = null, $description = '', $default = null) { if (null === $mode) { $mode = self::OPTIONAL; } elseif (!is_int($mode) || $mode > 7 || $mode < 1) { throw new \InvalidArgumentException(sprintf('Argument mode "%s" is not valid.', $mode)); } $this->name = $name; $this->mode = $mode; $this->description = $description; $this->setDefault($default); } public function getName() { return $this->name; } public function isRequired() { return self::REQUIRED === (self::REQUIRED & $this->mode); } public function isArray() { return self::IS_ARRAY === (self::IS_ARRAY & $this->mode); } public function setDefault($default = null) { if (self::REQUIRED === $this->mode && null !== $default) { throw new \LogicException('Cannot set a default value except for Parameter::OPTIONAL mode.'); } if ($this->isArray()) { if (null === $default) { $default = array(); } elseif (!is_array($default)) { throw new \LogicException('A default value for an array argument must be an array.'); } } $this->default = $default; } public function getDefault() { return $this->default; } public function getDescription() { return $this->description; } } } namespace Symfony\Component\Console\Input { class InputDefinition { private $arguments; private $requiredCount; private $hasAnArrayArgument = false; private $hasOptional; private $options; private $shortcuts; public function __construct(array $definition = array()) { $this->setDefinition($definition); } public function setDefinition(array $definition) { $arguments = array(); $options = array(); foreach ($definition as $item) { if ($item instanceof InputOption) { $options[] = $item; } else { $arguments[] = $item; } } $this->setArguments($arguments); $this->setOptions($options); } public function setArguments($arguments = array()) { $this->arguments = array(); $this->requiredCount = 0; $this->hasOptional = false; $this->hasAnArrayArgument = false; $this->addArguments($arguments); } public function addArguments($arguments = array()) { if (null !== $arguments) { foreach ($arguments as $argument) { $this->addArgument($argument); } } } public function addArgument(InputArgument $argument) { if (isset($this->arguments[$argument->getName()])) { throw new \LogicException(sprintf('An argument with name "%s" already exists.', $argument->getName())); } if ($this->hasAnArrayArgument) { throw new \LogicException('Cannot add an argument after an array argument.'); } if ($argument->isRequired() && $this->hasOptional) { throw new \LogicException('Cannot add a required argument after an optional one.'); } if ($argument->isArray()) { $this->hasAnArrayArgument = true; } if ($argument->isRequired()) { ++$this->requiredCount; } else { $this->hasOptional = true; } $this->arguments[$argument->getName()] = $argument; } public function getArgument($name) { $arguments = is_int($name) ? array_values($this->arguments) : $this->arguments; if (!$this->hasArgument($name)) { throw new \InvalidArgumentException(sprintf('The "%s" argument does not exist.', $name)); } return $arguments[$name]; } public function hasArgument($name) { $arguments = is_int($name) ? array_values($this->arguments) : $this->arguments; return isset($arguments[$name]); } public function getArguments() { return $this->arguments; } public function getArgumentCount() { return $this->hasAnArrayArgument ? PHP_INT_MAX : count($this->arguments); } public function getArgumentRequiredCount() { return $this->requiredCount; } public function getArgumentDefaults() { $values = array(); foreach ($this->arguments as $argument) { $values[$argument->getName()] = $argument->getDefault(); } return $values; } public function setOptions($options = array()) { $this->options = array(); $this->shortcuts = array(); $this->addOptions($options); } public function addOptions($options = array()) { foreach ($options as $option) { $this->addOption($option); } } public function addOption(InputOption $option) { if (isset($this->options[$option->getName()]) && !$option->equals($this->options[$option->getName()])) { throw new \LogicException(sprintf('An option named "%s" already exists.', $option->getName())); } elseif (isset($this->shortcuts[$option->getShortcut()]) && !$option->equals($this->options[$this->shortcuts[$option->getShortcut()]])) { throw new \LogicException(sprintf('An option with shortcut "%s" already exists.', $option->getShortcut())); } $this->options[$option->getName()] = $option; if ($option->getShortcut()) { $this->shortcuts[$option->getShortcut()] = $option->getName(); } } public function getOption($name) { if (!$this->hasOption($name)) { throw new \InvalidArgumentException(sprintf('The "--%s" option does not exist.', $name)); } return $this->options[$name]; } public function hasOption($name) { return isset($this->options[$name]); } public function getOptions() { return $this->options; } public function hasShortcut($name) { return isset($this->shortcuts[$name]); } public function getOptionForShortcut($shortcut) { return $this->getOption($this->shortcutToName($shortcut)); } public function getOptionDefaults() { $values = array(); foreach ($this->options as $option) { $values[$option->getName()] = $option->getDefault(); } return $values; } private function shortcutToName($shortcut) { if (!isset($this->shortcuts[$shortcut])) { throw new \InvalidArgumentException(sprintf('The "-%s" option does not exist.', $shortcut)); } return $this->shortcuts[$shortcut]; } public function getSynopsis() { $elements = array(); foreach ($this->getOptions() as $option) { $shortcut = $option->getShortcut() ? sprintf('-%s|', $option->getShortcut()) : ''; $elements[] = sprintf('['.($option->isValueRequired() ? '%s--%s="..."' : ($option->isValueOptional() ? '%s--%s[="..."]' : '%s--%s')).']', $shortcut, $option->getName()); } foreach ($this->getArguments() as $argument) { $elements[] = sprintf($argument->isRequired() ? '%s' : '[%s]', $argument->getName().($argument->isArray() ? '1' : '')); if ($argument->isArray()) { $elements[] = sprintf('... [%sN]', $argument->getName()); } } return implode(' ', $elements); } public function asText() { $max = 0; foreach ($this->getOptions() as $option) { $nameLength = strlen($option->getName()) + 2; if ($option->getShortcut()) { $nameLength += strlen($option->getShortcut()) + 3; } $max = max($max, $nameLength); } foreach ($this->getArguments() as $argument) { $max = max($max, strlen($argument->getName())); } ++$max; $text = array(); if ($this->getArguments()) { $text[] = '<comment>Arguments:</comment>'; foreach ($this->getArguments() as $argument) { if (null !== $argument->getDefault() && (!is_array($argument->getDefault()) || count($argument->getDefault()))) { $default = sprintf('<comment> (default: %s)</comment>', $this->formatDefaultValue($argument->getDefault())); } else { $default = ''; } $description = str_replace("\n", "\n".str_pad('', $max + 2, ' '), $argument->getDescription()); $text[] = sprintf(" <info>%-${max}s</info> %s%s", $argument->getName(), $description, $default); } $text[] = ''; } if ($this->getOptions()) { $text[] = '<comment>Options:</comment>'; foreach ($this->getOptions() as $option) { if ($option->acceptValue() && null !== $option->getDefault() && (!is_array($option->getDefault()) || count($option->getDefault()))) { $default = sprintf('<comment> (default: %s)</comment>', $this->formatDefaultValue($option->getDefault())); } else { $default = ''; } $multiple = $option->isArray() ? '<comment> (multiple values allowed)</comment>' : ''; $description = str_replace("\n", "\n".str_pad('', $max + 2, ' '), $option->getDescription()); $optionMax = $max - strlen($option->getName()) - 2; $text[] = sprintf(" <info>%s</info> %-${optionMax}s%s%s%s", '--'.$option->getName(), $option->getShortcut() ? sprintf('(-%s) ', $option->getShortcut()) : '', $description, $default, $multiple ); } $text[] = ''; } return implode("\n", $text); } public function asXml($asDom = false) { $dom = new \DOMDocument('1.0', 'UTF-8'); $dom->formatOutput = true; $dom->appendChild($definitionXML = $dom->createElement('definition')); $definitionXML->appendChild($argumentsXML = $dom->createElement('arguments')); foreach ($this->getArguments() as $argument) { $argumentsXML->appendChild($argumentXML = $dom->createElement('argument')); $argumentXML->setAttribute('name', $argument->getName()); $argumentXML->setAttribute('is_required', $argument->isRequired() ? 1 : 0); $argumentXML->setAttribute('is_array', $argument->isArray() ? 1 : 0); $argumentXML->appendChild($descriptionXML = $dom->createElement('description')); $descriptionXML->appendChild($dom->createTextNode($argument->getDescription())); $argumentXML->appendChild($defaultsXML = $dom->createElement('defaults')); $defaults = is_array($argument->getDefault()) ? $argument->getDefault() : (is_bool($argument->getDefault()) ? array(var_export($argument->getDefault(), true)) : ($argument->getDefault() ? array($argument->getDefault()) : array())); foreach ($defaults as $default) { $defaultsXML->appendChild($defaultXML = $dom->createElement('default')); $defaultXML->appendChild($dom->createTextNode($default)); } } $definitionXML->appendChild($optionsXML = $dom->createElement('options')); foreach ($this->getOptions() as $option) { $optionsXML->appendChild($optionXML = $dom->createElement('option')); $optionXML->setAttribute('name', '--'.$option->getName()); $optionXML->setAttribute('shortcut', $option->getShortcut() ? '-'.$option->getShortcut() : ''); $optionXML->setAttribute('accept_value', $option->acceptValue() ? 1 : 0); $optionXML->setAttribute('is_value_required', $option->isValueRequired() ? 1 : 0); $optionXML->setAttribute('is_multiple', $option->isArray() ? 1 : 0); $optionXML->appendChild($descriptionXML = $dom->createElement('description')); $descriptionXML->appendChild($dom->createTextNode($option->getDescription())); if ($option->acceptValue()) { $optionXML->appendChild($defaultsXML = $dom->createElement('defaults')); $defaults = is_array($option->getDefault()) ? $option->getDefault() : (is_bool($option->getDefault()) ? array(var_export($option->getDefault(), true)) : ($option->getDefault() ? array($option->getDefault()) : array())); foreach ($defaults as $default) { $defaultsXML->appendChild($defaultXML = $dom->createElement('default')); $defaultXML->appendChild($dom->createTextNode($default)); } } } return $asDom ? $dom : $dom->saveXml(); } private function formatDefaultValue($default) { return json_encode($default); } } } namespace Symfony\Component\Console\Input { class InputOption { const VALUE_NONE = 1; const VALUE_REQUIRED = 2; const VALUE_OPTIONAL = 4; const VALUE_IS_ARRAY = 8; private $name; private $shortcut; private $mode; private $default; private $description; public function __construct($name, $shortcut = null, $mode = null, $description = '', $default = null) { if (0 === strpos($name, '--')) { $name = substr($name, 2); } if (empty($name)) { throw new \InvalidArgumentException('An option name cannot be empty.'); } if (empty($shortcut)) { $shortcut = null; } if (null !== $shortcut) { if ('-' === $shortcut[0]) { $shortcut = substr($shortcut, 1); } if (empty($shortcut)) { throw new \InvalidArgumentException('An option shortcut cannot be empty.'); } } if (null === $mode) { $mode = self::VALUE_NONE; } elseif (!is_int($mode) || $mode > 15 || $mode < 1) { throw new \InvalidArgumentException(sprintf('Option mode "%s" is not valid.', $mode)); } $this->name = $name; $this->shortcut = $shortcut; $this->mode = $mode; $this->description = $description; if ($this->isArray() && !$this->acceptValue()) { throw new \InvalidArgumentException('Impossible to have an option mode VALUE_IS_ARRAY if the option does not accept a value.'); } $this->setDefault($default); } public function getShortcut() { return $this->shortcut; } public function getName() { return $this->name; } public function acceptValue() { return $this->isValueRequired() || $this->isValueOptional(); } public function isValueRequired() { return self::VALUE_REQUIRED === (self::VALUE_REQUIRED & $this->mode); } public function isValueOptional() { return self::VALUE_OPTIONAL === (self::VALUE_OPTIONAL & $this->mode); } public function isArray() { return self::VALUE_IS_ARRAY === (self::VALUE_IS_ARRAY & $this->mode); } public function setDefault($default = null) { if (self::VALUE_NONE === (self::VALUE_NONE & $this->mode) && null !== $default) { throw new \LogicException('Cannot set a default value when using Option::VALUE_NONE mode.'); } if ($this->isArray()) { if (null === $default) { $default = array(); } elseif (!is_array($default)) { throw new \LogicException('A default value for an array option must be an array.'); } } $this->default = $this->acceptValue() ? $default : false; } public function getDefault() { return $this->default; } public function getDescription() { return $this->description; } public function equals(InputOption $option) { return $option->getName() === $this->getName() && $option->getShortcut() === $this->getShortcut() && $option->getDefault() === $this->getDefault() && $option->isArray() === $this->isArray() && $option->isValueRequired() === $this->isValueRequired() && $option->isValueOptional() === $this->isValueOptional() ; } } } namespace Symfony\Component\Console\Input { class StringInput extends ArgvInput { const REGEX_STRING = '([^ ]+?)(?: |(?<!\\\\)"|(?<!\\\\)\'|$)'; const REGEX_QUOTED_STRING = '(?:"([^"\\\\]*(?:\\\\.[^"\\\\]*)*)"|\'([^\'\\\\]*(?:\\\\.[^\'\\\\]*)*)\')'; public function __construct($input, InputDefinition $definition = null) { parent::__construct(array(), $definition); $this->setTokens($this->tokenize($input)); } private function tokenize($input) { $input = preg_replace('/(\r\n|\r|\n|\t)/', ' ', $input); $tokens = array(); $length = strlen($input); $cursor = 0; while ($cursor < $length) { if (preg_match('/\s+/A', $input, $match, null, $cursor)) { } elseif (preg_match('/([^="\' ]+?)(=?)('.self::REGEX_QUOTED_STRING.'+)/A', $input, $match, null, $cursor)) { $tokens[] = $match[1].$match[2].stripcslashes(str_replace(array('"\'', '\'"', '\'\'', '""'), '', substr($match[3], 1, strlen($match[3]) - 2))); } elseif (preg_match('/'.self::REGEX_QUOTED_STRING.'/A', $input, $match, null, $cursor)) { $tokens[] = stripcslashes(substr($match[0], 1, strlen($match[0]) - 2)); } elseif (preg_match('/'.self::REGEX_STRING.'/A', $input, $match, null, $cursor)) { $tokens[] = stripcslashes($match[1]); } else { throw new \InvalidArgumentException(sprintf('Unable to parse input near "... %s ..."', substr($input, $cursor, 10))); } $cursor += strlen($match[0]); } return $tokens; } } } namespace Symfony\Component\Console\Output { use Symfony\Component\Console\Formatter\OutputFormatterInterface; interface OutputInterface { const VERBOSITY_QUIET = 0; const VERBOSITY_NORMAL = 1; const VERBOSITY_VERBOSE = 2; const OUTPUT_NORMAL = 0; const OUTPUT_RAW = 1; const OUTPUT_PLAIN = 2; public function write($messages, $newline = false, $type = 0); public function writeln($messages, $type = 0); public function setVerbosity($level); public function getVerbosity(); public function setDecorated($decorated); public function isDecorated(); public function setFormatter(OutputFormatterInterface $formatter); public function getFormatter(); } } namespace Symfony\Component\Console\Output { use Symfony\Component\Console\Formatter\OutputFormatterInterface; use Symfony\Component\Console\Formatter\OutputFormatter; abstract class Output implements OutputInterface { private $verbosity; private $formatter; public function __construct($verbosity = self::VERBOSITY_NORMAL, $decorated = null, OutputFormatterInterface $formatter = null) { $this->verbosity = null === $verbosity ? self::VERBOSITY_NORMAL : $verbosity; $this->formatter = null === $formatter ? new OutputFormatter() : $formatter; $this->formatter->setDecorated((Boolean) $decorated); } public function setFormatter(OutputFormatterInterface $formatter) { $this->formatter = $formatter; } public function getFormatter() { return $this->formatter; } public function setDecorated($decorated) { $this->formatter->setDecorated((Boolean) $decorated); } public function isDecorated() { return $this->formatter->isDecorated(); } public function setVerbosity($level) { $this->verbosity = (int) $level; } public function getVerbosity() { return $this->verbosity; } public function writeln($messages, $type = 0) { $this->write($messages, true, $type); } public function write($messages, $newline = false, $type = 0) { if (self::VERBOSITY_QUIET === $this->verbosity) { return; } $messages = (array) $messages; foreach ($messages as $message) { switch ($type) { case OutputInterface::OUTPUT_NORMAL: $message = $this->formatter->format($message); break; case OutputInterface::OUTPUT_RAW: break; case OutputInterface::OUTPUT_PLAIN: $message = strip_tags($this->formatter->format($message)); break; default: throw new \InvalidArgumentException(sprintf('Unknown output type given (%s)', $type)); } $this->doWrite($message, $newline); } } abstract protected function doWrite($message, $newline); } } namespace Symfony\Component\Console\Output { use Symfony\Component\Console\Formatter\OutputFormatterInterface; class StreamOutput extends Output { private $stream; public function __construct($stream, $verbosity = self::VERBOSITY_NORMAL, $decorated = null, OutputFormatterInterface $formatter = null) { if (!is_resource($stream) || 'stream' !== get_resource_type($stream)) { throw new \InvalidArgumentException('The StreamOutput class needs a stream as its first argument.'); } $this->stream = $stream; if (null === $decorated) { $decorated = $this->hasColorSupport($decorated); } parent::__construct($verbosity, $decorated, $formatter); } public function getStream() { return $this->stream; } protected function doWrite($message, $newline) { if (false === @fwrite($this->stream, $message.($newline ? PHP_EOL : ''))) { throw new \RuntimeException('Unable to write output.'); } fflush($this->stream); } protected function hasColorSupport() { if (DIRECTORY_SEPARATOR == '\\') { return false !== getenv('ANSICON'); } return function_exists('posix_isatty') && @posix_isatty($this->stream); } } } namespace Symfony\Component\Console\Output { use Symfony\Component\Console\Output\OutputInterface; interface ConsoleOutputInterface extends OutputInterface { public function getErrorOutput(); public function setErrorOutput(OutputInterface $error); } } namespace Symfony\Component\Console\Output { use Symfony\Component\Console\Formatter\OutputFormatter; use Symfony\Component\Console\Formatter\OutputFormatterInterface; use Symfony\Component\Console\Output\ConsoleOutputInterface; class ConsoleOutput extends StreamOutput implements ConsoleOutputInterface { private $stderr; public function __construct($verbosity = self::VERBOSITY_NORMAL, $decorated = null, OutputFormatterInterface $formatter = null) { $outputStream = 'php://stdout'; if (!$this->hasStdoutSupport()) { $outputStream = 'php://output'; } parent::__construct(fopen($outputStream, 'w'), $verbosity, $decorated, $formatter); $this->stderr = new StreamOutput(fopen('php://stderr', 'w'), $verbosity, $decorated, $formatter); } public function setDecorated($decorated) { parent::setDecorated($decorated); $this->stderr->setDecorated($decorated); } public function setFormatter(OutputFormatterInterface $formatter) { parent::setFormatter($formatter); $this->stderr->setFormatter($formatter); } public function setVerbosity($level) { parent::setVerbosity($level); $this->stderr->setVerbosity($level); } public function getErrorOutput() { return $this->stderr; } public function setErrorOutput(OutputInterface $error) { $this->stderr = $error; } protected function hasStdoutSupport() { return ('OS400' != php_uname('s')); } } } namespace Symfony\Component\Console\Output { class NullOutput extends Output { protected function doWrite($message, $newline) { } } } namespace Symfony\Component\Console { use Symfony\Component\Console\Application; use Symfony\Component\Console\Input\StringInput; use Symfony\Component\Console\Output\ConsoleOutput; use Symfony\Component\Process\ProcessBuilder; use Symfony\Component\Process\PhpExecutableFinder; class Shell { private $application; private $history; private $output; private $hasReadline; private $prompt; private $processIsolation; public function __construct(Application $application) { $this->hasReadline = function_exists('readline'); $this->application = $application; $this->history = getenv('HOME').'/.history_'.$application->getName(); $this->output = new ConsoleOutput(); $this->prompt = $application->getName().' > '; $this->processIsolation = false; } public function run() { $this->application->setAutoExit(false); $this->application->setCatchExceptions(true); if ($this->hasReadline) { readline_read_history($this->history); readline_completion_function(array($this, 'autocompleter')); } $this->output->writeln($this->getHeader()); $php = null; if ($this->processIsolation) { $finder = new PhpExecutableFinder(); $php = $finder->find(); $this->output->writeln(<<<EOF
<info>Running with process isolation, you should consider this:</info>
  * each command is executed as separate process,
  * commands don't support interactivity, all params must be passed explicitly,
  * commands output is not colorized.

EOF
); } while (true) { $command = $this->readline(); if (false === $command) { $this->output->writeln("\n"); break; } if ($this->hasReadline) { readline_add_history($command); readline_write_history($this->history); } if ($this->processIsolation) { $pb = new ProcessBuilder(); $process = $pb ->add($php) ->add($_SERVER['argv'][0]) ->add($command) ->inheritEnvironmentVariables(true) ->getProcess() ; $output = $this->output; $process->run(function($type, $data) use ($output) { $output->writeln($data); }); $ret = $process->getExitCode(); } else { $ret = $this->application->run(new StringInput($command), $this->output); } if (0 !== $ret) { $this->output->writeln(sprintf('<error>The command terminated with an error status (%s)</error>', $ret)); } } } protected function getHeader() { return <<<EOF

Welcome to the <info>{$this->application->getName()}</info> shell (<comment>{$this->application->getVersion()}</comment>).

At the prompt, type <comment>help</comment> for some help,
or <comment>list</comment> to get a list of available commands.

To exit the shell, type <comment>^D</comment>.

EOF;
} private function autocompleter($text) { $info = readline_info(); $text = substr($info['line_buffer'], 0, $info['end']); if ($info['point'] !== $info['end']) { return true; } if (false === strpos($text, ' ') || !$text) { return array_keys($this->application->all()); } try { $command = $this->application->find(substr($text, 0, strpos($text, ' '))); } catch (\Exception $e) { return true; } $list = array('--help'); foreach ($command->getDefinition()->getOptions() as $option) { $list[] = '--'.$option->getName(); } return $list; } private function readline() { if ($this->hasReadline) { $line = readline($this->prompt); } else { $this->output->write($this->prompt); $line = fgets(STDIN, 1024); $line = (!$line && strlen($line) == 0) ? false : rtrim($line); } return $line; } public function getProcessIsolation() { return $this->processIsolation; } public function setProcessIsolation($processIsolation) { $this->processIsolation = (Boolean) $processIsolation; } } } namespace Symfony\Component\Console { use Symfony\Component\Console\Input\InputInterface; use Symfony\Component\Console\Input\ArgvInput; use Symfony\Component\Console\Input\ArrayInput; use Symfony\Component\Console\Input\InputDefinition; use Symfony\Component\Console\Input\InputOption; use Symfony\Component\Console\Input\InputArgument; use Symfony\Component\Console\Output\OutputInterface; use Symfony\Component\Console\Output\Output; use Symfony\Component\Console\Output\ConsoleOutput; use Symfony\Component\Console\Output\ConsoleOutputInterface; use Symfony\Component\Console\Command\Command; use Symfony\Component\Console\Command\HelpCommand; use Symfony\Component\Console\Command\ListCommand; use Symfony\Component\Console\Helper\HelperSet; use Symfony\Component\Console\Helper\FormatterHelper; use Symfony\Component\Console\Helper\DialogHelper; class Application { private $commands; private $wantHelps = false; private $runningCommand; private $name; private $version; private $catchExceptions; private $autoExit; private $definition; private $helperSet; public function __construct($name = 'UNKNOWN', $version = 'UNKNOWN') { $this->name = $name; $this->version = $version; $this->catchExceptions = true; $this->autoExit = true; $this->commands = array(); $this->helperSet = $this->getDefaultHelperSet(); $this->definition = $this->getDefaultInputDefinition(); foreach ($this->getDefaultCommands() as $command) { $this->add($command); } } public function run(InputInterface $input = null, OutputInterface $output = null) { if (null === $input) { $input = new ArgvInput(); } if (null === $output) { $output = new ConsoleOutput(); } try { $statusCode = $this->doRun($input, $output); } catch (\Exception $e) { if (!$this->catchExceptions) { throw $e; } if ($output instanceof ConsoleOutputInterface) { $this->renderException($e, $output->getErrorOutput()); } else { $this->renderException($e, $output); } $statusCode = $e->getCode(); $statusCode = is_numeric($statusCode) && $statusCode ? $statusCode : 1; } if ($this->autoExit) { if ($statusCode > 255) { $statusCode = 255; } exit($statusCode); } return $statusCode; } public function doRun(InputInterface $input, OutputInterface $output) { $name = $this->getCommandName($input); if (true === $input->hasParameterOption(array('--ansi'))) { $output->setDecorated(true); } elseif (true === $input->hasParameterOption(array('--no-ansi'))) { $output->setDecorated(false); } if (true === $input->hasParameterOption(array('--help', '-h'))) { if (!$name) { $name = 'help'; $input = new ArrayInput(array('command' => 'help')); } else { $this->wantHelps = true; } } if (true === $input->hasParameterOption(array('--no-interaction', '-n'))) { $input->setInteractive(false); } if (function_exists('posix_isatty') && $this->getHelperSet()->has('dialog')) { $inputStream = $this->getHelperSet()->get('dialog')->getInputStream(); if (!posix_isatty($inputStream)) { $input->setInteractive(false); } } if (true === $input->hasParameterOption(array('--quiet', '-q'))) { $output->setVerbosity(OutputInterface::VERBOSITY_QUIET); } elseif (true === $input->hasParameterOption(array('--verbose', '-v'))) { $output->setVerbosity(OutputInterface::VERBOSITY_VERBOSE); } if (true === $input->hasParameterOption(array('--version', '-V'))) { $output->writeln($this->getLongVersion()); return 0; } if (!$name) { $name = 'list'; $input = new ArrayInput(array('command' => 'list')); } $command = $this->find($name); $this->runningCommand = $command; $statusCode = $command->run($input, $output); $this->runningCommand = null; return is_numeric($statusCode) ? $statusCode : 0; } public function setHelperSet(HelperSet $helperSet) { $this->helperSet = $helperSet; } public function getHelperSet() { return $this->helperSet; } public function getDefinition() { return $this->definition; } public function getHelp() { $messages = array( $this->getLongVersion(), '', '<comment>Usage:</comment>', sprintf("  [options] command [arguments]\n"), '<comment>Options:</comment>', ); foreach ($this->getDefinition()->getOptions() as $option) { $messages[] = sprintf('  %-29s %s %s', '<info>--'.$option->getName().'</info>', $option->getShortcut() ? '<info>-'.$option->getShortcut().'</info>' : '  ', $option->getDescription() ); } return implode(PHP_EOL, $messages); } public function setCatchExceptions($boolean) { $this->catchExceptions = (Boolean) $boolean; } public function setAutoExit($boolean) { $this->autoExit = (Boolean) $boolean; } public function getName() { return $this->name; } public function setName($name) { $this->name = $name; } public function getVersion() { return $this->version; } public function setVersion($version) { $this->version = $version; } public function getLongVersion() { if ('UNKNOWN' !== $this->getName() && 'UNKNOWN' !== $this->getVersion()) { return sprintf('<info>%s</info> version <comment>%s</comment>', $this->getName(), $this->getVersion()); } return '<info>Console Tool</info>'; } public function register($name) { return $this->add(new Command($name)); } public function addCommands(array $commands) { foreach ($commands as $command) { $this->add($command); } } public function add(Command $command) { $command->setApplication($this); if (!$command->isEnabled()) { $command->setApplication(null); return; } $this->commands[$command->getName()] = $command; foreach ($command->getAliases() as $alias) { $this->commands[$alias] = $command; } return $command; } public function get($name) { if (!isset($this->commands[$name])) { throw new \InvalidArgumentException(sprintf('The command "%s" does not exist.', $name)); } $command = $this->commands[$name]; if ($this->wantHelps) { $this->wantHelps = false; $helpCommand = $this->get('help'); $helpCommand->setCommand($command); return $helpCommand; } return $command; } public function has($name) { return isset($this->commands[$name]); } public function getNamespaces() { $namespaces = array(); foreach ($this->commands as $command) { $namespaces[] = $this->extractNamespace($command->getName()); foreach ($command->getAliases() as $alias) { $namespaces[] = $this->extractNamespace($alias); } } return array_values(array_unique(array_filter($namespaces))); } public function findNamespace($namespace) { $allNamespaces = array(); foreach ($this->getNamespaces() as $n) { $allNamespaces[$n] = explode(':', $n); } $found = array(); foreach (explode(':', $namespace) as $i => $part) { $abbrevs = static::getAbbreviations(array_unique(array_values(array_filter(array_map(function ($p) use ($i) { return isset($p[$i]) ? $p[$i] : ''; }, $allNamespaces))))); if (!isset($abbrevs[$part])) { $message = sprintf('There are no commands defined in the "%s" namespace.', $namespace); if (1 <= $i) { $part = implode(':', $found).':'.$part; } if ($alternatives = $this->findAlternativeNamespace($part, $abbrevs)) { $message .= "\n\nDid you mean one of these?\n    "; $message .= implode("\n    ", $alternatives); } throw new \InvalidArgumentException($message); } if (count($abbrevs[$part]) > 1) { throw new \InvalidArgumentException(sprintf('The namespace "%s" is ambiguous (%s).', $namespace, $this->getAbbreviationSuggestions($abbrevs[$part]))); } $found[] = $abbrevs[$part][0]; } return implode(':', $found); } public function find($name) { $namespace = ''; $searchName = $name; if (false !== $pos = strrpos($name, ':')) { $namespace = $this->findNamespace(substr($name, 0, $pos)); $searchName = $namespace.substr($name, $pos); } $commands = array(); foreach ($this->commands as $command) { if ($this->extractNamespace($command->getName()) == $namespace) { $commands[] = $command->getName(); } } $abbrevs = static::getAbbreviations(array_unique($commands)); if (isset($abbrevs[$searchName]) && 1 == count($abbrevs[$searchName])) { return $this->get($abbrevs[$searchName][0]); } if (isset($abbrevs[$searchName]) && count($abbrevs[$searchName]) > 1) { $suggestions = $this->getAbbreviationSuggestions($abbrevs[$searchName]); throw new \InvalidArgumentException(sprintf('Command "%s" is ambiguous (%s).', $name, $suggestions)); } $aliases = array(); foreach ($this->commands as $command) { foreach ($command->getAliases() as $alias) { if ($this->extractNamespace($alias) == $namespace) { $aliases[] = $alias; } } } $aliases = static::getAbbreviations(array_unique($aliases)); if (!isset($aliases[$searchName])) { $message = sprintf('Command "%s" is not defined.', $name); if ($alternatives = $this->findAlternativeCommands($searchName, $abbrevs)) { $message .= "\n\nDid you mean one of these?\n    "; $message .= implode("\n    ", $alternatives); } throw new \InvalidArgumentException($message); } if (count($aliases[$searchName]) > 1) { throw new \InvalidArgumentException(sprintf('Command "%s" is ambiguous (%s).', $name, $this->getAbbreviationSuggestions($aliases[$searchName]))); } return $this->get($aliases[$searchName][0]); } public function all($namespace = null) { if (null === $namespace) { return $this->commands; } $commands = array(); foreach ($this->commands as $name => $command) { if ($namespace === $this->extractNamespace($name, substr_count($namespace, ':') + 1)) { $commands[$name] = $command; } } return $commands; } public static function getAbbreviations($names) { $abbrevs = array(); foreach ($names as $name) { for ($len = strlen($name) - 1; $len > 0; --$len) { $abbrev = substr($name, 0, $len); if (!isset($abbrevs[$abbrev])) { $abbrevs[$abbrev] = array($name); } else { $abbrevs[$abbrev][] = $name; } } } foreach ($names as $name) { $abbrevs[$name] = array($name); } return $abbrevs; } public function asText($namespace = null, $raw = false) { $commands = $namespace ? $this->all($this->findNamespace($namespace)) : $this->commands; $width = 0; foreach ($commands as $command) { $width = strlen($command->getName()) > $width ? strlen($command->getName()) : $width; } $width += 2; if ($raw) { $messages = array(); foreach ($this->sortCommands($commands) as $space => $commands) { foreach ($commands as $name => $command) { $messages[] = sprintf("%-${width}s %s", $name, $command->getDescription()); } } return implode(PHP_EOL, $messages); } $messages = array($this->getHelp(), ''); if ($namespace) { $messages[] = sprintf("<comment>Available commands for the \"%s\" namespace:</comment>", $namespace); } else { $messages[] = '<comment>Available commands:</comment>'; } foreach ($this->sortCommands($commands) as $space => $commands) { if (!$namespace && '_global' !== $space) { $messages[] = '<comment>'.$space.'</comment>'; } foreach ($commands as $name => $command) { $messages[] = sprintf("  <info>%-${width}s</info> %s", $name, $command->getDescription()); } } return implode(PHP_EOL, $messages); } public function asXml($namespace = null, $asDom = false) { $commands = $namespace ? $this->all($this->findNamespace($namespace)) : $this->commands; $dom = new \DOMDocument('1.0', 'UTF-8'); $dom->formatOutput = true; $dom->appendChild($xml = $dom->createElement('symfony')); $xml->appendChild($commandsXML = $dom->createElement('commands')); if ($namespace) { $commandsXML->setAttribute('namespace', $namespace); } else { $namespacesXML = $dom->createElement('namespaces'); $xml->appendChild($namespacesXML); } foreach ($this->sortCommands($commands) as $space => $commands) { if (!$namespace) { $namespaceArrayXML = $dom->createElement('namespace'); $namespacesXML->appendChild($namespaceArrayXML); $namespaceArrayXML->setAttribute('id', $space); } foreach ($commands as $name => $command) { if ($name !== $command->getName()) { continue; } if (!$namespace) { $commandXML = $dom->createElement('command'); $namespaceArrayXML->appendChild($commandXML); $commandXML->appendChild($dom->createTextNode($name)); } $node = $command->asXml(true)->getElementsByTagName('command')->item(0); $node = $dom->importNode($node, true); $commandsXML->appendChild($node); } } return $asDom ? $dom : $dom->saveXml(); } public function renderException($e, $output) { $strlen = function ($string) { if (!function_exists('mb_strlen')) { return strlen($string); } if (false === $encoding = mb_detect_encoding($string)) { return strlen($string); } return mb_strlen($string, $encoding); }; do { $title = sprintf('  [%s]  ', get_class($e)); $len = $strlen($title); $width = $this->getTerminalWidth() ? $this->getTerminalWidth() - 1 : PHP_INT_MAX; $lines = array(); foreach (preg_split("{\r?\n}", $e->getMessage()) as $line) { foreach (str_split($line, $width - 4) as $line) { $lines[] = sprintf('  %s  ', $line); $len = max($strlen($line) + 4, $len); } } $messages = array(str_repeat(' ', $len), $title.str_repeat(' ', max(0, $len - $strlen($title)))); foreach ($lines as $line) { $messages[] = $line.str_repeat(' ', $len - $strlen($line)); } $messages[] = str_repeat(' ', $len); $output->writeln(""); $output->writeln(""); foreach ($messages as $message) { $output->writeln('<error>'.$message.'</error>'); } $output->writeln(""); $output->writeln(""); if (OutputInterface::VERBOSITY_VERBOSE === $output->getVerbosity()) { $output->writeln('<comment>Exception trace:</comment>'); $trace = $e->getTrace(); array_unshift($trace, array( 'function' => '', 'file' => $e->getFile() != null ? $e->getFile() : 'n/a', 'line' => $e->getLine() != null ? $e->getLine() : 'n/a', 'args' => array(), )); for ($i = 0, $count = count($trace); $i < $count; $i++) { $class = isset($trace[$i]['class']) ? $trace[$i]['class'] : ''; $type = isset($trace[$i]['type']) ? $trace[$i]['type'] : ''; $function = $trace[$i]['function']; $file = isset($trace[$i]['file']) ? $trace[$i]['file'] : 'n/a'; $line = isset($trace[$i]['line']) ? $trace[$i]['line'] : 'n/a'; $output->writeln(sprintf(' %s%s%s() at <info>%s:%s</info>', $class, $type, $function, $file, $line)); } $output->writeln(""); $output->writeln(""); } } while ($e = $e->getPrevious()); if (null !== $this->runningCommand) { $output->writeln(sprintf('<info>%s</info>', sprintf($this->runningCommand->getSynopsis(), $this->getName()))); $output->writeln(""); $output->writeln(""); } } protected function getTerminalWidth() { if (defined('PHP_WINDOWS_VERSION_BUILD')) { if ($ansicon = getenv('ANSICON')) { return preg_replace('{^(\d+)x.*$}', '$1', $ansicon); } exec('mode CON', $execData); if (preg_match('{columns:\s*(\d+)}i', $execData[4], $matches)) { return $matches[1]; } } if (preg_match("{rows.(\d+);.columns.(\d+);}i", $this->getSttyColumns(), $match)) { return $match[2]; } } protected function getTerminalHeight() { if (defined('PHP_WINDOWS_VERSION_BUILD')) { if ($ansicon = getenv('ANSICON')) { return preg_replace('{^\d+x\d+ \(\d+x(\d+)\)$}', '$1', trim($ansicon)); } exec('mode CON', $execData); if (preg_match('{lines:\s*(\d+)}i', $execData[3], $matches)) { return $matches[1]; } } if (preg_match("{rows.(\d+);.columns.(\d+);}i", $this->getSttyColumns(), $match)) { return $match[1]; } } protected function getCommandName(InputInterface $input) { return $input->getFirstArgument(); } protected function getDefaultInputDefinition() { return new InputDefinition(array( new InputArgument('command', InputArgument::REQUIRED, 'The command to execute'), new InputOption('--help', '-h', InputOption::VALUE_NONE, 'Display this help message.'), new InputOption('--quiet', '-q', InputOption::VALUE_NONE, 'Do not output any message.'), new InputOption('--verbose', '-v', InputOption::VALUE_NONE, 'Increase verbosity of messages.'), new InputOption('--version', '-V', InputOption::VALUE_NONE, 'Display this application version.'), new InputOption('--ansi', '', InputOption::VALUE_NONE, 'Force ANSI output.'), new InputOption('--no-ansi', '', InputOption::VALUE_NONE, 'Disable ANSI output.'), new InputOption('--no-interaction', '-n', InputOption::VALUE_NONE, 'Do not ask any interactive question.'), )); } protected function getDefaultCommands() { return array(new HelpCommand(), new ListCommand()); } protected function getDefaultHelperSet() { return new HelperSet(array( new FormatterHelper(), new DialogHelper(), )); } private function getSttyColumns() { if (!function_exists('proc_open')) { return; } $descriptorspec = array(1 => array('pipe', 'w'), 2 => array('pipe', 'w')); $process = proc_open('stty -a | grep columns', $descriptorspec, $pipes, null, null, array('suppress_errors' => true)); if (is_resource($process)) { $info = stream_get_contents($pipes[1]); fclose($pipes[1]); fclose($pipes[2]); proc_close($process); return $info; } } private function sortCommands($commands) { $namespacedCommands = array(); foreach ($commands as $name => $command) { $key = $this->extractNamespace($name, 1); if (!$key) { $key = '_global'; } $namespacedCommands[$key][$name] = $command; } ksort($namespacedCommands); foreach ($namespacedCommands as &$commands) { ksort($commands); } return $namespacedCommands; } private function getAbbreviationSuggestions($abbrevs) { return sprintf('%s, %s%s', $abbrevs[0], $abbrevs[1], count($abbrevs) > 2 ? sprintf(' and %d more', count($abbrevs) - 2) : ''); } private function extractNamespace($name, $limit = null) { $parts = explode(':', $name); array_pop($parts); return implode(':', null === $limit ? $parts : array_slice($parts, 0, $limit)); } private function findAlternativeCommands($name, $abbrevs) { $callback = function($item) { return $item->getName(); }; return $this->findAlternatives($name, $this->commands, $abbrevs, $callback); } private function findAlternativeNamespace($name, $abbrevs) { return $this->findAlternatives($name, $this->getNamespaces(), $abbrevs); } private function findAlternatives($name, $collection, $abbrevs, $callback = null) { $alternatives = array(); foreach ($collection as $item) { if (null !== $callback) { $item = call_user_func($callback, $item); } $lev = levenshtein($name, $item); if ($lev <= strlen($name) / 3 || false !== strpos($item, $name)) { $alternatives[$item] = $lev; } } if (!$alternatives) { foreach ($abbrevs as $key => $values) { $lev = levenshtein($name, $key); if ($lev <= strlen($name) / 3 || false !== strpos($key, $name)) { foreach ($values as $value) { $alternatives[$value] = $lev; } } } } asort($alternatives); return array_keys($alternatives); } } } namespace Symfony\Component\EventDispatcher { class Event { private $propagationStopped = false; private $dispatcher; private $name; public function isPropagationStopped() { return $this->propagationStopped; } public function stopPropagation() { $this->propagationStopped = true; } public function setDispatcher(EventDispatcher $dispatcher) { $this->dispatcher = $dispatcher; } public function getDispatcher() { return $this->dispatcher; } public function getName() { return $this->name; } public function setName($name) { $this->name = $name; } } } namespace Symfony\Component\EventDispatcher { interface EventDispatcherInterface { public function dispatch($eventName, Event $event = null); public function addListener($eventName, $listener, $priority = 0); public function addSubscriber(EventSubscriberInterface $subscriber); public function removeListener($eventName, $listener); public function removeSubscriber(EventSubscriberInterface $subscriber); public function getListeners($eventName = null); public function hasListeners($eventName = null); } } namespace Symfony\Component\EventDispatcher { class EventDispatcher implements EventDispatcherInterface { private $listeners = array(); private $sorted = array(); public function dispatch($eventName, Event $event = null) { if (null === $event) { $event = new Event(); } $event->setDispatcher($this); $event->setName($eventName); if (!isset($this->listeners[$eventName])) { return $event; } $this->doDispatch($this->getListeners($eventName), $eventName, $event); return $event; } public function getListeners($eventName = null) { if (null !== $eventName) { if (!isset($this->sorted[$eventName])) { $this->sortListeners($eventName); } return $this->sorted[$eventName]; } foreach (array_keys($this->listeners) as $eventName) { if (!isset($this->sorted[$eventName])) { $this->sortListeners($eventName); } } return $this->sorted; } public function hasListeners($eventName = null) { return (Boolean) count($this->getListeners($eventName)); } public function addListener($eventName, $listener, $priority = 0) { $this->listeners[$eventName][$priority][] = $listener; unset($this->sorted[$eventName]); } public function removeListener($eventName, $listener) { if (!isset($this->listeners[$eventName])) { return; } foreach ($this->listeners[$eventName] as $priority => $listeners) { if (false !== ($key = array_search($listener, $listeners))) { unset($this->listeners[$eventName][$priority][$key], $this->sorted[$eventName]); } } } public function addSubscriber(EventSubscriberInterface $subscriber) { foreach ($subscriber->getSubscribedEvents() as $eventName => $params) { if (is_string($params)) { $this->addListener($eventName, array($subscriber, $params)); } elseif (is_string($params[0])) { $this->addListener($eventName, array($subscriber, $params[0]), isset($params[1]) ? $params[1] : 0); } else { foreach ($params as $listener) { $this->addListener($eventName, array($subscriber, $listener[0]), isset($listener[1]) ? $listener[1] : 0); } } } } public function removeSubscriber(EventSubscriberInterface $subscriber) { foreach ($subscriber->getSubscribedEvents() as $eventName => $params) { if (is_array($params) && is_array($params[0])) { foreach ($params as $listener) { $this->removeListener($eventName, array($subscriber, $listener[0])); } } else { $this->removeListener($eventName, array($subscriber, is_string($params) ? $params : $params[0])); } } } protected function doDispatch($listeners, $eventName, Event $event) { foreach ($listeners as $listener) { call_user_func($listener, $event); if ($event->isPropagationStopped()) { break; } } } private function sortListeners($eventName) { $this->sorted[$eventName] = array(); if (isset($this->listeners[$eventName])) { krsort($this->listeners[$eventName]); $this->sorted[$eventName] = call_user_func_array('array_merge', $this->listeners[$eventName]); } } } } namespace Symfony\Component\HttpFoundation { class ParameterBag implements \IteratorAggregate, \Countable { protected $parameters; public function __construct(array $parameters = array()) { $this->parameters = $parameters; } public function all() { return $this->parameters; } public function keys() { return array_keys($this->parameters); } public function replace(array $parameters = array()) { $this->parameters = $parameters; } public function add(array $parameters = array()) { $this->parameters = array_replace($this->parameters, $parameters); } public function get($path, $default = null, $deep = false) { if (!$deep || false === $pos = strpos($path, '[')) { return array_key_exists($path, $this->parameters) ? $this->parameters[$path] : $default; } $root = substr($path, 0, $pos); if (!array_key_exists($root, $this->parameters)) { return $default; } $value = $this->parameters[$root]; $currentKey = null; for ($i = $pos, $c = strlen($path); $i < $c; $i++) { $char = $path[$i]; if ('[' === $char) { if (null !== $currentKey) { throw new \InvalidArgumentException(sprintf('Malformed path. Unexpected "[" at position %d.', $i)); } $currentKey = ''; } elseif (']' === $char) { if (null === $currentKey) { throw new \InvalidArgumentException(sprintf('Malformed path. Unexpected "]" at position %d.', $i)); } if (!is_array($value) || !array_key_exists($currentKey, $value)) { return $default; } $value = $value[$currentKey]; $currentKey = null; } else { if (null === $currentKey) { throw new \InvalidArgumentException(sprintf('Malformed path. Unexpected "%s" at position %d.', $char, $i)); } $currentKey .= $char; } } if (null !== $currentKey) { throw new \InvalidArgumentException(sprintf('Malformed path. Path must end with "]".')); } return $value; } public function set($key, $value) { $this->parameters[$key] = $value; } public function has($key) { return array_key_exists($key, $this->parameters); } public function remove($key) { unset($this->parameters[$key]); } public function getAlpha($key, $default = '', $deep = false) { return preg_replace('/[^[:alpha:]]/', '', $this->get($key, $default, $deep)); } public function getAlnum($key, $default = '', $deep = false) { return preg_replace('/[^[:alnum:]]/', '', $this->get($key, $default, $deep)); } public function getDigits($key, $default = '', $deep = false) { return str_replace(array('-', '+'), '', $this->filter($key, $default, $deep, FILTER_SANITIZE_NUMBER_INT)); } public function getInt($key, $default = 0, $deep = false) { return (int) $this->get($key, $default, $deep); } public function filter($key, $default = null, $deep = false, $filter=FILTER_DEFAULT, $options=array()) { $value = $this->get($key, $default, $deep); if (!is_array($options) && $options) { $options = array('flags' => $options); } if (is_array($value) && !isset($options['flags'])) { $options['flags'] = FILTER_REQUIRE_ARRAY; } return filter_var($value, $filter, $options); } public function getIterator() { return new \ArrayIterator($this->parameters); } public function count() { return count($this->parameters); } } } namespace Symfony\Component\HttpFoundation { class Cookie { protected $name; protected $value; protected $domain; protected $expire; protected $path; protected $secure; protected $httpOnly; public function __construct($name, $value = null, $expire = 0, $path = '/', $domain = null, $secure = false, $httpOnly = true) { if (preg_match("/[=,; \t\r\n\013\014]/", $name)) { throw new \InvalidArgumentException(sprintf('The cookie name "%s" contains invalid characters.', $name)); } if (empty($name)) { throw new \InvalidArgumentException('The cookie name cannot be empty.'); } if ($expire instanceof \DateTime) { $expire = $expire->format('U'); } elseif (!is_numeric($expire)) { $expire = strtotime($expire); if (false === $expire || -1 === $expire) { throw new \InvalidArgumentException('The cookie expiration time is not valid.'); } } $this->name = $name; $this->value = $value; $this->domain = $domain; $this->expire = $expire; $this->path = empty($path) ? '/' : $path; $this->secure = (Boolean) $secure; $this->httpOnly = (Boolean) $httpOnly; } public function __toString() { $str = urlencode($this->getName()).'='; if ('' === (string) $this->getValue()) { $str .= 'deleted; expires='.gmdate("D, d-M-Y H:i:s T", time() - 31536001); } else { $str .= urlencode($this->getValue()); if ($this->getExpiresTime() !== 0) { $str .= '; expires='.gmdate("D, d-M-Y H:i:s T", $this->getExpiresTime()); } } if ('/' !== $this->path) { $str .= '; path='.$this->path; } if (null !== $this->getDomain()) { $str .= '; domain='.$this->getDomain(); } if (true === $this->isSecure()) { $str .= '; secure'; } if (true === $this->isHttpOnly()) { $str .= '; httponly'; } return $str; } public function getName() { return $this->name; } public function getValue() { return $this->value; } public function getDomain() { return $this->domain; } public function getExpiresTime() { return $this->expire; } public function getPath() { return $this->path; } public function isSecure() { return $this->secure; } public function isHttpOnly() { return $this->httpOnly; } public function isCleared() { return $this->expire < time(); } } } namespace Symfony\Component\HttpFoundation { use Symfony\Component\HttpFoundation\File\UploadedFile; class FileBag extends ParameterBag { private static $fileKeys = array('error', 'name', 'size', 'tmp_name', 'type'); public function __construct(array $parameters = array()) { $this->replace($parameters); } public function replace(array $files = array()) { $this->parameters = array(); $this->add($files); } public function set($key, $value) { if (!is_array($value) && !$value instanceof UploadedFile) { throw new \InvalidArgumentException('An uploaded file must be an array or an instance of UploadedFile.'); } parent::set($key, $this->convertFileInformation($value)); } public function add(array $files = array()) { foreach ($files as $key => $file) { $this->set($key, $file); } } protected function convertFileInformation($file) { if ($file instanceof UploadedFile) { return $file; } $file = $this->fixPhpFilesArray($file); if (is_array($file)) { $keys = array_keys($file); sort($keys); if ($keys == self::$fileKeys) { if (UPLOAD_ERR_NO_FILE == $file['error']) { $file = null; } else { $file = new UploadedFile($file['tmp_name'], $file['name'], $file['type'], $file['size'], $file['error']); } } else { $file = array_map(array($this, 'convertFileInformation'), $file); } } return $file; } protected function fixPhpFilesArray($data) { if (!is_array($data)) { return $data; } $keys = array_keys($data); sort($keys); if (self::$fileKeys != $keys || !isset($data['name']) || !is_array($data['name'])) { return $data; } $files = $data; foreach (self::$fileKeys as $k) { unset($files[$k]); } foreach (array_keys($data['name']) as $key) { $files[$key] = $this->fixPhpFilesArray(array( 'error' => $data['error'][$key], 'name' => $data['name'][$key], 'type' => $data['type'][$key], 'tmp_name' => $data['tmp_name'][$key], 'size' => $data['size'][$key] )); } return $files; } } } namespace Symfony\Component\HttpFoundation { class HeaderBag implements \IteratorAggregate, \Countable { protected $headers; protected $cacheControl; public function __construct(array $headers = array()) { $this->cacheControl = array(); $this->headers = array(); foreach ($headers as $key => $values) { $this->set($key, $values); } } public function __toString() { if (!$this->headers) { return ''; } $max = max(array_map('strlen', array_keys($this->headers))) + 1; $content = ''; ksort($this->headers); foreach ($this->headers as $name => $values) { $name = implode('-', array_map('ucfirst', explode('-', $name))); foreach ($values as $value) { $content .= sprintf("%-{$max}s %s\r\n", $name.':', $value); } } return $content; } public function all() { return $this->headers; } public function keys() { return array_keys($this->headers); } public function replace(array $headers = array()) { $this->headers = array(); $this->add($headers); } public function add(array $headers) { foreach ($headers as $key => $values) { $this->set($key, $values); } } public function get($key, $default = null, $first = true) { $key = strtr(strtolower($key), '_', '-'); if (!array_key_exists($key, $this->headers)) { if (null === $default) { return $first ? null : array(); } return $first ? $default : array($default); } if ($first) { return count($this->headers[$key]) ? $this->headers[$key][0] : $default; } return $this->headers[$key]; } public function set($key, $values, $replace = true) { $key = strtr(strtolower($key), '_', '-'); $values = (array) $values; if (true === $replace || !isset($this->headers[$key])) { $this->headers[$key] = $values; } else { $this->headers[$key] = array_merge($this->headers[$key], $values); } if ('cache-control' === $key) { $this->cacheControl = $this->parseCacheControl($values[0]); } } public function has($key) { return array_key_exists(strtr(strtolower($key), '_', '-'), $this->headers); } public function contains($key, $value) { return in_array($value, $this->get($key, null, false)); } public function remove($key) { $key = strtr(strtolower($key), '_', '-'); unset($this->headers[$key]); if ('cache-control' === $key) { $this->cacheControl = array(); } } public function getDate($key, \DateTime $default = null) { if (null === $value = $this->get($key)) { return $default; } if (false === $date = \DateTime::createFromFormat(DATE_RFC2822, $value)) { throw new \RuntimeException(sprintf('The %s HTTP header is not parseable (%s).', $key, $value)); } return $date; } public function addCacheControlDirective($key, $value = true) { $this->cacheControl[$key] = $value; $this->set('Cache-Control', $this->getCacheControlHeader()); } public function hasCacheControlDirective($key) { return array_key_exists($key, $this->cacheControl); } public function getCacheControlDirective($key) { return array_key_exists($key, $this->cacheControl) ? $this->cacheControl[$key] : null; } public function removeCacheControlDirective($key) { unset($this->cacheControl[$key]); $this->set('Cache-Control', $this->getCacheControlHeader()); } public function getIterator() { return new \ArrayIterator($this->headers); } public function count() { return count($this->headers); } protected function getCacheControlHeader() { $parts = array(); ksort($this->cacheControl); foreach ($this->cacheControl as $key => $value) { if (true === $value) { $parts[] = $key; } else { if (preg_match('#[^a-zA-Z0-9._-]#', $value)) { $value = '"'.$value.'"'; } $parts[] = "$key=$value"; } } return implode(', ', $parts); } protected function parseCacheControl($header) { $cacheControl = array(); preg_match_all('#([a-zA-Z][a-zA-Z_-]*)\s*(?:=(?:"([^"]*)"|([^ \t",;]*)))?#', $header, $matches, PREG_SET_ORDER); foreach ($matches as $match) { $cacheControl[strtolower($match[1])] = isset($match[2]) && $match[2] ? $match[2] : (isset($match[3]) ? $match[3] : true); } return $cacheControl; } } } namespace Symfony\Component\HttpFoundation { class Response { public $headers; protected $content; protected $version; protected $statusCode; protected $statusText; protected $charset; public static $statusTexts = array( 100 => 'Continue', 101 => 'Switching Protocols', 102 => 'Processing', 200 => 'OK', 201 => 'Created', 202 => 'Accepted', 203 => 'Non-Authoritative Information', 204 => 'No Content', 205 => 'Reset Content', 206 => 'Partial Content', 207 => 'Multi-Status', 208 => 'Already Reported', 226 => 'IM Used', 300 => 'Multiple Choices', 301 => 'Moved Permanently', 302 => 'Found', 303 => 'See Other', 304 => 'Not Modified', 305 => 'Use Proxy', 306 => 'Reserved', 307 => 'Temporary Redirect', 308 => 'Permanent Redirect', 400 => 'Bad Request', 401 => 'Unauthorized', 402 => 'Payment Required', 403 => 'Forbidden', 404 => 'Not Found', 405 => 'Method Not Allowed', 406 => 'Not Acceptable', 407 => 'Proxy Authentication Required', 408 => 'Request Timeout', 409 => 'Conflict', 410 => 'Gone', 411 => 'Length Required', 412 => 'Precondition Failed', 413 => 'Request Entity Too Large', 414 => 'Request-URI Too Long', 415 => 'Unsupported Media Type', 416 => 'Requested Range Not Satisfiable', 417 => 'Expectation Failed', 418 => 'I\'m a teapot', 422 => 'Unprocessable Entity', 423 => 'Locked', 424 => 'Failed Dependency', 425 => 'Reserved for WebDAV advanced collections expired proposal', 426 => 'Upgrade Required', 428 => 'Precondition Required', 429 => 'Too Many Requests', 431 => 'Request Header Fields Too Large', 500 => 'Internal Server Error', 501 => 'Not Implemented', 502 => 'Bad Gateway', 503 => 'Service Unavailable', 504 => 'Gateway Timeout', 505 => 'HTTP Version Not Supported', 506 => 'Variant Also Negotiates (Experimental)', 507 => 'Insufficient Storage', 508 => 'Loop Detected', 510 => 'Not Extended', 511 => 'Network Authentication Required', ); public function __construct($content = '', $status = 200, $headers = array()) { $this->headers = new ResponseHeaderBag($headers); $this->setContent($content); $this->setStatusCode($status); $this->setProtocolVersion('1.0'); if (!$this->headers->has('Date')) { $this->setDate(new \DateTime(null, new \DateTimeZone('UTC'))); } } public static function create($content = '', $status = 200, $headers = array()) { return new static($content, $status, $headers); } public function __toString() { return sprintf('HTTP/%s %s %s', $this->version, $this->statusCode, $this->statusText)."\r\n". $this->headers."\r\n". $this->getContent(); } public function __clone() { $this->headers = clone $this->headers; } public function prepare(Request $request) { $headers = $this->headers; if ($this->isInformational() || in_array($this->statusCode, array(204, 304))) { $this->setContent(null); } if (!$headers->has('Content-Type')) { $format = $request->getRequestFormat(); if (null !== $format && $mimeType = $request->getMimeType($format)) { $headers->set('Content-Type', $mimeType); } } $charset = $this->charset ?: 'UTF-8'; if (!$headers->has('Content-Type')) { $headers->set('Content-Type', 'text/html; charset='.$charset); } elseif (0 === strpos($headers->get('Content-Type'), 'text/') && false === strpos($headers->get('Content-Type'), 'charset')) { $headers->set('Content-Type', $headers->get('Content-Type').'; charset='.$charset); } if ($headers->has('Transfer-Encoding')) { $headers->remove('Content-Length'); } if ('HEAD' === $request->getMethod()) { $length = $headers->get('Content-Length'); $this->setContent(null); if ($length) { $headers->set('Content-Length', $length); } } return $this; } public function sendHeaders() { if (headers_sent()) { return $this; } header(sprintf('HTTP/%s %s %s', $this->version, $this->statusCode, $this->statusText)); foreach ($this->headers->all() as $name => $values) { foreach ($values as $value) { header($name.': '.$value, false); } } foreach ($this->headers->getCookies() as $cookie) { setcookie($cookie->getName(), $cookie->getValue(), $cookie->getExpiresTime(), $cookie->getPath(), $cookie->getDomain(), $cookie->isSecure(), $cookie->isHttpOnly()); } return $this; } public function sendContent() { echo $this->content; return $this; } public function send() { $this->sendHeaders(); $this->sendContent(); if (function_exists('fastcgi_finish_request')) { fastcgi_finish_request(); } elseif ('cli' !== PHP_SAPI) { $previous = null; $obStatus = ob_get_status(1); while (($level = ob_get_level()) > 0 && $level !== $previous) { $previous = $level; if ($obStatus[$level - 1] && isset($obStatus[$level - 1]['del']) && $obStatus[$level - 1]['del']) { ob_end_flush(); } } flush(); } return $this; } public function setContent($content) { if (null !== $content && !is_string($content) && !is_numeric($content) && !is_callable(array($content, '__toString'))) { throw new \UnexpectedValueException('The Response content must be a string or object implementing __toString(), "'.gettype($content).'" given.'); } $this->content = (string) $content; return $this; } public function getContent() { return $this->content; } public function setProtocolVersion($version) { $this->version = $version; return $this; } public function getProtocolVersion() { return $this->version; } public function setStatusCode($code, $text = null) { $this->statusCode = $code = (int) $code; if ($this->isInvalid()) { throw new \InvalidArgumentException(sprintf('The HTTP status code "%s" is not valid.', $code)); } if (null === $text) { $this->statusText = isset(self::$statusTexts[$code]) ? self::$statusTexts[$code] : ''; return $this; } if (false === $text) { $this->statusText = ''; return $this; } $this->statusText = $text; return $this; } public function getStatusCode() { return $this->statusCode; } public function setCharset($charset) { $this->charset = $charset; return $this; } public function getCharset() { return $this->charset; } public function isCacheable() { if (!in_array($this->statusCode, array(200, 203, 300, 301, 302, 404, 410))) { return false; } if ($this->headers->hasCacheControlDirective('no-store') || $this->headers->getCacheControlDirective('private')) { return false; } return $this->isValidateable() || $this->isFresh(); } public function isFresh() { return $this->getTtl() > 0; } public function isValidateable() { return $this->headers->has('Last-Modified') || $this->headers->has('ETag'); } public function setPrivate() { $this->headers->removeCacheControlDirective('public'); $this->headers->addCacheControlDirective('private'); return $this; } public function setPublic() { $this->headers->addCacheControlDirective('public'); $this->headers->removeCacheControlDirective('private'); return $this; } public function mustRevalidate() { return $this->headers->hasCacheControlDirective('must-revalidate') || $this->headers->has('proxy-revalidate'); } public function getDate() { return $this->headers->getDate('Date'); } public function setDate(\DateTime $date) { $date->setTimezone(new \DateTimeZone('UTC')); $this->headers->set('Date', $date->format('D, d M Y H:i:s').' GMT'); return $this; } public function getAge() { if ($age = $this->headers->get('Age')) { return $age; } return max(time() - $this->getDate()->format('U'), 0); } public function expire() { if ($this->isFresh()) { $this->headers->set('Age', $this->getMaxAge()); } return $this; } public function getExpires() { return $this->headers->getDate('Expires'); } public function setExpires(\DateTime $date = null) { if (null === $date) { $this->headers->remove('Expires'); } else { $date = clone $date; $date->setTimezone(new \DateTimeZone('UTC')); $this->headers->set('Expires', $date->format('D, d M Y H:i:s').' GMT'); } return $this; } public function getMaxAge() { if ($age = $this->headers->getCacheControlDirective('s-maxage')) { return $age; } if ($age = $this->headers->getCacheControlDirective('max-age')) { return $age; } if (null !== $this->getExpires()) { return $this->getExpires()->format('U') - $this->getDate()->format('U'); } return null; } public function setMaxAge($value) { $this->headers->addCacheControlDirective('max-age', $value); return $this; } public function setSharedMaxAge($value) { $this->setPublic(); $this->headers->addCacheControlDirective('s-maxage', $value); return $this; } public function getTtl() { if ($maxAge = $this->getMaxAge()) { return $maxAge - $this->getAge(); } return null; } public function setTtl($seconds) { $this->setSharedMaxAge($this->getAge() + $seconds); return $this; } public function setClientTtl($seconds) { $this->setMaxAge($this->getAge() + $seconds); return $this; } public function getLastModified() { return $this->headers->getDate('Last-Modified'); } public function setLastModified(\DateTime $date = null) { if (null === $date) { $this->headers->remove('Last-Modified'); } else { $date = clone $date; $date->setTimezone(new \DateTimeZone('UTC')); $this->headers->set('Last-Modified', $date->format('D, d M Y H:i:s').' GMT'); } return $this; } public function getEtag() { return $this->headers->get('ETag'); } public function setEtag($etag = null, $weak = false) { if (null === $etag) { $this->headers->remove('Etag'); } else { if (0 !== strpos($etag, '"')) { $etag = '"'.$etag.'"'; } $this->headers->set('ETag', (true === $weak ? 'W/' : '').$etag); } return $this; } public function setCache(array $options) { if ($diff = array_diff(array_keys($options), array('etag', 'last_modified', 'max_age', 's_maxage', 'private', 'public'))) { throw new \InvalidArgumentException(sprintf('Response does not support the following options: "%s".', implode('", "', array_values($diff)))); } if (isset($options['etag'])) { $this->setEtag($options['etag']); } if (isset($options['last_modified'])) { $this->setLastModified($options['last_modified']); } if (isset($options['max_age'])) { $this->setMaxAge($options['max_age']); } if (isset($options['s_maxage'])) { $this->setSharedMaxAge($options['s_maxage']); } if (isset($options['public'])) { if ($options['public']) { $this->setPublic(); } else { $this->setPrivate(); } } if (isset($options['private'])) { if ($options['private']) { $this->setPrivate(); } else { $this->setPublic(); } } return $this; } public function setNotModified() { $this->setStatusCode(304); $this->setContent(null); foreach (array('Allow', 'Content-Encoding', 'Content-Language', 'Content-Length', 'Content-MD5', 'Content-Type', 'Last-Modified') as $header) { $this->headers->remove($header); } return $this; } public function hasVary() { return (Boolean) $this->headers->get('Vary'); } public function getVary() { if (!$vary = $this->headers->get('Vary')) { return array(); } return is_array($vary) ? $vary : preg_split('/[\s,]+/', $vary); } public function setVary($headers, $replace = true) { $this->headers->set('Vary', $headers, $replace); return $this; } public function isNotModified(Request $request) { if (!$request->isMethodSafe()) { return false; } $lastModified = $request->headers->get('If-Modified-Since'); $notModified = false; if ($etags = $request->getEtags()) { $notModified = (in_array($this->getEtag(), $etags) || in_array('*', $etags)) && (!$lastModified || $this->headers->get('Last-Modified') == $lastModified); } elseif ($lastModified) { $notModified = $lastModified == $this->headers->get('Last-Modified'); } if ($notModified) { $this->setNotModified(); } return $notModified; } public function isInvalid() { return $this->statusCode < 100 || $this->statusCode >= 600; } public function isInformational() { return $this->statusCode >= 100 && $this->statusCode < 200; } public function isSuccessful() { return $this->statusCode >= 200 && $this->statusCode < 300; } public function isRedirection() { return $this->statusCode >= 300 && $this->statusCode < 400; } public function isClientError() { return $this->statusCode >= 400 && $this->statusCode < 500; } public function isServerError() { return $this->statusCode >= 500 && $this->statusCode < 600; } public function isOk() { return 200 === $this->statusCode; } public function isForbidden() { return 403 === $this->statusCode; } public function isNotFound() { return 404 === $this->statusCode; } public function isRedirect($location = null) { return in_array($this->statusCode, array(201, 301, 302, 303, 307, 308)) && (null === $location ?: $location == $this->headers->get('Location')); } public function isEmpty() { return in_array($this->statusCode, array(201, 204, 304)); } } } namespace Symfony\Component\HttpFoundation { class RedirectResponse extends Response { protected $targetUrl; public function __construct($url, $status = 302, $headers = array()) { if (empty($url)) { throw new \InvalidArgumentException('Cannot redirect to an empty URL.'); } parent::__construct('', $status, $headers); $this->setTargetUrl($url); if (!$this->isRedirect()) { throw new \InvalidArgumentException(sprintf('The HTTP status code is not a redirect ("%s" given).', $status)); } } public static function create($url = '', $status = 302, $headers = array()) { return new static($url, $status, $headers); } public function getTargetUrl() { return $this->targetUrl; } public function setTargetUrl($url) { if (empty($url)) { throw new \InvalidArgumentException('Cannot redirect to an empty URL.'); } $this->targetUrl = $url; $this->setContent( sprintf('<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta http-equiv="refresh" content="1;url=%1$s" />

        <title>Redirecting to %1$s</title>
    </head>
    <body>
        Redirecting to <a href="%1$s">%1$s</a>.
    </body>
</html>', htmlspecialchars($url, ENT_QUOTES, 'UTF-8'))); $this->headers->set('Location', $url); return $this; } } } namespace Symfony\Component\HttpFoundation { use Symfony\Component\HttpFoundation\Session\SessionInterface; class Request { protected static $trustProxy = false; public $attributes; public $request; public $query; public $server; public $files; public $cookies; public $headers; protected $content; protected $languages; protected $charsets; protected $acceptableContentTypes; protected $pathInfo; protected $requestUri; protected $baseUrl; protected $basePath; protected $method; protected $format; protected $session; protected $locale; protected $defaultLocale = 'en'; protected static $formats; public function __construct(array $query = array(), array $request = array(), array $attributes = array(), array $cookies = array(), array $files = array(), array $server = array(), $content = null) { $this->initialize($query, $request, $attributes, $cookies, $files, $server, $content); } public function initialize(array $query = array(), array $request = array(), array $attributes = array(), array $cookies = array(), array $files = array(), array $server = array(), $content = null) { $this->request = new ParameterBag($request); $this->query = new ParameterBag($query); $this->attributes = new ParameterBag($attributes); $this->cookies = new ParameterBag($cookies); $this->files = new FileBag($files); $this->server = new ServerBag($server); $this->headers = new HeaderBag($this->server->getHeaders()); $this->content = $content; $this->languages = null; $this->charsets = null; $this->acceptableContentTypes = null; $this->pathInfo = null; $this->requestUri = null; $this->baseUrl = null; $this->basePath = null; $this->method = null; $this->format = null; } public static function createFromGlobals() { $request = new static($_GET, $_POST, array(), $_COOKIE, $_FILES, $_SERVER); if (0 === strpos($request->server->get('CONTENT_TYPE'), 'application/x-www-form-urlencoded') && in_array(strtoupper($request->server->get('REQUEST_METHOD', 'GET')), array('PUT', 'DELETE', 'PATCH')) ) { parse_str($request->getContent(), $data); $request->request = new ParameterBag($data); } return $request; } public static function create($uri, $method = 'GET', $parameters = array(), $cookies = array(), $files = array(), $server = array(), $content = null) { $defaults = array( 'SERVER_NAME' => 'localhost', 'SERVER_PORT' => 80, 'HTTP_HOST' => 'localhost', 'HTTP_USER_AGENT' => 'Symfony/2.X', 'HTTP_ACCEPT' => 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8', 'HTTP_ACCEPT_LANGUAGE' => 'en-us,en;q=0.5', 'HTTP_ACCEPT_CHARSET' => 'ISO-8859-1,utf-8;q=0.7,*;q=0.7', 'REMOTE_ADDR' => '127.0.0.1', 'SCRIPT_NAME' => '', 'SCRIPT_FILENAME' => '', 'SERVER_PROTOCOL' => 'HTTP/1.1', 'REQUEST_TIME' => time(), ); $components = parse_url($uri); if (isset($components['host'])) { $defaults['SERVER_NAME'] = $components['host']; $defaults['HTTP_HOST'] = $components['host']; } if (isset($components['scheme'])) { if ('https' === $components['scheme']) { $defaults['HTTPS'] = 'on'; $defaults['SERVER_PORT'] = 443; } } if (isset($components['port'])) { $defaults['SERVER_PORT'] = $components['port']; $defaults['HTTP_HOST'] = $defaults['HTTP_HOST'].':'.$components['port']; } if (isset($components['user'])) { $defaults['PHP_AUTH_USER'] = $components['user']; } if (isset($components['pass'])) { $defaults['PHP_AUTH_PW'] = $components['pass']; } if (!isset($components['path'])) { $components['path'] = ''; } switch (strtoupper($method)) { case 'POST': case 'PUT': case 'DELETE': $defaults['CONTENT_TYPE'] = 'application/x-www-form-urlencoded'; case 'PATCH': $request = $parameters; $query = array(); break; default: $request = array(); $query = $parameters; break; } if (isset($components['query'])) { parse_str(html_entity_decode($components['query']), $qs); $query = array_replace($qs, $query); } $queryString = http_build_query($query, '', '&'); $uri = $components['path'].('' !== $queryString ? '?'.$queryString : ''); $server = array_replace($defaults, $server, array( 'REQUEST_METHOD' => strtoupper($method), 'PATH_INFO' => '', 'REQUEST_URI' => $uri, 'QUERY_STRING' => $queryString, )); return new static($query, $request, array(), $cookies, $files, $server, $content); } public function duplicate(array $query = null, array $request = null, array $attributes = null, array $cookies = null, array $files = null, array $server = null) { $dup = clone $this; if ($query !== null) { $dup->query = new ParameterBag($query); } if ($request !== null) { $dup->request = new ParameterBag($request); } if ($attributes !== null) { $dup->attributes = new ParameterBag($attributes); } if ($cookies !== null) { $dup->cookies = new ParameterBag($cookies); } if ($files !== null) { $dup->files = new FileBag($files); } if ($server !== null) { $dup->server = new ServerBag($server); $dup->headers = new HeaderBag($dup->server->getHeaders()); } $dup->languages = null; $dup->charsets = null; $dup->acceptableContentTypes = null; $dup->pathInfo = null; $dup->requestUri = null; $dup->baseUrl = null; $dup->basePath = null; $dup->method = null; $dup->format = null; return $dup; } public function __clone() { $this->query = clone $this->query; $this->request = clone $this->request; $this->attributes = clone $this->attributes; $this->cookies = clone $this->cookies; $this->files = clone $this->files; $this->server = clone $this->server; $this->headers = clone $this->headers; } public function __toString() { return sprintf('%s %s %s', $this->getMethod(), $this->getRequestUri(), $this->server->get('SERVER_PROTOCOL'))."\r\n". $this->headers."\r\n". $this->getContent(); } public function overrideGlobals() { $_GET = $this->query->all(); $_POST = $this->request->all(); $_SERVER = $this->server->all(); $_COOKIE = $this->cookies->all(); foreach ($this->headers->all() as $key => $value) { $key = strtoupper(str_replace('-', '_', $key)); if (in_array($key, array('CONTENT_TYPE', 'CONTENT_LENGTH'))) { $_SERVER[$key] = implode(', ', $value); } else { $_SERVER['HTTP_'.$key] = implode(', ', $value); } } $request = array('g' => $_GET, 'p' => $_POST, 'c' => $_COOKIE); $requestOrder = ini_get('request_order') ?: ini_get('variable_order'); $requestOrder = preg_replace('#[^cgp]#', '', strtolower($requestOrder)) ?: 'gp'; $_REQUEST = array(); foreach (str_split($requestOrder) as $order) { $_REQUEST = array_merge($_REQUEST, $request[$order]); } } public static function trustProxyData() { self::$trustProxy = true; } public static function isProxyTrusted() { return self::$trustProxy; } public static function normalizeQueryString($qs) { if ('' == $qs) { return ''; } $parts = array(); $order = array(); foreach (explode('&', $qs) as $param) { if ('' === $param || '=' === $param[0]) { continue; } $keyValuePair = explode('=', $param, 2); $parts[] = isset($keyValuePair[1]) ? rawurlencode(urldecode($keyValuePair[0])).'='.rawurlencode(urldecode($keyValuePair[1])) : rawurlencode(urldecode($keyValuePair[0])); $order[] = urldecode($keyValuePair[0]); } array_multisort($order, SORT_ASC, $parts); return implode('&', $parts); } public function get($key, $default = null, $deep = false) { return $this->query->get($key, $this->attributes->get($key, $this->request->get($key, $default, $deep), $deep), $deep); } public function getSession() { return $this->session; } public function hasPreviousSession() { return $this->hasSession() && $this->cookies->has($this->session->getName()); } public function hasSession() { return null !== $this->session; } public function setSession(SessionInterface $session) { $this->session = $session; } public function getClientIp() { if (self::$trustProxy) { if ($this->server->has('HTTP_CLIENT_IP')) { return $this->server->get('HTTP_CLIENT_IP'); } elseif ($this->server->has('HTTP_X_FORWARDED_FOR')) { $clientIp = explode(',', $this->server->get('HTTP_X_FORWARDED_FOR')); foreach ($clientIp as $ipAddress) { $cleanIpAddress = trim($ipAddress); if (false !== filter_var($cleanIpAddress, FILTER_VALIDATE_IP)) { return $cleanIpAddress; } } return ''; } } return $this->server->get('REMOTE_ADDR'); } public function getScriptName() { return $this->server->get('SCRIPT_NAME', $this->server->get('ORIG_SCRIPT_NAME', '')); } public function getPathInfo() { if (null === $this->pathInfo) { $this->pathInfo = $this->preparePathInfo(); } return $this->pathInfo; } public function getBasePath() { if (null === $this->basePath) { $this->basePath = $this->prepareBasePath(); } return $this->basePath; } public function getBaseUrl() { if (null === $this->baseUrl) { $this->baseUrl = $this->prepareBaseUrl(); } return $this->baseUrl; } public function getScheme() { return $this->isSecure() ? 'https' : 'http'; } public function getPort() { if (self::$trustProxy && $this->headers->has('X-Forwarded-Port')) { return $this->headers->get('X-Forwarded-Port'); } return $this->server->get('SERVER_PORT'); } public function getUser() { return $this->server->get('PHP_AUTH_USER'); } public function getPassword() { return $this->server->get('PHP_AUTH_PW'); } public function getUserInfo() { $userinfo = $this->getUser(); $pass = $this->getPassword(); if ('' != $pass) { $userinfo .= ":$pass"; } return $userinfo; } public function getHttpHost() { $scheme = $this->getScheme(); $port = $this->getPort(); if (('http' == $scheme && $port == 80) || ('https' == $scheme && $port == 443)) { return $this->getHost(); } return $this->getHost().':'.$port; } public function getRequestUri() { if (null === $this->requestUri) { $this->requestUri = $this->prepareRequestUri(); } return $this->requestUri; } public function getSchemeAndHttpHost() { return $this->getScheme().'://'.(('' != $auth = $this->getUserInfo()) ? $auth.'@' : '').$this->getHttpHost(); } public function getUri() { $qs = $this->getQueryString(); if (null !== $qs) { $qs = '?'.$qs; } return $this->getSchemeAndHttpHost().$this->getBaseUrl().$this->getPathInfo().$qs; } public function getUriForPath($path) { return $this->getSchemeAndHttpHost().$this->getBaseUrl().$path; } public function getQueryString() { $qs = static::normalizeQueryString($this->server->get('QUERY_STRING')); return '' === $qs ? null : $qs; } public function isSecure() { return ( (strtolower($this->server->get('HTTPS')) == 'on' || $this->server->get('HTTPS') == 1) || (self::$trustProxy && strtolower($this->headers->get('SSL_HTTPS')) == 'on' || $this->headers->get('SSL_HTTPS') == 1) || (self::$trustProxy && strtolower($this->headers->get('X_FORWARDED_PROTO')) == 'https') ); } public function getHost() { if (self::$trustProxy && $host = $this->headers->get('X_FORWARDED_HOST')) { $elements = explode(',', $host); $host = trim($elements[count($elements) - 1]); } else { if (!$host = $this->headers->get('HOST')) { if (!$host = $this->server->get('SERVER_NAME')) { $host = $this->server->get('SERVER_ADDR', ''); } } } $host = preg_replace('/:\d+$/', '', $host); return trim(strtolower($host)); } public function setMethod($method) { $this->method = null; $this->server->set('REQUEST_METHOD', $method); } public function getMethod() { if (null === $this->method) { $this->method = strtoupper($this->server->get('REQUEST_METHOD', 'GET')); if ('POST' === $this->method) { $this->method = strtoupper($this->headers->get('X-HTTP-METHOD-OVERRIDE', $this->request->get('_method', $this->query->get('_method', 'POST')))); } } return $this->method; } public function getMimeType($format) { if (null === static::$formats) { static::initializeFormats(); } return isset(static::$formats[$format]) ? static::$formats[$format][0] : null; } public function getFormat($mimeType) { if (false !== $pos = strpos($mimeType, ';')) { $mimeType = substr($mimeType, 0, $pos); } if (null === static::$formats) { static::initializeFormats(); } foreach (static::$formats as $format => $mimeTypes) { if (in_array($mimeType, (array) $mimeTypes)) { return $format; } } return null; } public function setFormat($format, $mimeTypes) { if (null === static::$formats) { static::initializeFormats(); } static::$formats[$format] = is_array($mimeTypes) ? $mimeTypes : array($mimeTypes); } public function getRequestFormat($default = 'html') { if (null === $this->format) { $this->format = $this->get('_format', $default); } return $this->format; } public function setRequestFormat($format) { $this->format = $format; } public function getContentType() { return $this->getFormat($this->server->get('CONTENT_TYPE')); } public function setDefaultLocale($locale) { $this->setPhpDefaultLocale($this->defaultLocale = $locale); } public function setLocale($locale) { $this->setPhpDefaultLocale($this->locale = $locale); } public function getLocale() { return null === $this->locale ? $this->defaultLocale : $this->locale; } public function isMethod($method) { return $this->getMethod() === strtoupper($method); } public function isMethodSafe() { return in_array($this->getMethod(), array('GET', 'HEAD')); } public function getContent($asResource = false) { if (false === $this->content || (true === $asResource && null !== $this->content)) { throw new \LogicException('getContent() can only be called once when using the resource return type.'); } if (true === $asResource) { $this->content = false; return fopen('php://input', 'rb'); } if (null === $this->content) { $this->content = file_get_contents('php://input'); } return $this->content; } public function getETags() { return preg_split('/\s*,\s*/', $this->headers->get('if_none_match'), null, PREG_SPLIT_NO_EMPTY); } public function isNoCache() { return $this->headers->hasCacheControlDirective('no-cache') || 'no-cache' == $this->headers->get('Pragma'); } public function getPreferredLanguage(array $locales = null) { $preferredLanguages = $this->getLanguages(); if (empty($locales)) { return isset($preferredLanguages[0]) ? $preferredLanguages[0] : null; } if (!$preferredLanguages) { return $locales[0]; } $preferredLanguages = array_values(array_intersect($preferredLanguages, $locales)); return isset($preferredLanguages[0]) ? $preferredLanguages[0] : $locales[0]; } public function getLanguages() { if (null !== $this->languages) { return $this->languages; } $languages = $this->splitHttpAcceptHeader($this->headers->get('Accept-Language')); $this->languages = array(); foreach ($languages as $lang => $q) { if (strstr($lang, '-')) { $codes = explode('-', $lang); if ($codes[0] == 'i') { if (count($codes) > 1) { $lang = $codes[1]; } } else { for ($i = 0, $max = count($codes); $i < $max; $i++) { if ($i == 0) { $lang = strtolower($codes[0]); } else { $lang .= '_'.strtoupper($codes[$i]); } } } } $this->languages[] = $lang; } return $this->languages; } public function getCharsets() { if (null !== $this->charsets) { return $this->charsets; } return $this->charsets = array_keys($this->splitHttpAcceptHeader($this->headers->get('Accept-Charset'))); } public function getAcceptableContentTypes() { if (null !== $this->acceptableContentTypes) { return $this->acceptableContentTypes; } return $this->acceptableContentTypes = array_keys($this->splitHttpAcceptHeader($this->headers->get('Accept'))); } public function isXmlHttpRequest() { return 'XMLHttpRequest' == $this->headers->get('X-Requested-With'); } public function splitHttpAcceptHeader($header) { if (!$header) { return array(); } $values = array(); foreach (array_filter(explode(',', $header)) as $value) { if (preg_match('/;\s*(q=.*$)/', $value, $match)) { $q = (float) substr(trim($match[1]), 2); $value = trim(substr($value, 0, -strlen($match[0]))); } else { $q = 1; } if (0 < $q) { $values[trim($value)] = $q; } } arsort($values); reset($values); return $values; } protected function prepareRequestUri() { $requestUri = ''; if ($this->headers->has('X_REWRITE_URL') && false !== stripos(PHP_OS, 'WIN')) { $requestUri = $this->headers->get('X_REWRITE_URL'); } elseif ($this->server->get('IIS_WasUrlRewritten') == '1' && $this->server->get('UNENCODED_URL') != '') { $requestUri = $this->server->get('UNENCODED_URL'); } elseif ($this->server->has('REQUEST_URI')) { $requestUri = $this->server->get('REQUEST_URI'); $schemeAndHttpHost = $this->getSchemeAndHttpHost(); if (strpos($requestUri, $schemeAndHttpHost) === 0) { $requestUri = substr($requestUri, strlen($schemeAndHttpHost)); } } elseif ($this->server->has('ORIG_PATH_INFO')) { $requestUri = $this->server->get('ORIG_PATH_INFO'); if ('' != $this->server->get('QUERY_STRING')) { $requestUri .= '?'.$this->server->get('QUERY_STRING'); } } return $requestUri; } protected function prepareBaseUrl() { $filename = basename($this->server->get('SCRIPT_FILENAME')); if (basename($this->server->get('SCRIPT_NAME')) === $filename) { $baseUrl = $this->server->get('SCRIPT_NAME'); } elseif (basename($this->server->get('PHP_SELF')) === $filename) { $baseUrl = $this->server->get('PHP_SELF'); } elseif (basename($this->server->get('ORIG_SCRIPT_NAME')) === $filename) { $baseUrl = $this->server->get('ORIG_SCRIPT_NAME'); } else { $path = $this->server->get('PHP_SELF', ''); $file = $this->server->get('SCRIPT_FILENAME', ''); $segs = explode('/', trim($file, '/')); $segs = array_reverse($segs); $index = 0; $last = count($segs); $baseUrl = ''; do { $seg = $segs[$index]; $baseUrl = '/'.$seg.$baseUrl; ++$index; } while (($last > $index) && (false !== ($pos = strpos($path, $baseUrl))) && (0 != $pos)); } $requestUri = $this->getRequestUri(); if ($baseUrl && false !== $prefix = $this->getUrlencodedPrefix($requestUri, $baseUrl)) { return $prefix; } if ($baseUrl && false !== $prefix = $this->getUrlencodedPrefix($requestUri, dirname($baseUrl))) { return rtrim($prefix, '/'); } $truncatedRequestUri = $requestUri; if (($pos = strpos($requestUri, '?')) !== false) { $truncatedRequestUri = substr($requestUri, 0, $pos); } $basename = basename($baseUrl); if (empty($basename) || !strpos(rawurldecode($truncatedRequestUri), $basename)) { return ''; } if ((strlen($requestUri) >= strlen($baseUrl)) && ((false !== ($pos = strpos($requestUri, $baseUrl))) && ($pos !== 0))) { $baseUrl = substr($requestUri, 0, $pos + strlen($baseUrl)); } return rtrim($baseUrl, '/'); } protected function prepareBasePath() { $filename = basename($this->server->get('SCRIPT_FILENAME')); $baseUrl = $this->getBaseUrl(); if (empty($baseUrl)) { return ''; } if (basename($baseUrl) === $filename) { $basePath = dirname($baseUrl); } else { $basePath = $baseUrl; } if ('\\' === DIRECTORY_SEPARATOR) { $basePath = str_replace('\\', '/', $basePath); } return rtrim($basePath, '/'); } protected function preparePathInfo() { $baseUrl = $this->getBaseUrl(); if (null === ($requestUri = $this->getRequestUri())) { return '/'; } $pathInfo = '/'; if ($pos = strpos($requestUri, '?')) { $requestUri = substr($requestUri, 0, $pos); } if ((null !== $baseUrl) && (false === ($pathInfo = substr($requestUri, strlen($baseUrl))))) { return '/'; } elseif (null === $baseUrl) { return $requestUri; } return (string) $pathInfo; } protected static function initializeFormats() { static::$formats = array( 'html' => array('text/html', 'application/xhtml+xml'), 'txt' => array('text/plain'), 'js' => array('application/javascript', 'application/x-javascript', 'text/javascript'), 'css' => array('text/css'), 'json' => array('application/json', 'application/x-json'), 'xml' => array('text/xml', 'application/xml', 'application/x-xml'), 'rdf' => array('application/rdf+xml'), 'atom' => array('application/atom+xml'), 'rss' => array('application/rss+xml'), ); } private function setPhpDefaultLocale($locale) { try { if (class_exists('Locale', false)) { \Locale::setDefault($locale); } } catch (\Exception $e) { } } private function getUrlencodedPrefix($string, $prefix) { if (0 !== strpos(rawurldecode($string), $prefix)) { return false; } $len = strlen($prefix); if (preg_match("#^(%[[:xdigit:]]{2}|.){{$len}}#", $string, $match)) { return $match[0]; } return false; } } } namespace Symfony\Component\HttpFoundation { class ResponseHeaderBag extends HeaderBag { const COOKIES_FLAT = 'flat'; const COOKIES_ARRAY = 'array'; const DISPOSITION_ATTACHMENT = 'attachment'; const DISPOSITION_INLINE = 'inline'; protected $computedCacheControl = array(); protected $cookies = array(); public function __construct(array $headers = array()) { parent::__construct($headers); if (!isset($this->headers['cache-control'])) { $this->set('cache-control', ''); } } public function __toString() { $cookies = ''; foreach ($this->getCookies() as $cookie) { $cookies .= 'Set-Cookie: '.$cookie."\r\n"; } return parent::__toString().$cookies; } public function replace(array $headers = array()) { parent::replace($headers); if (!isset($this->headers['cache-control'])) { $this->set('cache-control', ''); } } public function set($key, $values, $replace = true) { parent::set($key, $values, $replace); if (in_array(strtr(strtolower($key), '_', '-'), array('cache-control', 'etag', 'last-modified', 'expires'))) { $computed = $this->computeCacheControlValue(); $this->headers['cache-control'] = array($computed); $this->computedCacheControl = $this->parseCacheControl($computed); } } public function remove($key) { parent::remove($key); if ('cache-control' === strtr(strtolower($key), '_', '-')) { $this->computedCacheControl = array(); } } public function hasCacheControlDirective($key) { return array_key_exists($key, $this->computedCacheControl); } public function getCacheControlDirective($key) { return array_key_exists($key, $this->computedCacheControl) ? $this->computedCacheControl[$key] : null; } public function setCookie(Cookie $cookie) { $this->cookies[$cookie->getDomain()][$cookie->getPath()][$cookie->getName()] = $cookie; } public function removeCookie($name, $path = '/', $domain = null) { if (null === $path) { $path = '/'; } unset($this->cookies[$domain][$path][$name]); if (empty($this->cookies[$domain][$path])) { unset($this->cookies[$domain][$path]); if (empty($this->cookies[$domain])) { unset($this->cookies[$domain]); } } } public function getCookies($format = self::COOKIES_FLAT) { if (!in_array($format, array(self::COOKIES_FLAT, self::COOKIES_ARRAY))) { throw new \InvalidArgumentException(sprintf('Format "%s" invalid (%s).', $format, implode(', ', array(self::COOKIES_FLAT, self::COOKIES_ARRAY)))); } if (self::COOKIES_ARRAY === $format) { return $this->cookies; } $flattenedCookies = array(); foreach ($this->cookies as $path) { foreach ($path as $cookies) { foreach ($cookies as $cookie) { $flattenedCookies[] = $cookie; } } } return $flattenedCookies; } public function clearCookie($name, $path = '/', $domain = null) { $this->setCookie(new Cookie($name, null, 1, $path, $domain)); } public function makeDisposition($disposition, $filename, $filenameFallback = '') { if (!in_array($disposition, array(self::DISPOSITION_ATTACHMENT, self::DISPOSITION_INLINE))) { throw new \InvalidArgumentException(sprintf('The disposition must be either "%s" or "%s".', self::DISPOSITION_ATTACHMENT, self::DISPOSITION_INLINE)); } if ('' == $filenameFallback) { $filenameFallback = $filename; } if (!preg_match('/^[\x20-\x7e]*$/', $filenameFallback)) { throw new \InvalidArgumentException('The filename fallback must only contain ASCII characters.'); } if (false !== strpos($filenameFallback, '%')) { throw new \InvalidArgumentException('The filename fallback cannot contain the "%" character.'); } if (false !== strpos($filename, '/') || false !== strpos($filename, '\\') || false !== strpos($filenameFallback, '/') || false !== strpos($filenameFallback, '\\')) { throw new \InvalidArgumentException('The filename and the fallback cannot contain the "/" and "\\" characters.'); } $output = sprintf('%s; filename="%s"', $disposition, str_replace('"', '\\"', $filenameFallback)); if ($filename !== $filenameFallback) { $output .= sprintf("; filename*=utf-8''%s", rawurlencode($filename)); } return $output; } protected function computeCacheControlValue() { if (!$this->cacheControl && !$this->has('ETag') && !$this->has('Last-Modified') && !$this->has('Expires')) { return 'no-cache'; } if (!$this->cacheControl) { return 'private, must-revalidate'; } $header = $this->getCacheControlHeader(); if (isset($this->cacheControl['public']) || isset($this->cacheControl['private'])) { return $header; } if (!isset($this->cacheControl['s-maxage'])) { return $header.', private'; } return $header; } } } namespace Symfony\Component\HttpFoundation { class ServerBag extends ParameterBag { public function getHeaders() { $headers = array(); foreach ($this->parameters as $key => $value) { if (0 === strpos($key, 'HTTP_')) { $headers[substr($key, 5)] = $value; } elseif (in_array($key, array('CONTENT_LENGTH', 'CONTENT_MD5', 'CONTENT_TYPE'))) { $headers[$key] = $value; } } if (isset($this->parameters['PHP_AUTH_USER'])) { $headers['PHP_AUTH_USER'] = $this->parameters['PHP_AUTH_USER']; $headers['PHP_AUTH_PW'] = isset($this->parameters['PHP_AUTH_PW']) ? $this->parameters['PHP_AUTH_PW'] : ''; } else { $authorizationHeader = null; if (isset($this->parameters['HTTP_AUTHORIZATION'])) { $authorizationHeader = $this->parameters['HTTP_AUTHORIZATION']; } elseif (isset($this->parameters['REDIRECT_HTTP_AUTHORIZATION'])) { $authorizationHeader = $this->parameters['REDIRECT_HTTP_AUTHORIZATION']; } if ((null !== $authorizationHeader) && (0 === stripos($authorizationHeader, 'basic'))) { $exploded = explode(':', base64_decode(substr($authorizationHeader, 6))); if (count($exploded) == 2) { list($headers['PHP_AUTH_USER'], $headers['PHP_AUTH_PW']) = $exploded; } } } if (isset($headers['PHP_AUTH_USER'])) { $headers['AUTHORIZATION'] = 'Basic '.base64_encode($headers['PHP_AUTH_USER'].':'.$headers['PHP_AUTH_PW']); } return $headers; } } } namespace Symfony\Component\HttpKernel\Controller { use Symfony\Component\HttpFoundation\Request; interface ControllerResolverInterface { public function getController(Request $request); public function getArguments(Request $request, $controller); } } namespace Symfony\Component\HttpKernel\Controller { use Symfony\Component\HttpKernel\Log\LoggerInterface; use Symfony\Component\HttpFoundation\Request; class ControllerResolver implements ControllerResolverInterface { private $logger; public function __construct(LoggerInterface $logger = null) { $this->logger = $logger; } public function getController(Request $request) { if (!$controller = $request->attributes->get('_controller')) { if (null !== $this->logger) { $this->logger->warn('Unable to look for the controller as the "_controller" parameter is missing'); } return false; } if (is_array($controller) || (is_object($controller) && method_exists($controller, '__invoke'))) { return $controller; } if (false === strpos($controller, ':')) { if (method_exists($controller, '__invoke')) { return new $controller; } elseif (function_exists($controller)) { return $controller; } } list($controller, $method) = $this->createController($controller); if (!method_exists($controller, $method)) { throw new \InvalidArgumentException(sprintf('Method "%s::%s" does not exist.', get_class($controller), $method)); } return array($controller, $method); } public function getArguments(Request $request, $controller) { if (is_array($controller)) { $r = new \ReflectionMethod($controller[0], $controller[1]); } elseif (is_object($controller) && !$controller instanceof \Closure) { $r = new \ReflectionObject($controller); $r = $r->getMethod('__invoke'); } else { $r = new \ReflectionFunction($controller); } return $this->doGetArguments($request, $controller, $r->getParameters()); } protected function doGetArguments(Request $request, $controller, array $parameters) { $attributes = $request->attributes->all(); $arguments = array(); foreach ($parameters as $param) { if (array_key_exists($param->name, $attributes)) { $arguments[] = $attributes[$param->name]; } elseif ($param->getClass() && $param->getClass()->isInstance($request)) { $arguments[] = $request; } elseif ($param->isDefaultValueAvailable()) { $arguments[] = $param->getDefaultValue(); } else { if (is_array($controller)) { $repr = sprintf('%s::%s()', get_class($controller[0]), $controller[1]); } elseif (is_object($controller)) { $repr = get_class($controller); } else { $repr = $controller; } throw new \RuntimeException(sprintf('Controller "%s" requires that you provide a value for the "$%s" argument (because there is no default value or because there is a non optional argument after this one).', $repr, $param->name)); } } return $arguments; } protected function createController($controller) { if (false === strpos($controller, '::')) { throw new \InvalidArgumentException(sprintf('Unable to find controller "%s".', $controller)); } list($class, $method) = explode('::', $controller, 2); if (!class_exists($class)) { throw new \InvalidArgumentException(sprintf('Class "%s" does not exist.', $class)); } return array(new $class(), $method); } } } namespace Symfony\Component\EventDispatcher { interface EventSubscriberInterface { public static function getSubscribedEvents(); } } namespace Symfony\Component\HttpKernel\EventListener { use Symfony\Component\HttpKernel\Event\GetResponseEvent; use Symfony\Component\HttpKernel\KernelEvents; use Symfony\Component\Routing\RequestContextAwareInterface; use Symfony\Component\EventDispatcher\EventSubscriberInterface; class LocaleListener implements EventSubscriberInterface { private $router; private $defaultLocale; public function __construct($defaultLocale = 'en', RequestContextAwareInterface $router = null) { $this->defaultLocale = $defaultLocale; $this->router = $router; } public function onKernelRequest(GetResponseEvent $event) { $request = $event->getRequest(); $request->setDefaultLocale($this->defaultLocale); if ($locale = $request->attributes->get('_locale')) { $request->setLocale($locale); } if (null !== $this->router) { $this->router->getContext()->setParameter('_locale', $request->getLocale()); } } public static function getSubscribedEvents() { return array( KernelEvents::REQUEST => array(array('onKernelRequest', 16)), ); } } } namespace Symfony\Component\HttpKernel\EventListener { use Symfony\Component\HttpKernel\Log\LoggerInterface; use Symfony\Component\HttpKernel\Event\GetResponseEvent; use Symfony\Component\HttpKernel\KernelEvents; use Symfony\Component\HttpKernel\Exception\MethodNotAllowedHttpException; use Symfony\Component\HttpKernel\Exception\NotFoundHttpException; use Symfony\Component\Routing\Exception\MethodNotAllowedException; use Symfony\Component\Routing\Exception\ResourceNotFoundException; use Symfony\Component\Routing\Matcher\UrlMatcherInterface; use Symfony\Component\Routing\Matcher\RequestMatcherInterface; use Symfony\Component\Routing\RequestContext; use Symfony\Component\Routing\RequestContextAwareInterface; use Symfony\Component\EventDispatcher\EventSubscriberInterface; class RouterListener implements EventSubscriberInterface { private $matcher; private $context; private $logger; public function __construct($matcher, RequestContext $context = null, LoggerInterface $logger = null) { if (!$matcher instanceof UrlMatcherInterface && !$matcher instanceof RequestMatcherInterface) { throw new \InvalidArgumentException('Matcher must either implement UrlMatcherInterface or RequestMatcherInterface.'); } if (null === $context && !$matcher instanceof RequestContextAwareInterface) { throw new \InvalidArgumentException('You must either pass a RequestContext or the matcher must implement RequestContextAwareInterface.'); } $this->matcher = $matcher; $this->context = $context ?: $matcher->getContext(); $this->logger = $logger; } public function onKernelRequest(GetResponseEvent $event) { $request = $event->getRequest(); $this->context->fromRequest($request); if ($request->attributes->has('_controller')) { return; } try { if ($this->matcher instanceof RequestMatcherInterface) { $parameters = $this->matcher->matchRequest($request); } else { $parameters = $this->matcher->match($request->getPathInfo()); } if (null !== $this->logger) { $this->logger->info(sprintf('Matched route "%s" (parameters: %s)', $parameters['_route'], $this->parametersToString($parameters))); } $request->attributes->add($parameters); unset($parameters['_route']); unset($parameters['_controller']); $request->attributes->set('_route_params', $parameters); } catch (ResourceNotFoundException $e) { $message = sprintf('No route found for "%s %s"', $request->getMethod(), $request->getPathInfo()); throw new NotFoundHttpException($message, $e); } catch (MethodNotAllowedException $e) { $message = sprintf('No route found for "%s %s": Method Not Allowed (Allow: %s)', $request->getMethod(), $request->getPathInfo(), strtoupper(implode(', ', $e->getAllowedMethods()))); throw new MethodNotAllowedHttpException($e->getAllowedMethods(), $message, $e); } } private function parametersToString(array $parameters) { $pieces = array(); foreach ($parameters as $key => $val) { $pieces[] = sprintf('"%s": "%s"', $key, (is_string($val) ? $val : json_encode($val))); } return implode(', ', $pieces); } public static function getSubscribedEvents() { return array( KernelEvents::REQUEST => array(array('onKernelRequest', 32)), ); } } } namespace Symfony\Component\HttpKernel\EventListener { use Symfony\Component\HttpKernel\Event\FilterResponseEvent; use Symfony\Component\HttpKernel\HttpKernelInterface; use Symfony\Component\HttpKernel\KernelEvents; use Symfony\Component\EventDispatcher\EventSubscriberInterface; class ResponseListener implements EventSubscriberInterface { private $charset; public function __construct($charset) { $this->charset = $charset; } public function onKernelResponse(FilterResponseEvent $event) { if (HttpKernelInterface::MASTER_REQUEST !== $event->getRequestType()) { return; } $response = $event->getResponse(); if (null === $response->getCharset()) { $response->setCharset($this->charset); } $response->prepare($event->getRequest()); } public static function getSubscribedEvents() { return array( KernelEvents::RESPONSE => 'onKernelResponse', ); } } } namespace Symfony\Component\HttpKernel\Event { use Symfony\Component\HttpKernel\HttpKernelInterface; use Symfony\Component\HttpFoundation\Request; use Symfony\Component\EventDispatcher\Event; class KernelEvent extends Event { private $kernel; private $request; private $requestType; public function __construct(HttpKernelInterface $kernel, Request $request, $requestType) { $this->kernel = $kernel; $this->request = $request; $this->requestType = $requestType; } public function getKernel() { return $this->kernel; } public function getRequest() { return $this->request; } public function getRequestType() { return $this->requestType; } } } namespace Symfony\Component\HttpKernel\Event { use Symfony\Component\HttpKernel\HttpKernelInterface; use Symfony\Component\HttpFoundation\Request; class FilterControllerEvent extends KernelEvent { private $controller; public function __construct(HttpKernelInterface $kernel, $controller, Request $request, $requestType) { parent::__construct($kernel, $request, $requestType); $this->setController($controller); } public function getController() { return $this->controller; } public function setController($controller) { if (!is_callable($controller)) { throw new \LogicException(sprintf('The controller must be a callable (%s given).', $this->varToString($controller))); } $this->controller = $controller; } private function varToString($var) { if (is_object($var)) { return sprintf('Object(%s)', get_class($var)); } if (is_array($var)) { $a = array(); foreach ($var as $k => $v) { $a[] = sprintf('%s => %s', $k, $this->varToString($v)); } return sprintf("Array(%s)", implode(', ', $a)); } if (is_resource($var)) { return sprintf('Resource(%s)', get_resource_type($var)); } if (null === $var) { return 'null'; } if (false === $var) { return 'false'; } if (true === $var) { return 'true'; } return (string) $var; } } } namespace Symfony\Component\HttpKernel\Event { use Symfony\Component\HttpKernel\HttpKernelInterface; use Symfony\Component\HttpFoundation\Request; use Symfony\Component\HttpFoundation\Response; class FilterResponseEvent extends KernelEvent { private $response; public function __construct(HttpKernelInterface $kernel, Request $request, $requestType, Response $response) { parent::__construct($kernel, $request, $requestType); $this->setResponse($response); } public function getResponse() { return $this->response; } public function setResponse(Response $response) { $this->response = $response; } } } namespace Symfony\Component\HttpKernel\Event { use Symfony\Component\HttpFoundation\Response; class GetResponseEvent extends KernelEvent { private $response; public function getResponse() { return $this->response; } public function setResponse(Response $response) { $this->response = $response; $this->stopPropagation(); } public function hasResponse() { return null !== $this->response; } } } namespace Symfony\Component\HttpKernel\Event { use Symfony\Component\HttpKernel\HttpKernelInterface; use Symfony\Component\HttpFoundation\Request; class GetResponseForControllerResultEvent extends GetResponseEvent { private $controllerResult; public function __construct(HttpKernelInterface $kernel, Request $request, $requestType, $controllerResult) { parent::__construct($kernel, $request, $requestType); $this->controllerResult = $controllerResult; } public function getControllerResult() { return $this->controllerResult; } } } namespace Symfony\Component\HttpKernel\Event { use Symfony\Component\HttpKernel\HttpKernelInterface; use Symfony\Component\HttpFoundation\Request; class GetResponseForExceptionEvent extends GetResponseEvent { private $exception; public function __construct(HttpKernelInterface $kernel, Request $request, $requestType, \Exception $e) { parent::__construct($kernel, $request, $requestType); $this->setException($e); } public function getException() { return $this->exception; } public function setException(\Exception $exception) { $this->exception = $exception; } } } namespace Symfony\Component\HttpKernel\Event { use Symfony\Component\HttpKernel\HttpKernelInterface; use Symfony\Component\EventDispatcher\Event; use Symfony\Component\HttpFoundation\Request; use Symfony\Component\HttpFoundation\Response; class PostResponseEvent extends Event { private $kernel; private $request; private $response; public function __construct(HttpKernelInterface $kernel, Request $request, Response $response) { $this->kernel = $kernel; $this->request = $request; $this->response = $response; } public function getKernel() { return $this->kernel; } public function getRequest() { return $this->request; } public function getResponse() { return $this->response; } } } namespace Symfony\Component\HttpKernel\Exception { interface HttpExceptionInterface { public function getStatusCode(); public function getHeaders(); } } namespace Symfony\Component\HttpKernel\Exception { class HttpException extends \RuntimeException implements HttpExceptionInterface { private $statusCode; private $headers; public function __construct($statusCode, $message = null, \Exception $previous = null, array $headers = array(), $code = 0) { $this->statusCode = $statusCode; $this->headers = $headers; parent::__construct($message, $code, $previous); } public function getStatusCode() { return $this->statusCode; } public function getHeaders() { return $this->headers; } } } namespace Symfony\Component\HttpKernel\Exception { class NotFoundHttpException extends HttpException { public function __construct($message = null, \Exception $previous = null, $code = 0) { parent::__construct(404, $message, $previous, array(), $code); } } } namespace Symfony\Component\HttpKernel\Exception { class MethodNotAllowedHttpException extends HttpException { public function __construct(array $allow, $message = null, \Exception $previous = null, $code = 0) { $headers = array('Allow' => strtoupper(implode(', ', $allow))); parent::__construct(405, $message, $previous, $headers, $code); } } } namespace Symfony\Component\HttpKernel { use Symfony\Component\HttpFoundation\Request; use Symfony\Component\HttpFoundation\Response; interface HttpKernelInterface { const MASTER_REQUEST = 1; const SUB_REQUEST = 2; public function handle(Request $request, $type = self::MASTER_REQUEST, $catch = true); } } namespace Symfony\Component\HttpKernel { use Symfony\Component\HttpFoundation\Request; use Symfony\Component\HttpFoundation\Response; interface TerminableInterface { public function terminate(Request $request, Response $response); } } namespace Symfony\Component\HttpKernel { use Symfony\Component\HttpKernel\Controller\ControllerResolverInterface; use Symfony\Component\HttpKernel\Exception\NotFoundHttpException; use Symfony\Component\HttpKernel\Exception\HttpExceptionInterface; use Symfony\Component\HttpKernel\Event\FilterControllerEvent; use Symfony\Component\HttpKernel\Event\FilterResponseEvent; use Symfony\Component\HttpKernel\Event\GetResponseEvent; use Symfony\Component\HttpKernel\Event\GetResponseForControllerResultEvent; use Symfony\Component\HttpKernel\Event\GetResponseForExceptionEvent; use Symfony\Component\HttpKernel\Event\PostResponseEvent; use Symfony\Component\HttpFoundation\Request; use Symfony\Component\HttpFoundation\Response; use Symfony\Component\EventDispatcher\EventDispatcherInterface; class HttpKernel implements HttpKernelInterface, TerminableInterface { protected $dispatcher; protected $resolver; public function __construct(EventDispatcherInterface $dispatcher, ControllerResolverInterface $resolver) { $this->dispatcher = $dispatcher; $this->resolver = $resolver; } public function handle(Request $request, $type = HttpKernelInterface::MASTER_REQUEST, $catch = true) { try { return $this->handleRaw($request, $type); } catch (\Exception $e) { if (false === $catch) { throw $e; } return $this->handleException($e, $request, $type); } } public function terminate(Request $request, Response $response) { $this->dispatcher->dispatch(KernelEvents::TERMINATE, new PostResponseEvent($this, $request, $response)); } private function handleRaw(Request $request, $type = self::MASTER_REQUEST) { $event = new GetResponseEvent($this, $request, $type); $this->dispatcher->dispatch(KernelEvents::REQUEST, $event); if ($event->hasResponse()) { return $this->filterResponse($event->getResponse(), $request, $type); } if (false === $controller = $this->resolver->getController($request)) { throw new NotFoundHttpException(sprintf('Unable to find the controller for path "%s". Maybe you forgot to add the matching route in your routing configuration?', $request->getPathInfo())); } $event = new FilterControllerEvent($this, $controller, $request, $type); $this->dispatcher->dispatch(KernelEvents::CONTROLLER, $event); $controller = $event->getController(); $arguments = $this->resolver->getArguments($request, $controller); $response = call_user_func_array($controller, $arguments); if (!$response instanceof Response) { $event = new GetResponseForControllerResultEvent($this, $request, $type, $response); $this->dispatcher->dispatch(KernelEvents::VIEW, $event); if ($event->hasResponse()) { $response = $event->getResponse(); } if (!$response instanceof Response) { $msg = sprintf('The controller must return a response (%s given).', $this->varToString($response)); if (null === $response) { $msg .= ' Did you forget to add a return statement somewhere in your controller?'; } throw new \LogicException($msg); } } return $this->filterResponse($response, $request, $type); } private function filterResponse(Response $response, Request $request, $type) { $event = new FilterResponseEvent($this, $request, $type, $response); $this->dispatcher->dispatch(KernelEvents::RESPONSE, $event); return $event->getResponse(); } private function handleException(\Exception $e, $request, $type) { $event = new GetResponseForExceptionEvent($this, $request, $type, $e); $this->dispatcher->dispatch(KernelEvents::EXCEPTION, $event); $e = $event->getException(); if (!$event->hasResponse()) { throw $e; } $response = $event->getResponse(); if ($response->headers->has('X-Status-Code')) { $response->setStatusCode($response->headers->get('X-Status-Code')); $response->headers->remove('X-Status-Code'); } elseif (!$response->isClientError() && !$response->isServerError() && !$response->isRedirect()) { if ($e instanceof HttpExceptionInterface) { $response->setStatusCode($e->getStatusCode()); $response->headers->add($e->getHeaders()); } else { $response->setStatusCode(500); } } try { return $this->filterResponse($response, $request, $type); } catch (\Exception $e) { return $response; } } private function varToString($var) { if (is_object($var)) { return sprintf('Object(%s)', get_class($var)); } if (is_array($var)) { $a = array(); foreach ($var as $k => $v) { $a[] = sprintf('%s => %s', $k, $this->varToString($v)); } return sprintf("Array(%s)", implode(', ', $a)); } if (is_resource($var)) { return sprintf('Resource(%s)', get_resource_type($var)); } if (null === $var) { return 'null'; } if (false === $var) { return 'false'; } if (true === $var) { return 'true'; } return (string) $var; } } } namespace Symfony\Component\HttpKernel { final class KernelEvents { const REQUEST = 'kernel.request'; const EXCEPTION = 'kernel.exception'; const VIEW = 'kernel.view'; const CONTROLLER = 'kernel.controller'; const RESPONSE = 'kernel.response'; const TERMINATE = 'kernel.terminate'; } } namespace Symfony\Component\Process { class Process { const ERR = 'err'; const OUT = 'out'; const STATUS_READY = 'ready'; const STATUS_STARTED = 'started'; const STATUS_TERMINATED = 'terminated'; const STDIN = 0; const STDOUT = 1; const STDERR = 2; private $commandline; private $cwd; private $env; private $stdin; private $timeout; private $options; private $exitcode; private $processInformation; private $stdout; private $stderr; private $enhanceWindowsCompatibility; private $pipes; private $process; private $status = self::STATUS_READY; private $fileHandles; private $readBytes; public static $exitCodes = array( 0 => 'OK', 1 => 'General error', 2 => 'Misuse of shell builtins', 126 => 'Invoked command cannot execute', 127 => 'Command not found', 128 => 'Invalid exit argument', 129 => 'Hangup', 130 => 'Interrupt', 131 => 'Quit and dump core', 132 => 'Illegal instruction', 133 => 'Trace/breakpoint trap', 134 => 'Process aborted', 135 => 'Bus error: "access to undefined portion of memory object"', 136 => 'Floating point exception: "erroneous arithmetic operation"', 137 => 'Kill (terminate immediately)', 138 => 'User-defined 1', 139 => 'Segmentation violation', 140 => 'User-defined 2', 141 => 'Write to pipe with no one reading', 142 => 'Signal raised by alarm', 143 => 'Termination (request to terminate)', 145 => 'Child process terminated, stopped (or continued*)', 146 => 'Continue if stopped', 147 => 'Stop executing temporarily', 148 => 'Terminal stop signal', 149 => 'Background process attempting to read from tty ("in")', 150 => 'Background process attempting to write to tty ("out")', 151 => 'Urgent data available on socket', 152 => 'CPU time limit exceeded', 153 => 'File size limit exceeded', 154 => 'Signal raised by timer counting virtual time: "virtual timer expired"', 155 => 'Profiling timer expired', 157 => 'Pollable event', 159 => 'Bad syscall', ); public function __construct($commandline, $cwd = null, array $env = null, $stdin = null, $timeout = 60, array $options = array()) { if (!function_exists('proc_open')) { throw new \RuntimeException('The Process class relies on proc_open, which is not available on your PHP installation.'); } $this->commandline = $commandline; $this->cwd = null === $cwd ? getcwd() : $cwd; if (null !== $env) { $this->env = array(); foreach ($env as $key => $value) { $this->env[(binary) $key] = (binary) $value; } } else { $this->env = null; } $this->stdin = $stdin; $this->setTimeout($timeout); $this->enhanceWindowsCompatibility = true; $this->options = array_replace(array('suppress_errors' => true, 'binary_pipes' => true), $options); } public function __destruct() { $this->stop(); } public function run($callback = null) { $this->start($callback); return $this->wait($callback); } public function start($callback = null) { if ($this->isRunning()) { throw new \RuntimeException('Process is already running'); } $this->stdout = ''; $this->stderr = ''; $callback = $this->buildCallback($callback); if (defined('PHP_WINDOWS_VERSION_BUILD')) { $this->fileHandles = array( self::STDOUT => tmpfile(), ); $this->readBytes = array( self::STDOUT => 0, ); $descriptors = array(array('pipe', 'r'), $this->fileHandles[self::STDOUT], array('pipe', 'w')); } else { $descriptors = array(array('pipe', 'r'), array('pipe', 'w'), array('pipe', 'w')); } $commandline = $this->commandline; if (defined('PHP_WINDOWS_VERSION_BUILD') && $this->enhanceWindowsCompatibility) { $commandline = 'cmd /V:ON /E:ON /C "'.$commandline.'"'; if (!isset($this->options['bypass_shell'])) { $this->options['bypass_shell'] = true; } } $this->process = proc_open($commandline, $descriptors, $this->pipes, $this->cwd, $this->env, $this->options); if (!is_resource($this->process)) { throw new \RuntimeException('Unable to launch a new process.'); } $this->status = self::STATUS_STARTED; foreach ($this->pipes as $pipe) { stream_set_blocking($pipe, false); } if (null === $this->stdin) { fclose($this->pipes[0]); unset($this->pipes[0]); return; } $writePipes = array($this->pipes[0]); unset($this->pipes[0]); $stdinLen = strlen($this->stdin); $stdinOffset = 0; while ($writePipes) { if (defined('PHP_WINDOWS_VERSION_BUILD')) { $this->processFileHandles($callback); } $r = $this->pipes; $w = $writePipes; $e = null; $n = @stream_select($r, $w, $e, $this->timeout); if (false === $n) { break; } if ($n === 0) { proc_terminate($this->process); throw new \RuntimeException('The process timed out.'); } if ($w) { $written = fwrite($writePipes[0], (binary) substr($this->stdin, $stdinOffset), 8192); if (false !== $written) { $stdinOffset += $written; } if ($stdinOffset >= $stdinLen) { fclose($writePipes[0]); $writePipes = null; } } foreach ($r as $pipe) { $type = array_search($pipe, $this->pipes); $data = fread($pipe, 8192); if (strlen($data) > 0) { call_user_func($callback, $type == 1 ? self::OUT : self::ERR, $data); } if (false === $data || feof($pipe)) { fclose($pipe); unset($this->pipes[$type]); } } } $this->updateStatus(); } public function wait($callback = null) { $this->updateStatus(); $callback = $this->buildCallback($callback); while ($this->pipes || (defined('PHP_WINDOWS_VERSION_BUILD') && $this->fileHandles)) { if (defined('PHP_WINDOWS_VERSION_BUILD') && $this->fileHandles) { $this->processFileHandles($callback, !$this->pipes); } if ($this->pipes) { $r = $this->pipes; $w = null; $e = null; $n = @stream_select($r, $w, $e, $this->timeout); if (false === $n) { $this->pipes = array(); continue; } if (0 === $n) { proc_terminate($this->process); throw new \RuntimeException('The process timed out.'); } foreach ($r as $pipe) { $type = array_search($pipe, $this->pipes); $data = fread($pipe, 8192); if (strlen($data) > 0) { call_user_func($callback, $type == 1 ? self::OUT : self::ERR, $data); } if (false === $data || feof($pipe)) { fclose($pipe); unset($this->pipes[$type]); } } } } $this->updateStatus(); if ($this->processInformation['signaled']) { throw new \RuntimeException(sprintf('The process stopped because of a "%s" signal.', $this->processInformation['stopsig'])); } $time = 0; while ($this->isRunning() && $time < 1000000) { $time += 1000; usleep(1000); } $exitcode = proc_close($this->process); if ($this->processInformation['signaled']) { throw new \RuntimeException(sprintf('The process stopped because of a "%s" signal.', $this->processInformation['stopsig'])); } return $this->exitcode = $this->processInformation['running'] ? $exitcode : $this->processInformation['exitcode']; } public function getOutput() { $this->updateOutput(); return $this->stdout; } public function getErrorOutput() { $this->updateErrorOutput(); return $this->stderr; } public function getExitCode() { $this->updateStatus(); return $this->exitcode; } public function getExitCodeText() { $this->updateStatus(); return isset(self::$exitCodes[$this->exitcode]) ? self::$exitCodes[$this->exitcode] : 'Unknown error'; } public function isSuccessful() { $this->updateStatus(); return 0 == $this->exitcode; } public function hasBeenSignaled() { $this->updateStatus(); return $this->processInformation['signaled']; } public function getTermSignal() { $this->updateStatus(); return $this->processInformation['termsig']; } public function hasBeenStopped() { $this->updateStatus(); return $this->processInformation['stopped']; } public function getStopSignal() { $this->updateStatus(); return $this->processInformation['stopsig']; } public function isRunning() { if (self::STATUS_STARTED !== $this->status) { return false; } $this->updateStatus(); return $this->processInformation['running']; } public function stop($timeout=10) { $timeoutMicro = (int) $timeout*10E6; if ($this->isRunning()) { proc_terminate($this->process); $time = 0; while (1 == $this->isRunning() && $time < $timeoutMicro) { $time += 1000; usleep(1000); } foreach ($this->pipes as $pipe) { fclose($pipe); } $this->pipes = array(); $exitcode = proc_close($this->process); $this->exitcode = -1 === $this->processInformation['exitcode'] ? $exitcode : $this->processInformation['exitcode']; if (defined('PHP_WINDOWS_VERSION_BUILD')) { foreach ($this->fileHandles as $fileHandle) { fclose($fileHandle); } $this->fileHandles = array(); } } $this->status = self::STATUS_TERMINATED; return $this->exitcode; } public function addOutput($line) { $this->stdout .= $line; } public function addErrorOutput($line) { $this->stderr .= $line; } public function getCommandLine() { return $this->commandline; } public function setCommandLine($commandline) { $this->commandline = $commandline; } public function getTimeout() { return $this->timeout; } public function setTimeout($timeout) { if (null === $timeout) { $this->timeout = null; return; } $timeout = (integer) $timeout; if ($timeout < 0) { throw new \InvalidArgumentException('The timeout value must be a valid positive integer.'); } $this->timeout = $timeout; } public function getWorkingDirectory() { return $this->cwd; } public function setWorkingDirectory($cwd) { $this->cwd = $cwd; } public function getEnv() { return $this->env; } public function setEnv(array $env) { $this->env = $env; } public function getStdin() { return $this->stdin; } public function setStdin($stdin) { $this->stdin = $stdin; } public function getOptions() { return $this->options; } public function setOptions(array $options) { $this->options = $options; } public function getEnhanceWindowsCompatibility() { return $this->enhanceWindowsCompatibility; } public function setEnhanceWindowsCompatibility($enhance) { $this->enhanceWindowsCompatibility = (Boolean) $enhance; } protected function buildCallback($callback) { $that = $this; $out = self::OUT; $err = self::ERR; $callback = function ($type, $data) use ($that, $callback, $out, $err) { if ($out == $type) { $that->addOutput($data); } else { $that->addErrorOutput($data); } if (null !== $callback) { call_user_func($callback, $type, $data); } }; return $callback; } protected function updateStatus() { if (self::STATUS_STARTED !== $this->status) { return; } $this->processInformation = proc_get_status($this->process); if (!$this->processInformation['running']) { $this->status = self::STATUS_TERMINATED; if (-1 !== $this->processInformation['exitcode']) { $this->exitcode = $this->processInformation['exitcode']; } } } protected function updateErrorOutput() { if (isset($this->pipes[self::STDERR]) && is_resource($this->pipes[self::STDERR])) { $this->addErrorOutput(stream_get_contents($this->pipes[self::STDERR])); } } protected function updateOutput() { if (defined('PHP_WINDOWS_VERSION_BUILD') && isset($this->fileHandles[self::STDOUT]) && is_resource($this->fileHandles[self::STDOUT])) { fseek($this->fileHandles[self::STDOUT], $this->readBytes[self::STDOUT]); $this->addOutput(stream_get_contents($this->fileHandles[self::STDOUT])); } elseif (isset($this->pipes[self::STDOUT]) && is_resource($this->pipes[self::STDOUT])) { $this->addOutput(stream_get_contents($this->pipes[self::STDOUT])); } } private function processFileHandles($callback, $closeEmptyHandles = false) { $fh = $this->fileHandles; foreach ($fh as $type => $fileHandle) { fseek($fileHandle, $this->readBytes[$type]); $data = fread($fileHandle, 8192); if (strlen($data) > 0) { $this->readBytes[$type] += strlen($data); call_user_func($callback, $type == 1 ? self::OUT : self::ERR, $data); } if (false === $data || ($closeEmptyHandles && '' === $data && feof($fileHandle))) { fclose($fileHandle); unset($this->fileHandles[$type]); } } } } } namespace Symfony\Component\Routing\Exception { interface ExceptionInterface { } } namespace Symfony\Component\Routing\Exception { class InvalidParameterException extends \InvalidArgumentException implements ExceptionInterface { } } namespace Symfony\Component\Routing\Exception { class MethodNotAllowedException extends \RuntimeException implements ExceptionInterface { protected $allowedMethods; public function __construct(array $allowedMethods, $message = null, $code = 0, \Exception $previous = null) { $this->allowedMethods = array_map('strtoupper', $allowedMethods); parent::__construct($message, $code, $previous); } public function getAllowedMethods() { return $this->allowedMethods; } } } namespace Symfony\Component\Routing\Exception { class MissingMandatoryParametersException extends \InvalidArgumentException implements ExceptionInterface { } } namespace Symfony\Component\Routing\Exception { class ResourceNotFoundException extends \RuntimeException implements ExceptionInterface { } } namespace Symfony\Component\Routing\Exception { class RouteNotFoundException extends \InvalidArgumentException implements ExceptionInterface { } } namespace Symfony\Component\Routing { interface RequestContextAwareInterface { public function setContext(RequestContext $context); public function getContext(); } } namespace Symfony\Component\Routing\Generator { use Symfony\Component\Routing\RequestContextAwareInterface; use Symfony\Component\Routing\Exception\RouteNotFoundException; interface UrlGeneratorInterface extends RequestContextAwareInterface { public function generate($name, $parameters = array(), $absolute = false); } } namespace Symfony\Component\Routing\Generator { interface ConfigurableRequirementsInterface { public function setStrictRequirements($enabled); public function isStrictRequirements(); } } namespace Symfony\Component\Routing\Generator { use Symfony\Component\Routing\Route; use Symfony\Component\Routing\RouteCollection; use Symfony\Component\Routing\RequestContext; use Symfony\Component\Routing\Exception\InvalidParameterException; use Symfony\Component\Routing\Exception\RouteNotFoundException; use Symfony\Component\Routing\Exception\MissingMandatoryParametersException; use Symfony\Component\HttpKernel\Log\LoggerInterface; class UrlGenerator implements UrlGeneratorInterface, ConfigurableRequirementsInterface { protected $context; protected $strictRequirements = true; protected $logger; protected $decodedChars = array( '%2F' => '/', '%40' => '@', '%3A' => ':', '%3B' => ';', '%2C' => ',', '%3D' => '=', '%2B' => '+', '%21' => '!', '%2A' => '*', '%7C' => '|', ); protected $routes; public function __construct(RouteCollection $routes, RequestContext $context, LoggerInterface $logger = null) { $this->routes = $routes; $this->context = $context; $this->logger = $logger; } public function setContext(RequestContext $context) { $this->context = $context; } public function getContext() { return $this->context; } public function setStrictRequirements($enabled) { $this->strictRequirements = (Boolean) $enabled; } public function isStrictRequirements() { return $this->strictRequirements; } public function generate($name, $parameters = array(), $absolute = false) { if (null === $route = $this->routes->get($name)) { throw new RouteNotFoundException(sprintf('Route "%s" does not exist.', $name)); } $compiledRoute = $route->compile(); return $this->doGenerate($compiledRoute->getVariables(), $route->getDefaults(), $route->getRequirements(), $compiledRoute->getTokens(), $parameters, $name, $absolute); } protected function doGenerate($variables, $defaults, $requirements, $tokens, $parameters, $name, $absolute) { $variables = array_flip($variables); $originParameters = $parameters; $parameters = array_replace($this->context->getParameters(), $parameters); $tparams = array_replace($defaults, $parameters); if ($diff = array_diff_key($variables, $tparams)) { throw new MissingMandatoryParametersException(sprintf('The "%s" route has some missing mandatory parameters ("%s").', $name, implode('", "', array_keys($diff)))); } $url = ''; $optional = true; foreach ($tokens as $token) { if ('variable' === $token[0]) { if (false === $optional || !array_key_exists($token[3], $defaults) || (isset($parameters[$token[3]]) && (string) $parameters[$token[3]] != (string) $defaults[$token[3]])) { if (!$isEmpty = in_array($tparams[$token[3]], array(null, '', false), true)) { if ($tparams[$token[3]] && !preg_match('#^'.$token[2].'$#', $tparams[$token[3]])) { $message = sprintf('Parameter "%s" for route "%s" must match "%s" ("%s" given).', $token[3], $name, $token[2], $tparams[$token[3]]); if ($this->strictRequirements) { throw new InvalidParameterException($message); } if ($this->logger) { $this->logger->err($message); } return null; } } if (!$isEmpty || !$optional) { $url = $token[1].$tparams[$token[3]].$url; } $optional = false; } } elseif ('text' === $token[0]) { $url = $token[1].$url; $optional = false; } } if ('' === $url) { $url = '/'; } $url = $this->context->getBaseUrl().strtr(rawurlencode($url), $this->decodedChars); $url = strtr($url, array('/../' => '/%2E%2E/', '/./' => '/%2E/')); if ('/..' === substr($url, -3)) { $url = substr($url, 0, -2) . '%2E%2E'; } elseif ('/.' === substr($url, -2)) { $url = substr($url, 0, -1) . '%2E'; } $extra = array_diff_key($originParameters, $variables, $defaults); if ($extra && $query = http_build_query($extra, '', '&')) { $url .= '?'.$query; } if ($this->context->getHost()) { $scheme = $this->context->getScheme(); if (isset($requirements['_scheme']) && ($req = strtolower($requirements['_scheme'])) && $scheme != $req) { $absolute = true; $scheme = $req; } if ($absolute) { $port = ''; if ('http' === $scheme && 80 != $this->context->getHttpPort()) { $port = ':'.$this->context->getHttpPort(); } elseif ('https' === $scheme && 443 != $this->context->getHttpsPort()) { $port = ':'.$this->context->getHttpsPort(); } $url = $scheme.'://'.$this->context->getHost().$port.$url; } } return $url; } } } namespace Symfony\Component\Routing\Matcher { use Symfony\Component\Routing\RequestContextAwareInterface; use Symfony\Component\Routing\Exception\ResourceNotFoundException; use Symfony\Component\Routing\Exception\MethodNotAllowedException; interface UrlMatcherInterface extends RequestContextAwareInterface { public function match($pathinfo); } } namespace Symfony\Component\Routing\Matcher { interface RedirectableUrlMatcherInterface { public function redirect($path, $route, $scheme = null); } } namespace Symfony\Component\Routing\Matcher { use Symfony\Component\Routing\Exception\MethodNotAllowedException; use Symfony\Component\Routing\Exception\ResourceNotFoundException; use Symfony\Component\Routing\RouteCollection; use Symfony\Component\Routing\RequestContext; use Symfony\Component\Routing\Route; class UrlMatcher implements UrlMatcherInterface { const REQUIREMENT_MATCH = 0; const REQUIREMENT_MISMATCH = 1; const ROUTE_MATCH = 2; protected $context; protected $allow; private $routes; public function __construct(RouteCollection $routes, RequestContext $context) { $this->routes = $routes; $this->context = $context; } public function setContext(RequestContext $context) { $this->context = $context; } public function getContext() { return $this->context; } public function match($pathinfo) { $this->allow = array(); if ($ret = $this->matchCollection(rawurldecode($pathinfo), $this->routes)) { return $ret; } throw 0 < count($this->allow) ? new MethodNotAllowedException(array_unique(array_map('strtoupper', $this->allow))) : new ResourceNotFoundException(); } protected function matchCollection($pathinfo, RouteCollection $routes) { foreach ($routes as $name => $route) { if ($route instanceof RouteCollection) { if (false === strpos($route->getPrefix(), '{') && $route->getPrefix() !== substr($pathinfo, 0, strlen($route->getPrefix()))) { continue; } if (!$ret = $this->matchCollection($pathinfo, $route)) { continue; } return $ret; } $compiledRoute = $route->compile(); if ('' !== $compiledRoute->getStaticPrefix() && 0 !== strpos($pathinfo, $compiledRoute->getStaticPrefix())) { continue; } if (!preg_match($compiledRoute->getRegex(), $pathinfo, $matches)) { continue; } if ($req = $route->getRequirement('_method')) { if ('HEAD' === $method = $this->context->getMethod()) { $method = 'GET'; } if (!in_array($method, $req = explode('|', strtoupper($req)))) { $this->allow = array_merge($this->allow, $req); continue; } } $status = $this->handleRouteRequirements($pathinfo, $name, $route); if (self::ROUTE_MATCH === $status[0]) { return $status[1]; } if (self::REQUIREMENT_MISMATCH === $status[0]) { continue; } return array_merge($this->mergeDefaults($matches, $route->getDefaults()), array('_route' => $name)); } } protected function handleRouteRequirements($pathinfo, $name, Route $route) { $scheme = $route->getRequirement('_scheme'); $status = $scheme && $scheme !== $this->context->getScheme() ? self::REQUIREMENT_MISMATCH : self::REQUIREMENT_MATCH; return array($status, null); } protected function mergeDefaults($params, $defaults) { $parameters = $defaults; foreach ($params as $key => $value) { if (!is_int($key)) { $parameters[$key] = $value; } } return $parameters; } } } namespace Symfony\Component\Routing\Matcher { use Symfony\Component\Routing\Exception\ResourceNotFoundException; use Symfony\Component\Routing\Route; abstract class RedirectableUrlMatcher extends UrlMatcher implements RedirectableUrlMatcherInterface { public function match($pathinfo) { try { $parameters = parent::match($pathinfo); } catch (ResourceNotFoundException $e) { if ('/' === substr($pathinfo, -1) || !in_array($this->context->getMethod(), array('HEAD', 'GET'))) { throw $e; } try { parent::match($pathinfo.'/'); return $this->redirect($pathinfo.'/', null); } catch (ResourceNotFoundException $e2) { throw $e; } } return $parameters; } protected function handleRouteRequirements($pathinfo, $name, Route $route) { $scheme = $route->getRequirement('_scheme'); if ($scheme && $this->context->getScheme() !== $scheme) { return array(self::ROUTE_MATCH, $this->redirect($pathinfo, $name, $scheme)); } return array(self::REQUIREMENT_MATCH, null); } } } namespace Symfony\Component\Routing { use Symfony\Component\HttpFoundation\Request; class RequestContext { private $baseUrl; private $method; private $host; private $scheme; private $httpPort; private $httpsPort; private $parameters; public function __construct($baseUrl = '', $method = 'GET', $host = 'localhost', $scheme = 'http', $httpPort = 80, $httpsPort = 443) { $this->baseUrl = $baseUrl; $this->method = strtoupper($method); $this->host = $host; $this->scheme = strtolower($scheme); $this->httpPort = $httpPort; $this->httpsPort = $httpsPort; $this->parameters = array(); } public function fromRequest(Request $request) { $this->setBaseUrl($request->getBaseUrl()); $this->setMethod($request->getMethod()); $this->setHost($request->getHost()); $this->setScheme($request->getScheme()); $this->setHttpPort($request->isSecure() ? $this->httpPort : $request->getPort()); $this->setHttpsPort($request->isSecure() ? $request->getPort() : $this->httpsPort); } public function getBaseUrl() { return $this->baseUrl; } public function setBaseUrl($baseUrl) { $this->baseUrl = $baseUrl; } public function getMethod() { return $this->method; } public function setMethod($method) { $this->method = strtoupper($method); } public function getHost() { return $this->host; } public function setHost($host) { $this->host = $host; } public function getScheme() { return $this->scheme; } public function setScheme($scheme) { $this->scheme = strtolower($scheme); } public function getHttpPort() { return $this->httpPort; } public function setHttpPort($httpPort) { $this->httpPort = $httpPort; } public function getHttpsPort() { return $this->httpsPort; } public function setHttpsPort($httpsPort) { $this->httpsPort = $httpsPort; } public function getParameters() { return $this->parameters; } public function setParameters(array $parameters) { $this->parameters = $parameters; return $this; } public function getParameter($name) { return isset($this->parameters[$name]) ? $this->parameters[$name] : null; } public function hasParameter($name) { return array_key_exists($name, $this->parameters); } public function setParameter($name, $parameter) { $this->parameters[$name] = $parameter; } } } namespace Symfony\Component\Routing { class Route implements \Serializable { private $pattern; private $defaults; private $requirements; private $options; private $compiled; private static $compilers = array(); public function __construct($pattern, array $defaults = array(), array $requirements = array(), array $options = array()) { $this->setPattern($pattern); $this->setDefaults($defaults); $this->setRequirements($requirements); $this->setOptions($options); } public function __clone() { $this->compiled = null; } public function serialize() { return serialize(array( 'pattern' => $this->pattern, 'defaults' => $this->defaults, 'requirements' => $this->requirements, 'options' => $this->options, )); } public function unserialize($data) { $data = unserialize($data); $this->pattern = $data['pattern']; $this->defaults = $data['defaults']; $this->requirements = $data['requirements']; $this->options = $data['options']; } public function getPattern() { return $this->pattern; } public function setPattern($pattern) { $this->pattern = trim($pattern); if ('' === $this->pattern || '/' !== $this->pattern[0]) { $this->pattern = '/'.$this->pattern; } $this->compiled = null; return $this; } public function getOptions() { return $this->options; } public function setOptions(array $options) { $this->options = array( 'compiler_class' => 'Symfony\\Component\\Routing\\RouteCompiler', ); return $this->addOptions($options); } public function addOptions(array $options) { foreach ($options as $name => $option) { $this->options[(string) $name] = $option; } $this->compiled = null; return $this; } public function setOption($name, $value) { $this->options[$name] = $value; $this->compiled = null; return $this; } public function getOption($name) { return isset($this->options[$name]) ? $this->options[$name] : null; } public function getDefaults() { return $this->defaults; } public function setDefaults(array $defaults) { $this->defaults = array(); return $this->addDefaults($defaults); } public function addDefaults(array $defaults) { foreach ($defaults as $name => $default) { $this->defaults[(string) $name] = $default; } $this->compiled = null; return $this; } public function getDefault($name) { return isset($this->defaults[$name]) ? $this->defaults[$name] : null; } public function hasDefault($name) { return array_key_exists($name, $this->defaults); } public function setDefault($name, $default) { $this->defaults[(string) $name] = $default; $this->compiled = null; return $this; } public function getRequirements() { return $this->requirements; } public function setRequirements(array $requirements) { $this->requirements = array(); return $this->addRequirements($requirements); } public function addRequirements(array $requirements) { foreach ($requirements as $key => $regex) { $this->requirements[$key] = $this->sanitizeRequirement($key, $regex); } $this->compiled = null; return $this; } public function getRequirement($key) { return isset($this->requirements[$key]) ? $this->requirements[$key] : null; } public function setRequirement($key, $regex) { $this->requirements[$key] = $this->sanitizeRequirement($key, $regex); $this->compiled = null; return $this; } public function compile() { if (null !== $this->compiled) { return $this->compiled; } $class = $this->getOption('compiler_class'); if (!isset(self::$compilers[$class])) { self::$compilers[$class] = new $class; } return $this->compiled = self::$compilers[$class]->compile($this); } private function sanitizeRequirement($key, $regex) { if (!is_string($regex)) { throw new \InvalidArgumentException(sprintf('Routing requirement for "%s" must be a string', $key)); } if ('' === $regex) { throw new \InvalidArgumentException(sprintf('Routing requirement for "%s" cannot be empty', $key)); } if ('^' === $regex[0]) { $regex = substr($regex, 1); } if ('$' === substr($regex, -1)) { $regex = substr($regex, 0, -1); } return $regex; } } } namespace Symfony\Component\Routing { class CompiledRoute { private $route; private $variables; private $tokens; private $staticPrefix; private $regex; public function __construct(Route $route, $staticPrefix, $regex, array $tokens, array $variables) { $this->route = $route; $this->staticPrefix = $staticPrefix; $this->regex = $regex; $this->tokens = $tokens; $this->variables = $variables; } public function getRoute() { return $this->route; } public function getStaticPrefix() { return $this->staticPrefix; } public function getRegex() { return $this->regex; } public function getTokens() { return $this->tokens; } public function getVariables() { return $this->variables; } public function getPattern() { return $this->route->getPattern(); } public function getOptions() { return $this->route->getOptions(); } public function getDefaults() { return $this->route->getDefaults(); } public function getRequirements() { return $this->route->getRequirements(); } } } namespace Symfony\Component\Routing { use Symfony\Component\Config\Resource\ResourceInterface; class RouteCollection implements \IteratorAggregate, \Countable { private $routes; private $resources; private $prefix; private $parent; public function __construct() { $this->routes = array(); $this->resources = array(); $this->prefix = ''; } public function __clone() { foreach ($this->routes as $name => $route) { $this->routes[$name] = clone $route; if ($route instanceof RouteCollection) { $this->routes[$name]->setParent($this); } } } public function getParent() { return $this->parent; } public function getRoot() { $parent = $this; while ($parent->getParent()) { $parent = $parent->getParent(); } return $parent; } public function getIterator() { return new \ArrayIterator($this->routes); } public function count() { $count = 0; foreach ($this->routes as $route) { $count += $route instanceof RouteCollection ? count($route) : 1; } return $count; } public function add($name, Route $route) { if (!preg_match('/^[a-z0-9A-Z_.]+$/', $name)) { throw new \InvalidArgumentException(sprintf('The provided route name "%s" contains non valid characters. A route name must only contain digits (0-9), letters (a-z and A-Z), underscores (_) and dots (.).', $name)); } $this->remove($name); $this->routes[$name] = $route; } public function all() { $routes = array(); foreach ($this->routes as $name => $route) { if ($route instanceof RouteCollection) { $routes = array_merge($routes, $route->all()); } else { $routes[$name] = $route; } } return $routes; } public function get($name) { if (isset($this->routes[$name])) { return $this->routes[$name] instanceof RouteCollection ? null : $this->routes[$name]; } foreach ($this->routes as $routes) { if ($routes instanceof RouteCollection && null !== $route = $routes->get($name)) { return $route; } } return null; } public function remove($name) { $root = $this->getRoot(); foreach ((array) $name as $n) { $root->removeRecursively($n); } } public function addCollection(RouteCollection $collection, $prefix = '', $defaults = array(), $requirements = array(), $options = array()) { $root = $this->getRoot(); if ($root === $collection || $root->hasCollection($collection)) { throw new \InvalidArgumentException('The RouteCollection already exists in the tree.'); } $this->remove(array_keys($collection->all())); $collection->setParent($this); $collection->addPrefix($this->getPrefix() . $prefix, $defaults, $requirements, $options); $this->routes[] = $collection; } public function addPrefix($prefix, $defaults = array(), $requirements = array(), $options = array()) { $prefix = rtrim($prefix, '/'); if ('' === $prefix && empty($defaults) && empty($requirements) && empty($options)) { return; } if ('' !== $prefix && '/' !== $prefix[0]) { $prefix = '/'.$prefix; } $this->prefix = $prefix.$this->prefix; foreach ($this->routes as $route) { if ($route instanceof RouteCollection) { $route->addPrefix($prefix, $defaults, $requirements, $options); } else { $route->setPattern($prefix.$route->getPattern()); $route->addDefaults($defaults); $route->addRequirements($requirements); $route->addOptions($options); } } } public function getPrefix() { return $this->prefix; } public function getResources() { $resources = $this->resources; foreach ($this as $routes) { if ($routes instanceof RouteCollection) { $resources = array_merge($resources, $routes->getResources()); } } return array_unique($resources); } public function addResource(ResourceInterface $resource) { $this->resources[] = $resource; } private function setParent(RouteCollection $parent) { $this->parent = $parent; } private function removeRecursively($name) { if (isset($this->routes[$name])) { unset($this->routes[$name]); return true; } foreach ($this->routes as $routes) { if ($routes instanceof RouteCollection && $routes->removeRecursively($name)) { return true; } } return false; } private function hasCollection(RouteCollection $collection) { foreach ($this->routes as $routes) { if ($routes === $collection || $routes instanceof RouteCollection && $routes->hasCollection($collection)) { return true; } } return false; } } } namespace Symfony\Component\Routing { interface RouteCompilerInterface { public function compile(Route $route); } } namespace Symfony\Component\Routing { class RouteCompiler implements RouteCompilerInterface { const REGEX_DELIMITER = '#'; public function compile(Route $route) { $pattern = $route->getPattern(); $len = strlen($pattern); $tokens = array(); $variables = array(); $pos = 0; preg_match_all('#.\{(\w+)\}#', $pattern, $matches, PREG_OFFSET_CAPTURE | PREG_SET_ORDER); foreach ($matches as $match) { if ($text = substr($pattern, $pos, $match[0][1] - $pos)) { $tokens[] = array('text', $text); } $pos = $match[0][1] + strlen($match[0][0]); $var = $match[1][0]; if ($req = $route->getRequirement($var)) { $regexp = $req; } else { $separators = array($match[0][0][0]); if ($pos !== $len) { $separators[] = $pattern[$pos]; } $regexp = sprintf('[^%s]+', preg_quote(implode('', array_unique($separators)), self::REGEX_DELIMITER)); } $tokens[] = array('variable', $match[0][0][0], $regexp, $var); if (in_array($var, $variables)) { throw new \LogicException(sprintf('Route pattern "%s" cannot reference variable name "%s" more than once.', $route->getPattern(), $var)); } $variables[] = $var; } if ($pos < $len) { $tokens[] = array('text', substr($pattern, $pos)); } $firstOptional = INF; for ($i = count($tokens) - 1; $i >= 0; $i--) { $token = $tokens[$i]; if ('variable' === $token[0] && $route->hasDefault($token[3])) { $firstOptional = $i; } else { break; } } $regexp = ''; for ($i = 0, $nbToken = count($tokens); $i < $nbToken; $i++) { $regexp .= $this->computeRegexp($tokens, $i, $firstOptional); } return new CompiledRoute( $route, 'text' === $tokens[0][0] ? $tokens[0][1] : '', self::REGEX_DELIMITER.'^'.$regexp.'$'.self::REGEX_DELIMITER.'s', array_reverse($tokens), $variables ); } private function computeRegexp(array $tokens, $index, $firstOptional) { $token = $tokens[$index]; if ('text' === $token[0]) { return preg_quote($token[1], self::REGEX_DELIMITER); } else { if (0 === $index && 0 === $firstOptional) { return sprintf('%s(?<%s>%s)?', preg_quote($token[1], self::REGEX_DELIMITER), $token[3], $token[2]); } else { $regexp = sprintf('%s(?<%s>%s)', preg_quote($token[1], self::REGEX_DELIMITER), $token[3], $token[2]); if ($index >= $firstOptional) { $regexp = "(?:$regexp"; $nbTokens = count($tokens); if ($nbTokens - 1 == $index) { $regexp .= str_repeat(")?", $nbTokens - $firstOptional - (0 === $firstOptional ? 1 : 0)); } } return $regexp; } } } } } namespace Symfony\Bridge\Twig\Extension { use Symfony\Component\Routing\Generator\UrlGeneratorInterface; class RoutingExtension extends \Twig_Extension { private $generator; public function __construct(UrlGeneratorInterface $generator) { $this->generator = $generator; } public function getFunctions() { return array( 'url' => new \Twig_Function_Method($this, 'getUrl'), 'path' => new \Twig_Function_Method($this, 'getPath'), ); } public function getPath($name, $parameters = array()) { return $this->generator->generate($name, $parameters, false); } public function getUrl($name, $parameters = array()) { return $this->generator->generate($name, $parameters, true); } public function getName() { return 'routing'; } } } namespace { class Pimple implements ArrayAccess { private $values; public function __construct (array $values = array()) { $this->values = $values; } public function offsetSet($id, $value) { $this->values[$id] = $value; } public function offsetGet($id) { if (!array_key_exists($id, $this->values)) { throw new InvalidArgumentException(sprintf('Identifier "%s" is not defined.', $id)); } return $this->values[$id] instanceof Closure ? $this->values[$id]($this) : $this->values[$id]; } public function offsetExists($id) { return array_key_exists($id, $this->values); } public function offsetUnset($id) { unset($this->values[$id]); } public function share(Closure $callable) { return function ($c) use ($callable) { static $object; if (null === $object) { $object = $callable($c); } return $object; }; } public function protect(Closure $callable) { return function ($c) use ($callable) { return $callable; }; } public function raw($id) { if (!array_key_exists($id, $this->values)) { throw new InvalidArgumentException(sprintf('Identifier "%s" is not defined.', $id)); } return $this->values[$id]; } public function extend($id, Closure $callable) { if (!array_key_exists($id, $this->values)) { throw new InvalidArgumentException(sprintf('Identifier "%s" is not defined.', $id)); } $factory = $this->values[$id]; if (!($factory instanceof Closure)) { throw new InvalidArgumentException(sprintf('Identifier "%s" does not contain an object definition.', $id)); } return $this->values[$id] = function ($c) use ($callable, $factory) { return $callable($factory($c), $c); }; } public function keys() { return array_keys($this->values); } } } namespace Silex { use Symfony\Component\HttpKernel\HttpKernel; use Symfony\Component\HttpKernel\HttpKernelInterface; use Symfony\Component\HttpKernel\TerminableInterface; use Symfony\Component\HttpKernel\Event\GetResponseForControllerResultEvent; use Symfony\Component\HttpKernel\Event\GetResponseForExceptionEvent; use Symfony\Component\HttpKernel\Event\FilterControllerEvent; use Symfony\Component\HttpKernel\Event\FilterResponseEvent; use Symfony\Component\HttpKernel\Event\GetResponseEvent; use Symfony\Component\HttpKernel\Event\PostResponseEvent; use Symfony\Component\HttpKernel\EventListener\LocaleListener; use Symfony\Component\HttpKernel\EventListener\ResponseListener; use Symfony\Component\HttpKernel\EventListener\RouterListener; use Symfony\Component\HttpKernel\Exception\HttpExceptionInterface; use Symfony\Component\HttpKernel\Exception\HttpException; use Symfony\Component\HttpKernel\KernelEvents; use Symfony\Component\HttpFoundation\Request; use Symfony\Component\HttpFoundation\Response; use Symfony\Component\HttpFoundation\RedirectResponse; use Symfony\Component\HttpFoundation\StreamedResponse; use Symfony\Component\HttpFoundation\JsonResponse; use Symfony\Component\EventDispatcher\Event; use Symfony\Component\EventDispatcher\EventDispatcher; use Symfony\Component\EventDispatcher\EventSubscriberInterface; use Symfony\Component\Routing\RouteCollection; use Symfony\Component\Routing\RequestContext; use Silex\RedirectableUrlMatcher; use Silex\ControllerResolver; class Application extends \Pimple implements HttpKernelInterface, EventSubscriberInterface, TerminableInterface { const VERSION = '1.0-DEV'; private $providers = array(); private $booted = false; private $beforeDispatched = false; public function __construct() { $app = $this; $this['logger'] = null; $this['autoloader'] = function () { throw new \RuntimeException('You tried to access the autoloader service. The autoloader has been removed from Silex. It is recommended that you use Composer to manage your dependencies and handle your autoloading. See http://getcomposer.org for more information.'); }; $this['routes'] = $this->share(function () { return new RouteCollection(); }); $this['controllers'] = $this->share(function () use ($app) { return $app['controllers_factory']; }); $this['controllers_factory'] = function () use ($app) { return new ControllerCollection($app['route_factory']); }; $this['route_class'] = 'Silex\\Route'; $this['route_factory'] = function () use ($app) { return new $app['route_class'](); }; $this['exception_handler'] = $this->share(function () { return new ExceptionHandler(); }); $this['dispatcher'] = $this->share(function () use ($app) { $dispatcher = new EventDispatcher(); $dispatcher->addSubscriber($app); $urlMatcher = new LazyUrlMatcher(function () use ($app) { return $app['url_matcher']; }); $dispatcher->addSubscriber(new RouterListener($urlMatcher, $app['request_context'], $app['logger'])); $dispatcher->addSubscriber(new LocaleListener($app['locale'], $urlMatcher)); return $dispatcher; }); $this['resolver'] = $this->share(function () use ($app) { return new ControllerResolver($app, $app['logger']); }); $this['kernel'] = $this->share(function () use ($app) { return new HttpKernel($app['dispatcher'], $app['resolver']); }); $this['request_context'] = $this->share(function () use ($app) { $context = new RequestContext(); $context->setHttpPort($app['request.http_port']); $context->setHttpsPort($app['request.https_port']); return $context; }); $this['url_matcher'] = $this->share(function () use ($app) { return new RedirectableUrlMatcher($app['routes'], $app['request_context']); }); $this['route_before_middlewares_trigger'] = $this->protect(function (GetResponseEvent $event) use ($app) { $request = $event->getRequest(); $routeName = $request->attributes->get('_route'); if (!$route = $app['routes']->get($routeName)) { return; } foreach ((array) $route->getOption('_before_middlewares') as $callback) { $ret = call_user_func($callback, $request, $app); if ($ret instanceof Response) { $event->setResponse($ret); return; } elseif (null !== $ret) { throw new \RuntimeException(sprintf('A before middleware for route "%s" returned an invalid response value. Must return null or an instance of Response.', $routeName)); } } }); $this['route_after_middlewares_trigger'] = $this->protect(function (FilterResponseEvent $event) use ($app) { $request = $event->getRequest(); $routeName = $request->attributes->get('_route'); if (!$route = $app['routes']->get($routeName)) { return; } foreach ((array) $route->getOption('_after_middlewares') as $callback) { $response = call_user_func($callback, $request, $event->getResponse()); if ($response instanceof Response) { $event->setResponse($response); } elseif (null !== $response) { throw new \RuntimeException(sprintf('An after middleware for route "%s" returned an invalid response value. Must return null or an instance of Response.', $routeName)); } } }); $this['request_error'] = $this->protect(function () { throw new \RuntimeException('Accessed request service outside of request scope. Try moving that call to a before handler or controller.'); }); $this['request'] = $this['request_error']; $this['request.http_port'] = 80; $this['request.https_port'] = 443; $this['debug'] = false; $this['charset'] = 'UTF-8'; $this['locale'] = 'en'; } public function register(ServiceProviderInterface $provider, array $values = array()) { $this->providers[] = $provider; $provider->register($this); foreach ($values as $key => $value) { $this[$key] = $value; } } public function boot() { if (!$this->booted) { foreach ($this->providers as $provider) { $provider->boot($this); } $this->booted = true; } } public function match($pattern, $to) { return $this['controllers']->match($pattern, $to); } public function get($pattern, $to) { return $this['controllers']->get($pattern, $to); } public function post($pattern, $to) { return $this['controllers']->post($pattern, $to); } public function put($pattern, $to) { return $this['controllers']->put($pattern, $to); } public function delete($pattern, $to) { return $this['controllers']->delete($pattern, $to); } public function before($callback, $priority = 0) { $this['dispatcher']->addListener(SilexEvents::BEFORE, function (GetResponseEvent $event) use ($callback) { $ret = call_user_func($callback, $event->getRequest()); if ($ret instanceof Response) { $event->setResponse($ret); } }, $priority); } public function after($callback, $priority = 0) { $this['dispatcher']->addListener(SilexEvents::AFTER, function (FilterResponseEvent $event) use ($callback) { call_user_func($callback, $event->getRequest(), $event->getResponse()); }, $priority); } public function finish($callback, $priority = 0) { $this['dispatcher']->addListener(SilexEvents::FINISH, function (PostResponseEvent $event) use ($callback) { call_user_func($callback, $event->getRequest(), $event->getResponse()); }, $priority); } public function abort($statusCode, $message = '', array $headers = array()) { throw new HttpException($statusCode, $message, null, $headers); } public function error($callback, $priority = 0) { $this['dispatcher']->addListener(SilexEvents::ERROR, function (GetResponseForExceptionEvent $event) use ($callback) { $exception = $event->getException(); if (is_array($callback)) { $callbackReflection = new \ReflectionMethod($callback[0], $callback[1]); } elseif (is_object($callback) && !$callback instanceof \Closure) { $callbackReflection = new \ReflectionObject($callback); $callbackReflection = $callbackReflection->getMethod('__invoke'); } else { $callbackReflection = new \ReflectionFunction($callback); } if ($callbackReflection->getNumberOfParameters() > 0) { $parameters = $callbackReflection->getParameters(); $expectedException = $parameters[0]; if ($expectedException->getClass() && !$expectedException->getClass()->isInstance($exception)) { return; } } $code = $exception instanceof HttpExceptionInterface ? $exception->getStatusCode() : 500; $result = call_user_func($callback, $exception, $code); if (null !== $result) { $response = $result instanceof Response ? $result : new Response((string) $result); $event->setResponse($response); } }, $priority); } public function flush($prefix = '') { $this['routes']->addCollection($this['controllers']->flush($prefix), $prefix); } public function redirect($url, $status = 302) { return new RedirectResponse($url, $status); } public function stream($callback = null, $status = 200, $headers = array()) { return new StreamedResponse($callback, $status, $headers); } public function escape($text, $flags = ENT_COMPAT, $charset = null, $doubleEncode = true) { return htmlspecialchars($text, $flags, $charset ?: $this['charset'], $doubleEncode); } public function json($data = array(), $status = 200, $headers = array()) { return new JsonResponse($data, $status, $headers); } public function mount($prefix, $app) { if ($app instanceof ControllerProviderInterface) { $app = $app->connect($this); } if (!$app instanceof ControllerCollection) { throw new \LogicException('The "mount" method takes either a ControllerCollection or a ControllerProviderInterface instance.'); } $this['routes']->addCollection($app->flush($prefix), $prefix); } public function run(Request $request = null) { if (null === $request) { $request = Request::createFromGlobals(); } $response = $this->handle($request); $response->send(); $this->terminate($request, $response); } public function handle(Request $request, $type = HttpKernelInterface::MASTER_REQUEST, $catch = true) { if (!$this->booted) { $this->boot(); } $this->beforeDispatched = false; $current = HttpKernelInterface::SUB_REQUEST === $type ? $this['request'] : $this['request_error']; $this['request'] = $request; $this->flush(); $response = $this['kernel']->handle($request, $type, $catch); $this['request'] = $current; return $response; } public function terminate(Request $request, Response $response) { $this['kernel']->terminate($request, $response); } public function onEarlyKernelRequest(GetResponseEvent $event) { if (HttpKernelInterface::MASTER_REQUEST === $event->getRequestType()) { if (isset($this['exception_handler'])) { $this['dispatcher']->addSubscriber($this['exception_handler']); } $this['dispatcher']->addSubscriber(new ResponseListener($this['charset'])); } } public function onKernelRequest(GetResponseEvent $event) { $this['locale'] = $event->getRequest()->getLocale(); if (HttpKernelInterface::MASTER_REQUEST === $event->getRequestType()) { $this->beforeDispatched = true; $this['dispatcher']->dispatch(SilexEvents::BEFORE, $event); } $this['route_before_middlewares_trigger']($event); } public function onKernelController(FilterControllerEvent $event) { $request = $event->getRequest(); $route = $this['routes']->get($request->attributes->get('_route')); if ($route && $converters = $route->getOption('_converters')) { foreach ($converters as $name => $callback) { $request->attributes->set($name, call_user_func($callback, $request->attributes->get($name, null), $request)); } } } public function onKernelView(GetResponseForControllerResultEvent $event) { $response = $event->getControllerResult(); $response = $response instanceof Response ? $response : new Response((string) $response); $event->setResponse($response); } public function onKernelResponse(FilterResponseEvent $event) { $this['route_after_middlewares_trigger']($event); if (HttpKernelInterface::MASTER_REQUEST === $event->getRequestType()) { $this['dispatcher']->dispatch(SilexEvents::AFTER, $event); } } public function onKernelTerminate(PostResponseEvent $event) { $this['dispatcher']->dispatch(SilexEvents::FINISH, $event); } public function onKernelException(GetResponseForExceptionEvent $event) { if (!$this->beforeDispatched) { $this->beforeDispatched = true; try { $this['dispatcher']->dispatch(SilexEvents::BEFORE, $event); } catch (\Exception $e) { } } $errorEvent = new GetResponseForExceptionEvent($this, $event->getRequest(), $event->getRequestType(), $event->getException()); $this['dispatcher']->dispatch(SilexEvents::ERROR, $errorEvent); if ($errorEvent->hasResponse()) { $event->setResponse($errorEvent->getResponse()); } } public static function getSubscribedEvents() { return array( KernelEvents::REQUEST => array( array('onEarlyKernelRequest', 256), array('onKernelRequest') ), KernelEvents::CONTROLLER => 'onKernelController', KernelEvents::RESPONSE => 'onKernelResponse', KernelEvents::EXCEPTION => array('onKernelException', -10), KernelEvents::TERMINATE => 'onKernelTerminate', KernelEvents::VIEW => array('onKernelView', -10), ); } } } namespace Silex { use Silex\Exception\ControllerFrozenException; class Controller { private $route; private $routeName; private $isFrozen = false; public function __construct(Route $route) { $this->route = $route; } public function getRoute() { return $this->route; } public function getRouteName() { return $this->routeName; } public function bind($routeName) { if ($this->isFrozen) { throw new ControllerFrozenException(sprintf('Calling %s on frozen %s instance.', __METHOD__, __CLASS__)); } $this->routeName = $routeName; return $this; } public function __call($method, $arguments) { if (!method_exists($this->route, $method)) { throw new \BadMethodCallException(sprintf('Method "%s::%s" does not exist.', get_class($this->route), $method)); } call_user_func_array(array($this->route, $method), $arguments); return $this; } public function freeze() { $this->isFrozen = true; } public function generateRouteName($prefix) { $requirements = $this->route->getRequirements(); $method = isset($requirements['_method']) ? $requirements['_method'] : ''; $routeName = $prefix.$method.$this->route->getPattern(); $routeName = str_replace(array('/', ':', '|', '-'), '_', $routeName); $routeName = preg_replace('/[^a-z0-9A-Z_.]+/', '', $routeName); return $routeName; } } } namespace Silex { use Symfony\Component\Routing\RouteCollection; use Silex\Controller; class ControllerCollection { protected $controllers = array(); protected $defaultRoute; public function __construct(Route $defaultRoute) { $this->defaultRoute = $defaultRoute; } public function match($pattern, $to) { $route = clone $this->defaultRoute; $route->setPattern($pattern); $route->setDefault('_controller', $to); $this->controllers[] = $controller = new Controller($route); return $controller; } public function get($pattern, $to) { return $this->match($pattern, $to)->method('GET'); } public function post($pattern, $to) { return $this->match($pattern, $to)->method('POST'); } public function put($pattern, $to) { return $this->match($pattern, $to)->method('PUT'); } public function delete($pattern, $to) { return $this->match($pattern, $to)->method('DELETE'); } public function __call($method, $arguments) { if (!method_exists($this->defaultRoute, $method)) { throw new \BadMethodCallException(sprintf('Method "%s::%s" does not exist.', get_class($this->defaultRoute), $method)); } call_user_func_array(array($this->defaultRoute, $method), $arguments); foreach ($this->controllers as $controller) { call_user_func_array(array($controller, $method), $arguments); } return $this; } public function flush($prefix = '') { $routes = new RouteCollection(); foreach ($this->controllers as $controller) { if (!$name = $controller->getRouteName()) { $name = $controller->generateRouteName($prefix); while ($routes->get($name)) { $name .= '_'; } $controller->bind($name); } $routes->add($name, $controller->getRoute()); $controller->freeze(); } $this->controllers = array(); return $routes; } } } namespace Silex { use Symfony\Component\HttpKernel\Controller\ControllerResolver as BaseControllerResolver; use Symfony\Component\HttpKernel\Log\LoggerInterface; use Symfony\Component\HttpFoundation\Request; class ControllerResolver extends BaseControllerResolver { protected $app; public function __construct(Application $app, LoggerInterface $logger = null) { $this->app = $app; parent::__construct($logger); } protected function doGetArguments(Request $request, $controller, array $parameters) { foreach ($parameters as $param) { if ($param->getClass() && $param->getClass()->isInstance($this->app)) { $request->attributes->set($param->getName(), $this->app); break; } } return parent::doGetArguments($request, $controller, $parameters); } } } namespace Silex { use Symfony\Component\HttpKernel\Debug\ExceptionHandler as DebugExceptionHandler; use Symfony\Component\EventDispatcher\EventSubscriberInterface; use Symfony\Component\HttpKernel\Event\GetResponseForExceptionEvent; class ExceptionHandler implements EventSubscriberInterface { public function onSilexError(GetResponseForExceptionEvent $event) { $app = $event->getKernel(); $handler = new DebugExceptionHandler($app['debug']); $event->setResponse($handler->createResponse($event->getException())); } public static function getSubscribedEvents() { return array(SilexEvents::ERROR => array('onSilexError', -255)); } } } namespace Silex\Exception { class ControllerFrozenException extends \RuntimeException { } } namespace Silex { use Symfony\Component\Routing\RequestContext; use Symfony\Component\Routing\Matcher\UrlMatcherInterface; class LazyUrlMatcher implements UrlMatcherInterface { private $factory; public function __construct(\Closure $factory) { $this->factory = $factory; } public function getUrlMatcher() { $urlMatcher = call_user_func($this->factory); if (!$urlMatcher instanceof UrlMatcherInterface) { throw new \LogicException("Factory supplied to LazyUrlMatcher must return implementation of UrlMatcherInterface."); } return $urlMatcher; } public function match($pathinfo) { return $this->getUrlMatcher()->match($pathinfo); } public function setContext(RequestContext $context) { $this->getUrlMatcher()->setContext($context); } public function getContext() { return $this->getUrlMatcher()->getContext(); } } } namespace Silex\Provider { use Symfony\Component\HttpFoundation\Request; use Symfony\Component\HttpKernel\HttpKernelInterface; class TwigCoreExtension extends \Twig_Extension { public function getFunctions() { return array( 'render' => new \Twig_Function_Method($this, 'render', array('needs_environment' => true, 'is_safe' => array('html'))), ); } public function render(\Twig_Environment $twig, $uri) { $globals = $twig->getGlobals(); $request = $globals['app']['request']; $subRequest = Request::create($uri, 'get', array(), $request->cookies->all(), array(), $request->server->all()); if ($request->getSession()) { $subRequest->setSession($request->getSession()); } $response = $globals['app']->handle($subRequest, HttpKernelInterface::SUB_REQUEST, false); if (!$response->isSuccessful()) { throw new \RuntimeException(sprintf('Error when rendering "%s" (Status code is %s).', $request->getUri(), $response->getStatusCode())); } return $response->getContent(); } public function getName() { return 'silex'; } } } namespace Silex { interface ServiceProviderInterface { public function register(Application $app); public function boot(Application $app); } } namespace Silex\Provider { use Silex\Application; use Silex\ServiceProviderInterface; use Symfony\Bridge\Twig\Extension\RoutingExtension; use Symfony\Bridge\Twig\Extension\TranslationExtension; use Symfony\Bridge\Twig\Extension\FormExtension; use Symfony\Bridge\Twig\Extension\SecurityExtension; use Symfony\Bridge\Twig\Form\TwigRendererEngine; use Symfony\Bridge\Twig\Form\TwigRenderer; class TwigServiceProvider implements ServiceProviderInterface { public function register(Application $app) { $app['twig.options'] = array(); $app['twig.form.templates'] = array('form_div_layout.html.twig'); $app['twig.path'] = array(); $app['twig.templates'] = array(); $app['twig'] = $app->share(function ($app) { $app['twig.options'] = array_replace( array( 'charset' => $app['charset'], 'debug' => $app['debug'], 'strict_variables' => $app['debug'], ), $app['twig.options'] ); $twig = new \Twig_Environment($app['twig.loader'], $app['twig.options']); $twig->addGlobal('app', $app); $twig->addExtension(new TwigCoreExtension()); if ($app['debug']) { $twig->addExtension(new \Twig_Extension_Debug()); } if (class_exists('Symfony\Bridge\Twig\Extension\RoutingExtension')) { if (isset($app['url_generator'])) { $twig->addExtension(new RoutingExtension($app['url_generator'])); } if (isset($app['translator'])) { $twig->addExtension(new TranslationExtension($app['translator'])); } if (isset($app['security'])) { $twig->addExtension(new SecurityExtension($app['security'])); } if (isset($app['form.factory'])) { $app['twig.form.engine'] = $app->share(function ($app) { return new TwigRendererEngine($app['twig.form.templates']); }); $app['twig.form.renderer'] = $app->share(function ($app) { return new TwigRenderer($app['twig.form.engine'], $app['form.csrf_provider']); }); $twig->addExtension(new FormExtension($app['twig.form.renderer'])); $reflected = new \ReflectionClass('Symfony\Bridge\Twig\Extension\FormExtension'); $path = dirname($reflected->getFileName()).'/../Resources/views/Form'; $app['twig.loader']->addLoader(new \Twig_Loader_Filesystem($path)); } } if (isset($app['twig.configure'])) { throw new \RuntimeException('The twig.configure service has been removed. Read the changelog to learn how you can upgrade your code.'); } return $twig; }); $app['twig.loader.filesystem'] = $app->share(function ($app) { return new \Twig_Loader_Filesystem($app['twig.path']); }); $app['twig.loader.array'] = $app->share(function ($app) { return new \Twig_Loader_Array($app['twig.templates']); }); $app['twig.loader'] = $app->share(function ($app) { return new \Twig_Loader_Chain(array( $app['twig.loader.filesystem'], $app['twig.loader.array'], )); }); } public function boot(Application $app) { if (isset($app['twig.class_path'])) { throw new \RuntimeException('You have provided the twig.class_path parameter. The autoloader has been removed from Silex. It is recommended that you use Composer to manage your dependencies and handle your autoloading. If you are already using Composer, you can remove the parameter. See http://getcomposer.org for more information.'); } } } } namespace Silex\Provider { use Silex\Application; use Silex\ServiceProviderInterface; use Symfony\Component\Routing\Generator\UrlGenerator; class UrlGeneratorServiceProvider implements ServiceProviderInterface { public function register(Application $app) { $app['url_generator'] = $app->share(function ($app) { $app->flush(); return new UrlGenerator($app['routes'], $app['request_context']); }); } public function boot(Application $app) { } } } namespace Silex { use Symfony\Component\HttpFoundation\RedirectResponse; use Symfony\Component\Routing\Matcher\RedirectableUrlMatcher as BaseRedirectableUrlMatcher; use Symfony\Component\Routing\Matcher\RedirectableUrlMatcherInterface; class RedirectableUrlMatcher extends BaseRedirectableUrlMatcher { public function redirect($path, $route, $scheme = null) { $url = $this->context->getBaseUrl().$path; if ($this->context->getHost()) { if ($scheme) { $port = ''; if ('http' === $scheme && 80 != $this->context->getHttpPort()) { $port = ':'.$this->context->getHttpPort(); } elseif ('https' === $scheme && 443 != $this->context->getHttpsPort()) { $port = ':'.$this->context->getHttpsPort(); } $url = $scheme.'://'.$this->context->getHost().$port.$url; } } return array( '_controller' => function ($url) { return new RedirectResponse($url, 301); }, 'url' => $url, ); } } } namespace Silex { final class SilexEvents { const BEFORE = 'silex.before'; const AFTER = 'silex.after'; const FINISH = 'silex.finish'; const ERROR = 'silex.error'; } } namespace Silex { use Symfony\Component\Routing\Route as BaseRoute; class Route extends BaseRoute { public function __construct($pattern = '', array $defaults = array(), array $requirements = array(), array $options = array()) { parent::__construct($pattern, $defaults, $requirements, $options); } public function assert($variable, $regexp) { $this->setRequirement($variable, $regexp); return $this; } public function value($variable, $default) { $this->setDefault($variable, $default); return $this; } public function convert($variable, $callback) { $converters = $this->getOption('_converters'); $converters[$variable] = $callback; $this->setOption('_converters', $converters); return $this; } public function method($method) { $this->setRequirement('_method', $method); return $this; } public function requireHttp() { $this->setRequirement('_scheme', 'http'); return $this; } public function requireHttps() { $this->setRequirement('_scheme', 'https'); return $this; } public function before($callback) { $callbacks = $this->getOption('_before_middlewares'); $callbacks[] = $callback; $this->setOption('_before_middlewares', $callbacks); return $this; } public function after($callback) { $callbacks = $this->getOption('_after_middlewares'); $callbacks[] = $callback; $this->setOption('_after_middlewares', $callbacks); return $this; } } } namespace Sismo { class AnsiEscapeSequencesConverter { static public function convertToHtml($text) { $text = preg_replace('#\033\[(K|s|u|2J|2K|\d+(A|B|C|D|E|F|G|J|K|S|T)|\d+;\d+(H|f))#', '', $text); return preg_replace_callback("#\033\[(.+?)m(?:\033\[(?:.+?)m)*(.+?)\033\[0m#s", function ($matches) { $options = explode(';', $matches[1]); $text = $matches[2]; $classes = array(); $colors = array('black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white'); foreach ($options as $option) { if ($option >= 30 && $option < 40) { $classes[] = sprintf('ansi_color_fg_%s', $colors[$option - 30]); } elseif ($option >= 40 && $option < 50) { $classes[] = sprintf('ansi_color_bg_%s', $colors[$option - 40]); } } if (in_array(4, $options)) { $classes[] = 'underlined'; } if (in_array(1, $options)) { $text = sprintf('<strong>%s</strong>', $text); } if ($classes) { return sprintf('<span class="%s">%s</span>', implode(' ', $classes), $text); } return $text; }, $text); } } } namespace Sismo { use Symfony\Component\Process\Process; class Builder { private $project; private $baseBuildDir; private $buildDir; private $callback; private $gitPath; private $gitCmds; public function __construct($buildDir, $gitPath, array $gitCmds) { $this->baseBuildDir = $buildDir; $this->gitPath = $gitPath; $this->gitCmds = array_replace(array( 'clone' => 'clone --progress --recursive %repo% %dir% --branch %localbranch%', 'fetch' => 'fetch origin', 'prepare' => 'submodule update --init --recursive', 'checkout' => 'checkout %branch%', 'reset' => 'reset --hard %revision%', 'show' => 'show -s --pretty=format:%format% %revision%', ), $gitCmds); } public function init(Project $project, $callback = null) { $this->project = $project; $this->callback = $callback; $this->buildDir = $this->baseBuildDir.'/'.$this->getBuildDir($project); } public function build() { file_put_contents($this->buildDir.'/sismo-run-tests.sh', str_replace(array("\r\n", "\r"), "\n", $this->project->getCommand())); $process = new Process('sh sismo-run-tests.sh', $this->buildDir); $process->setTimeout(3600); $process->run($this->callback); return $process; } public function getBuildDir(Project $project) { return substr(md5($project->getRepository().$project->getBranch()), 0, 6); } public function prepare($revision, $sync) { if (!file_exists($this->buildDir)) { mkdir($this->buildDir, 0777, true); } if (!file_exists($this->buildDir.'/.git')) { $this->execute($this->getGitCommand('clone'), sprintf('Unable to clone repository for project "%s".', $this->project)); } if ($sync) { $this->execute($this->gitPath.' '.$this->gitCmds['fetch'], sprintf('Unable to fetch repository for project "%s".', $this->project)); $this->execute($this->gitPath.' '.$this->gitCmds['prepare'], sprintf('Unable to update submodules for project "%s".', $this->project)); } $this->execute($this->getGitCommand('checkout'), sprintf('Unable to checkout branch "%s" for project "%s".', $this->project->getBranch(), $this->project)); if (null === $revision || 'HEAD' === $revision) { $revision = null; if (file_exists($file = $this->buildDir.'/.git/HEAD')) { $revision = trim(file_get_contents($file)); if (0 === strpos($revision, 'ref: ')) { if (file_exists($file = $this->buildDir.'/.git/'.substr($revision, 5))) { $revision = trim(file_get_contents($file)); } else { $revision = null; } } } if (null === $revision) { throw new BuildException(sprintf('Unable to get HEAD for branch "%s" for project "%s".', $this->project->getBranch(), $this->project)); } } $this->execute($this->getGitCommand('reset', array('%revision%' => escapeshellarg($revision))), sprintf('Revision "%s" for project "%s" does not exist.', $revision, $this->project)); $process = $this->execute($this->getGitCommand('show', array('%revision%' => escapeshellarg($revision))), sprintf('Unable to get logs for project "%s".', $this->project)); return explode("\n", trim($process->getOutput()), 4); } protected function getGitCommand($command, array $replace = array()) { $replace = array_merge(array( '%repo%' => escapeshellarg($this->project->getRepository()), '%dir%' => escapeshellarg($this->buildDir), '%branch%' => escapeshellarg('origin/'.$this->project->getBranch()), '%localbranch%' => escapeshellarg($this->project->getBranch()), '%format%' => escapeshellarg('%H%n%an%n%ci%n%s%n'), ), $replace); return strtr($this->gitPath.' '.$this->gitCmds[$command], $replace); } private function execute($command, $message) { if (null !== $this->callback) { call_user_func($this->callback, 'out', sprintf("Running \"%s\"\n", $command)); } $process = new Process($command, $this->buildDir); $process->setTimeout(3600); $process->run($this->callback); if (!$process->isSuccessful()) { throw new BuildException($message); } return $process; } } } namespace Sismo { class BuildException extends \Exception { } } namespace Sismo { class Commit { private $project; private $sha; private $message; private $author; private $date; private $build; private $output; private $buildDate; private $status = 'building'; private $statuses = array('building' => 'building', 'success' => 'succeeded', 'failed' => 'failed'); public function __construct(Project $project, $sha) { $this->project = $project; $this->sha = $sha; } public function __toString() { return sprintf('%s@%s', $this->project, $this->getShortSha()); } public function isBuilding() { return 'building' === $this->status; } public function isBuilt() { return in_array($this->status, array('success', 'failed')); } public function isSuccessful() { return 'success' === $this->status; } public function setStatusCode($status) { if (!in_array($status, array('building', 'success', 'failed'))) { throw new \InvalidArgumentException(sprintf('Invalid status code "%s".', $status)); } $this->status = $status; } public function getStatusCode() { return $this->status; } public function getStatus() { return $this->statuses[$this->status]; } public function setOutput($output) { $this->output = $output; } public function getOutput() { return $this->output; } public function getDecoratedOutput() { return AnsiEscapeSequencesConverter::convertToHtml($this->output); } public function getMessage() { return $this->message; } public function setMessage($message) { $this->message = $message; } public function getSha() { return $this->sha; } public function getShortSha() { return substr($this->sha, 0, 6); } public function getProject() { return $this->project; } public function getAuthor() { return $this->author; } public function setAuthor($author) { $this->author = $author; } public function getDate() { return $this->date; } public function setDate(\DateTime $date) { $this->date = $date; } public function getBuildDate() { return $this->buildDate; } public function setBuildDate(\DateTime $date) { $this->buildDate = $date; } } } namespace Sismo\Notifier { use Sismo\Commit; abstract class Notifier { abstract public function notify(Commit $commit); protected function format($format, Commit $commit) { return strtr($format, $this->getPlaceholders($commit)); } protected function getPlaceholders(Commit $commit) { $project = $commit->getProject(); return array( '%slug%' => $project->getSlug(), '%name%' => $project->getName(), '%status%' => $commit->getStatus(), '%status_code%' => $commit->getStatusCode(), '%STATUS%' => strtoupper($commit->getStatus()), '%sha%' => $commit->getSha(), '%short_sha%' => $commit->getShortSha(), '%author%' => $commit->getAuthor(), '%message%' => $commit->getMessage(), '%output%' => $commit->getOutput(), ); } } } namespace Sismo\Contrib { use Sismo\Notifier\Notifier; use Sismo\Commit; class XmppNotifier extends Notifier { private $format; private $host; private $port; private $username; private $password; private $server; private $recipient; public function __construct($host, $port, $server, $username, $password, $recipient, $format = '[%STATUS%] %name% %short_sha% -- %message% by %author%') { $this->host = $host; $this->port = $port; $this->server = $server; $this->username = $username; $this->password = $password; $this->recipient = $recipient; $this->format = $format; } public function notify(Commit $commit) { $old = error_reporting(0); $conn = new \XMPPHP_XMPP($this->host, $this->port, $this->username, $this->password, 'sismo', $this->server); $conn->connect(); $conn->processUntil('session_start'); $conn->presence(); foreach (explode(',', $this->recipient) as $user) { $conn->message($user, $this->format($this->format, $commit)); } $conn->disconnect(); error_reporting($old); } } } namespace Sismo\Contrib { class GoogleTalkNotifier extends XmppNotifier { public function __construct($username, $password, $recipient, $format = '[%STATUS%] %name% %short_sha% -- %message% by %author%') { parent::__construct('talk.google.com', 5222, 'gmail.com', $username, $password, $recipient, $format); } } } namespace Sismo\Notifier { use Symfony\Component\Process\Process; use Sismo\Commit; class DBusNotifier extends Notifier { public function __construct($format = "[%STATUS%]\n%message%\n%author%") { $this->format = $format; } public function notify(Commit $commit) { $process = new Process(sprintf('notify-send "%s" "%s"', $commit->getProject()->getName(), $this->format($this->format, $commit))); $process->setTimeout(2); $process->run(); if ($process->isSuccessful()) { return; } $process = new Process(sprintf('dbus-send --print-reply --dest=org.freedesktop.Notifications /org/freedesktop/Notifications org.freedesktop.Notifications.Notify string:"sismo" int32:0 string:"" string:"%s" string:"%s" array:string:"" dict:string:"" int32:-1', $commit->getProject()->getName(), $this->format($this->format, $commit))); $process->setTimeout(2); $process->run(); if ($process->isSuccessful()) { return; } } } } namespace Sismo\Notifier { use Sismo\Commit; class GrowlNotifier extends Notifier { private $application; private $address; private $notifications; private $password; private $port; private $registered; private $format; public function __construct($password, $application = 'sismo', $address = 'localhost', $format = "[%STATUS%]\n%message%\n%author%", $port = 9887) { $this->application = $application; $this->address = $address; $this->password = $password; $this->format = $format; $this->port = $port; $this->registered = false; $this->notifications = array( array('name' => 'Success', 'enabled' => true), array('name' => 'Fail', 'enabled' => true), ); } public function notify(Commit $commit) { $this->register(); return $this->doNotify($commit->isSuccessful() ? 'Success' : 'Fail', $commit->getProject()->getName(), $this->format($this->format, $commit)); } private function register() { if (true === $this->registered) { return; } $this->registered = true; $data = ''; $defaults = ''; $nbDefaults = 0; foreach ($this->notifications as $i => $notification) { $data .= pack('n', strlen($notification['name'])).$notification['name']; if ($notification['enabled']) { $defaults .= pack('c', $i); ++$nbDefaults; } } $data = pack('c2nc2', 1, 0, strlen($this->application), count($this->notifications), $nbDefaults).$this->application.$data.$defaults; $this->send($data); } private function doNotify($name, $title, $message) { $data = pack('c2n5', 1, 1, 0, strlen($name), strlen($title), strlen($message), strlen($this->application)).$name.$title.$message.$this->application; $this->send($data); } private function send($data) { $data .= pack('H32', md5($data.$this->password)); $fp = fsockopen('udp://'.$this->address, $this->port); fwrite($fp, $data); fclose($fp); } } } namespace Sismo { use Sismo\Notifier\Notifier; class Project { protected static $defaultCommand = 'phpunit'; protected $name; protected $slug; protected $repository; protected $branch = 'master'; protected $command; protected $urlPattern; protected $commits = array(); protected $building = false; protected $notifiers = array(); public function __construct($name, $repository = null, $notifiers = array(), $slug = null) { $this->name = $name; $this->slug = $slug ?: $this->slugify($name); $this->command = static::$defaultCommand; if (null !== $repository) { $this->setRepository($repository); } if (!is_array($notifiers)) { $notifiers = array($notifiers); } foreach ($notifiers as $notifier) { $this->addNotifier($notifier); } } public function __toString() { return $this->name; } public function setBuilding($bool) { $this->building = (Boolean) $bool; } public function isBuilding() { return $this->building; } public function addNotifier(Notifier $notifier) { $this->notifiers[] = $notifier; } public function getNotifiers() { return $this->notifiers; } public function setBranch($branch) { $this->branch = $branch; } public function getBranch() { return $this->branch; } public function setCommits(array $commits = array()) { $this->commits = $commits; } public function getCommits() { return $this->commits; } public function getLatestCommit() { return $this->commits ? $this->commits[0] : null; } public function getStatusCode() { return !$this->commits ? 'no_build' : $this->commits[0]->getStatusCode(); } public function getStatus() { return !$this->commits ? 'not built yet' : $this->commits[0]->getStatus(); } public function getCCStatus() { if (!$this->commits || !$this->commits[0]->isBuilt()) { return 'Unknown'; } return $this->commits[0]->isSuccessful() ? 'Success' : 'Failure'; } public function getCCActivity() { return $this->commits && $this->commits[0]->isBuilding() ? 'Building' : 'Sleeping'; } public function getName() { return $this->name; } public function getShortName() { list($name, ) = explode('(', $this->name); return trim($name); } public function getSubName() { if (false !== $pos = strpos($this->name, '(')) { return trim(substr($this->name, $pos + 1, -1)); } return ''; } public function getSlug() { return $this->slug; } public function setSlug($slug) { $this->slug = $slug; } public function getRepository() { return $this->repository; } public function setRepository($url) { if (false !== strpos($url, '@')) { list($url, $branch) = explode('@', $url); $this->branch = $branch; } $this->repository = $url; } public function getCommand() { return $this->command; } public function setCommand($command) { $this->command = $command; } public static function setDefaultCommand($command) { self::$defaultCommand = $command; } public function getUrlPattern() { return $this->urlPattern; } public function setUrlPattern($pattern) { $this->urlPattern = $pattern; } private function slugify($text) { $text = preg_replace('#[^\\pL\d]+#u', '-', $text); $text = trim($text, '-'); if (function_exists('iconv')) { $text = iconv('utf-8', 'us-ascii//TRANSLIT', $text); } $text = strtolower($text); $text = preg_replace('#[^-\w]+#', '', $text); if (empty($text)) { throw new \RuntimeException(sprintf('Unable to compute a slug for "%s". Define it explicitly.', $text)); } return $text; } } } namespace Sismo { use Symfony\Component\Process\Process; class GithubProject extends Project { public function setRepository($url) { parent::setRepository($url); if (file_exists($this->getRepository())) { $process = new Process('git remote -v', $this->getRepository()); $process->run(); foreach (explode("\n", $process->getOutput()) as $line) { $parts = explode("\t", $line); if ('origin' == $parts[0] && preg_match('#(?:\:|/|@)github.com(?:\:|/)(.*?)/(.*?)\.git#', $parts[1], $matches)) { $this->setUrlPattern(sprintf('https://github.com/%s/%s/commit/%%commit%%', $matches[1], $matches[2])); break; } } } elseif (preg_match('#^[a-z0-9_-]+/[a-z0-9_-]+$#i', $this->getRepository())) { $this->setUrlPattern(sprintf('https://github.com/%s/commit/%%commit%%', $this->getRepository())); parent::setRepository(sprintf('https://github.com/%s.git', $this->getRepository())); } else { throw new \InvalidArgumentException(sprintf('URL "%s" does not look like a Github repository.', $this->getRepository())); } } } } namespace Sismo { class SSHProject extends Project { public function setRepository($url) { $this->repository = $url; } } } namespace Sismo { use Sismo\Storage\StorageInterface; class Sismo { const VERSION = '0.999999'; const FORCE_BUILD = 1; const LOCAL_BUILD = 2; const SILENT_BUILD = 4; private $storage; private $builder; private $projects = array(); public function __construct(StorageInterface $storage, Builder $builder) { $this->storage = $storage; $this->builder = $builder; } public function build(Project $project, $revision = null, $flags = 0, $callback = null) { if ($project->isBuilding() && Sismo::FORCE_BUILD !== ($flags & Sismo::FORCE_BUILD)) { return; } $this->builder->init($project, $callback); list($sha, $author, $date, $message) = $this->builder->prepare($revision, Sismo::LOCAL_BUILD !== ($flags & Sismo::LOCAL_BUILD)); $commit = $this->storage->getCommit($project, $sha); if ($commit && $commit->isBuilt() && Sismo::FORCE_BUILD !== ($flags & Sismo::FORCE_BUILD)) { return; } $commit = $this->storage->initCommit($project, $sha, $author, \DateTime::createFromFormat('Y-m-d H:i:s O', $date), $message); $process = $this->builder->build(); if (!$process->isSuccessful()) { $commit->setStatusCode('failed'); $commit->setOutput(sprintf("\033[31mBuild failed\033[0m\n\n\033[33mOutput\033[0m\n%s\n\n\033[33m Error\033[0m%s", $process->getOutput(), $process->getErrorOutput())); } else { $commit->setStatusCode('success'); $commit->setOutput($process->getOutput()); } $this->storage->updateCommit($commit); if (Sismo::SILENT_BUILD !== ($flags & Sismo::SILENT_BUILD)) { foreach ($project->getNotifiers() as $notifier) { $notifier->notify($commit); } } } public function hasProject($slug) { return isset($this->projects[$slug]); } public function getProject($slug) { if (!isset($this->projects[$slug])) { throw new \InvalidArgumentException(sprintf('Project "%s" does not exist.', $slug)); } return $this->projects[$slug]; } public function addProject(Project $project) { $this->storage->updateProject($project); $this->projects[$project->getSlug()] = $project; } public function getProjects() { return $this->projects; } } } namespace Sismo\Storage { use Sismo\Project; use Sismo\Commit; interface StorageInterface { public function getCommit(Project $project, $sha); public function initCommit(Project $project, $sha, $author, \DateTime $date, $message); public function updateProject(Project $project); public function updateCommit(Commit $commit); public function close(); } } namespace Sismo\Storage { use Sismo\Project; use Sismo\Commit; class Storage implements StorageInterface { private $db; public function __construct(\SQLite3 $db) { $this->db = $db; } public function getCommit(Project $project, $sha) { $stmt = $this->db->prepare('SELECT slug, sha, author, date, build_date, message, status, output FROM `commit` WHERE slug = :slug AND sha = :sha'); $stmt->bindValue(':slug', $project->getSlug(), SQLITE3_TEXT); $stmt->bindValue(':sha', $sha, SQLITE3_TEXT); if (false !== $result = $stmt->execute()) { if (false !== $result = $result->fetchArray(\SQLITE3_ASSOC)) { return $this->createCommit($project, $result); } } return false; } public function initCommit(Project $project, $sha, $author, \DateTime $date, $message) { $stmt = $this->db->prepare('INSERT OR REPLACE INTO `commit` (slug, sha, author, date, message, status, output, build_date) VALUES (:slug, :sha, :author, :date, :message, :status, :output, :build_date)'); $stmt->bindValue(':slug', $project->getSlug(), SQLITE3_TEXT); $stmt->bindValue(':sha', $sha, SQLITE3_TEXT); $stmt->bindValue(':author', $author, SQLITE3_TEXT); $stmt->bindValue(':date', $date->format('Y-m-d H:i:s'), SQLITE3_TEXT); $stmt->bindValue(':message', $message, SQLITE3_TEXT); $stmt->bindValue(':status', 'building', SQLITE3_TEXT); $stmt->bindValue(':output', '', SQLITE3_TEXT); $stmt->bindValue(':build_date', '', SQLITE3_TEXT); if (false === $result = $stmt->execute()) { throw new \RuntimeException(sprintf('Unable to save commit "%s" from project "%s".', $sha, $project->getName())); } $commit = new Commit($project, $sha); $commit->setAuthor($author); $commit->setMessage($message); $commit->setDate($date); return $commit; } public function updateProject(Project $project) { $stmt = $this->db->prepare('INSERT OR REPLACE INTO project (slug, name, repository, branch, command, url_pattern) VALUES (:slug, :name, :repository, :branch, :command, :url_pattern)'); $stmt->bindValue(':slug', $project->getSlug(), SQLITE3_TEXT); $stmt->bindValue(':name', $project->getName(), SQLITE3_TEXT); $stmt->bindValue(':repository', $project->getRepository(), SQLITE3_TEXT); $stmt->bindValue(':branch', $project->getBranch(), SQLITE3_TEXT); $stmt->bindValue(':command', $project->getCommand(), SQLITE3_TEXT); $stmt->bindValue(':url_pattern', $project->getUrlPattern(), SQLITE3_TEXT); if (false === $stmt->execute()) { throw new \RuntimeException(sprintf('Unable to save project "%s".', $project->getName())); } $stmt = $this->db->prepare('SELECT sha, author, date, build_date, message, status, output FROM `commit` WHERE slug = :slug ORDER BY build_date DESC LIMIT 100'); $stmt->bindValue(':slug', $project->getSlug(), SQLITE3_TEXT); if (false === $results = $stmt->execute()) { throw new \RuntimeException(sprintf('Unable to get latest commit for project "%s".', $project->getName())); } $commits = array(); while ($result = $results->fetchArray(\SQLITE3_ASSOC)) { $commits[] = $this->createCommit($project, $result); } $project->setCommits($commits); $stmt = $this->db->prepare('SELECT COUNT(*) AS count FROM `commit` WHERE slug = :slug AND status = "building"'); $stmt->bindValue(':slug', $project->getSlug(), SQLITE3_TEXT); $building = false; if (false !== $result = $stmt->execute()) { if (false !== $result = $result->fetchArray(\SQLITE3_ASSOC)) { if ($result['count'] > 0) { $building = true; } } } $project->setBuilding($building); } public function updateCommit(Commit $commit) { $stmt = $this->db->prepare('UPDATE `commit` SET status = :status, output = :output, build_date = CURRENT_TIMESTAMP WHERE slug = :slug AND sha = :sha'); $stmt->bindValue(':slug', $commit->getProject()->getSlug(), SQLITE3_TEXT); $stmt->bindValue(':sha', $commit->getSha(), SQLITE3_TEXT); $stmt->bindValue(':status', $commit->getStatusCode(), SQLITE3_TEXT); $stmt->bindValue(':output', $commit->getOutput(), SQLITE3_TEXT); if (false === $stmt->execute()) { throw new \RuntimeException(sprintf('Unable to save build "%s@%s".', $commit->getProject()->getName(), $commit->getSha())); } } private function createCommit($project, $result) { $commit = new Commit($project, $result['sha']); $commit->setAuthor($result['author']); $commit->setMessage($result['message']); $commit->setDate(\DateTime::createFromFormat('Y-m-d H:i:s', $result['date'])); if ($result['build_date']) { $commit->setBuildDate(\DateTime::createFromFormat('Y-m-d H:i:s', $result['build_date'])); } $commit->setStatusCode($result['status']); $commit->setOutput($result['output']); return $commit; } public function close() { $this->db->close(); } public function __destruct() { $this->close(); } } } namespace { use Silex\Application; use Silex\Provider\TwigServiceProvider; use Silex\Provider\UrlGeneratorServiceProvider; use Sismo\Sismo; use Sismo\Project; use Sismo\Storage\Storage; use Sismo\Builder; use Symfony\Component\Process\Process; use Symfony\Component\HttpFoundation\Response; $app = new Application(); $app->register(new UrlGeneratorServiceProvider()); $app->register(new TwigServiceProvider(), array( 'twig.path' => __DIR__.'/templates', )); $app['twig'] = $app->share($app->extend('twig', function($twig, $app) { $twig->setCache($app['twig.cache.path']); return $twig; })); $app['data.path'] = getenv('SISMO_DATA_PATH') ?: getenv('HOME').'/.sismo/data'; $app['config.file'] = getenv('SISMO_CONFIG_PATH') ?: getenv('HOME').'/.sismo/config.php'; $app['config.storage.file'] = getenv('SISMO_STORAGE_PATH') ?: getenv('HOME').'/.sismo/storage.php'; $app['build.path'] = $app->share(function ($app) { return $app['data.path'].'/build'; }); $app['db.path'] = $app->share(function ($app) { if (!is_dir($app['data.path'])) { mkdir($app['data.path'], 0777, true); } return $app['data.path'].'/sismo.db'; }); $app['twig.cache.path'] = $app->share(function ($app) { return $app['data.path'].'/cache'; }); $app['git.path'] = getenv('SISMO_GIT_PATH') ?: 'git'; $app['git.cmds'] = array(); $app['db.schema'] = <<<EOF
CREATE TABLE IF NOT EXISTS project (
    slug        TEXT,
    name        TEXT,
    repository  TEXT,
    branch      TEXT,
    command     BLOB,
    url_pattern TEXT,
    PRIMARY KEY (slug)
);

CREATE TABLE IF NOT EXISTS `commit` (
    slug          TEXT,
    sha           TEXT,
    date          TEXT,
    message       BLOB,
    author        TEXT,
    status        TEXT,
    output        BLOB,
    build_date    TEXT DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (slug, sha),
    CONSTRAINT slug FOREIGN KEY (slug) REFERENCES project(slug) ON DELETE CASCADE
);
EOF;
$app['db'] = $app->share(function () use ($app) { $db = new \SQLite3($app['db.path']); $db->busyTimeout(1000); $db->exec($app['db.schema']); return $db; }); $app['storage'] = $app->share(function () use ($app) { if (is_file($app['config.storage.file'])) { $storage = require $app['config.storage.file']; } else { $storage = new Storage($app['db']); } return $storage; }); $app['builder'] = $app->share(function () use ($app) { $process = new Process(sprintf('%s --version', $app['git.path'])); if ($process->run() > 0) { throw new \RuntimeException(sprintf('The git binary cannot be found (%s).', $app['git.path'])); } return new Builder($app['build.path'], $app['git.path'], $app['git.cmds']); }); $app['sismo'] = $app->share(function () use ($app) { $sismo = new Sismo($app['storage'], $app['builder']); if (!is_file($app['config.file'])) { throw new \RuntimeException(sprintf("Looks like you forgot to define your projects.\nSismo looked into \"%s\".", $app['config.file'])); } $projects = require $app['config.file']; if (null === $projects) { throw new \RuntimeException(sprintf('The "%s" configuration file must return an array of Projects (returns null).', $app['config.file'])); } if (!is_array($projects)) { throw new \RuntimeException(sprintf('The "%s" configuration file must return an array of Projects (returns a non-array).', $app['config.file'])); } foreach ($projects as $project) { if (!$project instanceof Project) { throw new \RuntimeException(sprintf('The "%s" configuration file must return an array of Project instances.', $app['config.file'])); } $sismo->addProject($project); } return $sismo; }); $app->error(function (\Exception $e, $code) use ($app) { if ($app['debug']) { return; } $error = 404 == $code ? $e->getMessage() : null; return new Response($app['twig']->render('error.twig', array('error' => $error)), $code); }); }namespace { class FakeTwigLoader implements Twig_LoaderInterface { public function getSource($name) {} public function getCacheKey($name) { static $templates = array( 'ccmonitor.twig.xml' => '/Users/fabien/work/sismo/src/templates/ccmonitor.twig.xml', 'error.twig' => '/Users/fabien/work/sismo/src/templates/error.twig', 'layout.twig' => '/Users/fabien/work/sismo/src/templates/layout.twig', 'project.twig' => '/Users/fabien/work/sismo/src/templates/project.twig', 'projects.twig' => '/Users/fabien/work/sismo/src/templates/projects.twig', ); return $templates[$name]; } public function isFresh($name, $time) { return true; } } $app['twig.loader'] = $app->share(function () { return new FakeTwigLoader(); }); } namespace { class __TwigTemplate_d25a0d1b48c9fbc74b222fb7afbf714b extends Twig_Template { public function __construct(Twig_Environment $env) { parent::__construct($env); $this->parent = false; $this->blocks = array( ); } protected function doDisplay(array $context, array $blocks = array()) { echo "<?xml version=\"1.0\" encoding=\"UTF-8\"?>
<Projects>
"; if (isset($context["projects"])) { $_projects_ = $context["projects"]; } else { $_projects_ = null; } $context['_parent'] = (array) $context; $context['_seq'] = twig_ensure_traversable($_projects_); foreach ($context['_seq'] as $context["_key"] => $context["project"]) { if (isset($context["project"])) { $_project_ = $context["project"]; } else { $_project_ = null; } $context["commit"] = $this->getAttribute($_project_, "getLatestCommit"); echo "<Project
  name=\""; if (isset($context["project"])) { $_project_ = $context["project"]; } else { $_project_ = null; } echo twig_escape_filter($this->env, $_project_, "html", null, true); echo "\"
  category=\"\"
  activity=\""; if (isset($context["project"])) { $_project_ = $context["project"]; } else { $_project_ = null; } echo twig_escape_filter($this->env, $this->getAttribute($_project_, "ccactivity"), "html", null, true); echo "\"
  lastBuildStatus=\""; if (isset($context["project"])) { $_project_ = $context["project"]; } else { $_project_ = null; } echo twig_escape_filter($this->env, $this->getAttribute($_project_, "ccstatus"), "html", null, true); echo "\"
  lastBuildLabel=\"build."; if (isset($context["commit"])) { $_commit_ = $context["commit"]; } else { $_commit_ = null; } echo twig_escape_filter($this->env, ((($_commit_ && $this->getAttribute($_commit_, "built"))) ? ($this->getAttribute($_commit_, "sha")) : ("Unknown")), "html", null, true); echo "\"
  lastBuildTime=\""; if (isset($context["commit"])) { $_commit_ = $context["commit"]; } else { $_commit_ = null; } echo twig_escape_filter($this->env, ((($_commit_ && $this->getAttribute($_commit_, "built"))) ? ($this->getAttribute($this->getAttribute($_commit_, "builddate"), "format", array(0 => constant("DATE_ATOM")), "method")) : ("1970-01-01T00:00:00.000000-00:00")), "html", null, true); echo "\"
  webUrl=\""; if (isset($context["project"])) { $_project_ = $context["project"]; } else { $_project_ = null; } echo twig_escape_filter($this->env, $this->env->getExtension('routing')->getUrl("project", array("slug" => $this->getAttribute($_project_, "slug"))), "html", null, true); echo "\"
/>
"; } $_parent = $context['_parent']; unset($context['_seq'], $context['_iterated'], $context['_key'], $context['project'], $context['_parent'], $context['loop']); $context = array_merge($_parent, array_intersect_key($context, $_parent)); echo "</Projects>
"; } public function getTemplateName() { return "ccmonitor.twig.xml"; } public function isTraitable() { return false; } public function getDebugInfo() { return array ( 68 => 15, 58 => 12, 53 => 11, 48 => 10, 43 => 9, 38 => 8, 32 => 6, 29 => 5, 26 => 4, 21 => 3, 17 => 1,); } } class __TwigTemplate_b7c8e42116d1671f36c77dc341da618b extends Twig_Template { public function __construct(Twig_Environment $env) { parent::__construct($env); $this->parent = $this->env->loadTemplate("layout.twig"); $this->blocks = array( 'title' => array($this, 'block_title'), 'content' => array($this, 'block_content'), ); } protected function doGetParent(array $context) { return "layout.twig"; } protected function doDisplay(array $context, array $blocks = array()) { $this->parent->display($context, array_merge($this->blocks, $blocks)); } public function block_title($context, array $blocks = array()) { echo "Error"; } public function block_content($context, array $blocks = array()) { echo "    <h1>Hmmm, looks like something went wrong</h1>

    <p id=\"error\">"; if (isset($context["error"])) { $_error_ = $context["error"]; } else { $_error_ = null; } echo (($_error_) ? (strtr($_error_, array("
" => "<br />"))) : ("An error occurred")); echo "</p>
"; } public function getTemplateName() { return "error.twig"; } public function isTraitable() { return false; } public function getDebugInfo() { return array ( 40 => 8, 36 => 6, 33 => 5, 27 => 3, 68 => 15, 58 => 12, 53 => 11, 48 => 10, 43 => 9, 38 => 8, 32 => 6, 29 => 5, 26 => 4, 21 => 3, 17 => 1,); } } class __TwigTemplate_e35345c659e394c05c52df3b99d49b83 extends Twig_Template { public function __construct(Twig_Environment $env) { parent::__construct($env); $this->parent = false; $this->blocks = array( 'title' => array($this, 'block_title'), 'content' => array($this, 'block_content'), ); } protected function doDisplay(array $context, array $blocks = array()) { echo "<!DOCTYPE html>
<html>
    <head>
        <meta charset=\"utf-8\" />
        <title>"; $this->displayBlock('title', $context, $blocks); echo " | Sismo</title>
        <link href=\""; if (isset($context["app"])) { $_app_ = $context["app"]; } else { $_app_ = null; } echo twig_escape_filter($this->env, $this->getAttribute($this->getAttribute($_app_, "request"), "baseurl"), "html", null, true); echo "/css/sismo.css\" rel=\"stylesheet\" />
    </head>
    <body>
        <div id=\"content\">
            "; $this->displayBlock('content', $context, $blocks); echo "        </div>
        <footer>
            <span>Powered by <strong><a href=\"http://sismo.sensiolabs.org/\">Sismo</a></strong> "; echo twig_escape_filter($this->env, constant("Sismo\\Sismo::VERSION"), "html", null, true); echo ", your Personal Continuous Testing Server</span>
            <a href=\"http://www.sensiolabs.com/\"><img class=\"png_fix\" src=\""; if (isset($context["app"])) { $_app_ = $context["app"]; } else { $_app_ = null; } echo twig_escape_filter($this->env, $this->getAttribute($this->getAttribute($_app_, "request"), "baseurl"), "html", null, true); echo "/images/sensio-labs-product.png\" alt=\"a Sensio Labs product\" /></a>
        </footer>
    </body>
</html>
"; } public function block_title($context, array $blocks = array()) { echo ""; } public function block_content($context, array $blocks = array()) { echo ""; } public function getTemplateName() { return "layout.twig"; } public function isTraitable() { return false; } public function getDebugInfo() { return array ( 63 => 10, 57 => 5, 47 => 14, 39 => 11, 37 => 10, 25 => 5, 19 => 1, 40 => 8, 36 => 6, 33 => 5, 27 => 3, 68 => 15, 58 => 12, 53 => 11, 48 => 10, 43 => 13, 38 => 8, 32 => 6, 29 => 6, 26 => 4, 21 => 3, 17 => 1,); } } class __TwigTemplate_199979d6ab3501182b0468d4cfb6b0f2 extends Twig_Template { public function __construct(Twig_Environment $env) { parent::__construct($env); $this->parent = $this->env->loadTemplate("layout.twig"); $this->blocks = array( 'title' => array($this, 'block_title'), 'content' => array($this, 'block_content'), ); } protected function doGetParent(array $context) { return "layout.twig"; } protected function doDisplay(array $context, array $blocks = array()) { $context["__internal_26d3a54278191eeff5d7740bd348051b8c8b5d50"] = $this; $this->parent->display($context, array_merge($this->blocks, $blocks)); } public function block_title($context, array $blocks = array()) { if (isset($context["project"])) { $_project_ = $context["project"]; } else { $_project_ = null; } echo twig_escape_filter($this->env, ("Project " . $_project_), "html", null, true); } public function block_content($context, array $blocks = array()) { echo "    <div id=\"back\"><a href=\""; echo twig_escape_filter($this->env, $this->env->getExtension('routing')->getPath("projects"), "html", null, true); echo "\">&laquo; Projects</a></div>

    <h1>
        <a href=\""; if (isset($context["project"])) { $_project_ = $context["project"]; } else { $_project_ = null; } echo twig_escape_filter($this->env, $this->env->getExtension('routing')->getPath("project", array("slug" => $this->getAttribute($_project_, "slug"))), "html", null, true); echo "\">
            "; if (isset($context["project"])) { $_project_ = $context["project"]; } else { $_project_ = null; } echo twig_escape_filter($this->env, $this->getAttribute($_project_, "shortname"), "html", null, true); echo "
            "; if (isset($context["project"])) { $_project_ = $context["project"]; } else { $_project_ = null; } if ($this->getAttribute($_project_, "subname")) { echo "<small> &mdash; "; if (isset($context["project"])) { $_project_ = $context["project"]; } else { $_project_ = null; } echo twig_escape_filter($this->env, $this->getAttribute($_project_, "subname"), "html", null, true); echo "</small>"; } echo "        </a>
    </h1>

    "; if (isset($context["commit"])) { $_commit_ = $context["commit"]; } else { $_commit_ = null; } if ((!$_commit_)) { echo "        <p id=\"error\">Never built yet.</p>
    "; } else { echo "        <div class=\"clearfix "; if (isset($context["commit"])) { $_commit_ = $context["commit"]; } else { $_commit_ = null; } echo twig_escape_filter($this->env, $this->getAttribute($_commit_, "statuscode"), "html", null, true); echo "\" id=\"build\">"; if (isset($context["commit"])) { $_commit_ = $context["commit"]; } else { $_commit_ = null; } echo $context["__internal_26d3a54278191eeff5d7740bd348051b8c8b5d50"]->getcommit_block($_commit_); echo "</div>

        "; if (isset($context["commit"])) { $_commit_ = $context["commit"]; } else { $_commit_ = null; } if ($this->getAttribute($_commit_, "isbuilt")) { echo "            <div id=\"output\">
                <pre>"; if (isset($context["commit"])) { $_commit_ = $context["commit"]; } else { $_commit_ = null; } echo (($this->getAttribute($_commit_, "output")) ? ($this->getAttribute($_commit_, "decoratedoutput")) : ("No output")); echo "</pre>
            </div>
        "; } echo "
        "; if (isset($context["commits"])) { $_commits_ = $context["commits"]; } else { $_commits_ = null; } if ((array_key_exists("commits", $context) && $_commits_)) { echo "            <h1>Builds History</h1>
            <ul id=\"builds\">
                "; if (isset($context["commits"])) { $_commits_ = $context["commits"]; } else { $_commits_ = null; } $context['_parent'] = (array) $context; $context['_seq'] = twig_ensure_traversable($_commits_); foreach ($context['_seq'] as $context["_key"] => $context["commit"]) { echo "                    <li class=\""; if (isset($context["commit"])) { $_commit_ = $context["commit"]; } else { $_commit_ = null; } echo twig_escape_filter($this->env, $this->getAttribute($_commit_, "statuscode"), "html", null, true); echo "\">"; if (isset($context["commit"])) { $_commit_ = $context["commit"]; } else { $_commit_ = null; } echo $context["__internal_26d3a54278191eeff5d7740bd348051b8c8b5d50"]->getcommit_block($_commit_); echo "</li>
                "; } $_parent = $context['_parent']; unset($context['_seq'], $context['_iterated'], $context['_key'], $context['commit'], $context['_parent'], $context['loop']); $context = array_merge($_parent, array_intersect_key($context, $_parent)); echo "            </ul>
        "; } echo "    "; } } public function getcommit_block($commit = null) { $context = $this->env->mergeGlobals(array( "commit" => $commit, )); $blocks = array(); ob_start(); try { echo "    <div class=\"commit\">"; if (isset($context["commit"])) { $_commit_ = $context["commit"]; } else { $_commit_ = null; } echo $this->getAttribute($this, "commit_link", array(0 => $_commit_), "method"); echo "</div>
    <h2>
        "; if (isset($context["commit"])) { $_commit_ = $context["commit"]; } else { $_commit_ = null; } echo twig_escape_filter($this->env, $this->getAttribute($_commit_, "message"), "html", null, true); echo "
        <span class=\"permalink\"><a href=\""; if (isset($context["commit"])) { $_commit_ = $context["commit"]; } else { $_commit_ = null; } echo twig_escape_filter($this->env, $this->env->getExtension('routing')->getPath("commit", array("slug" => $this->getAttribute($this->getAttribute($_commit_, "project"), "slug"), "sha" => $this->getAttribute($_commit_, "sha"))), "html", null, true); echo "\">¶</a></span>
    </h2>
    <div class=\"meta\">
        by <em>"; if (isset($context["commit"])) { $_commit_ = $context["commit"]; } else { $_commit_ = null; } echo twig_escape_filter($this->env, $this->getAttribute($_commit_, "author"), "html", null, true); echo "</em> on <em>"; if (isset($context["commit"])) { $_commit_ = $context["commit"]; } else { $_commit_ = null; } echo twig_escape_filter($this->env, twig_date_format_filter($this->env, $this->getAttribute($_commit_, "date"), "j M Y H:i"), "html", null, true); echo "</em>
    </div>
"; } catch(Exception $e) { ob_end_clean(); throw $e; } return ob_get_clean(); } public function getcommit_link($commit = null) { $context = $this->env->mergeGlobals(array( "commit" => $commit, )); $blocks = array(); ob_start(); try { echo "    "; if (isset($context["commit"])) { $_commit_ = $context["commit"]; } else { $_commit_ = null; } if ((!$this->getAttribute($this->getAttribute($_commit_, "project"), "urlpattern"))) { echo "        #"; if (isset($context["commit"])) { $_commit_ = $context["commit"]; } else { $_commit_ = null; } echo twig_escape_filter($this->env, $this->getAttribute($_commit_, "shortsha"), "html", null, true); echo " "; if (isset($context["commit"])) { $_commit_ = $context["commit"]; } else { $_commit_ = null; } echo twig_escape_filter($this->env, $this->getAttribute($_commit_, "status"), "html", null, true); echo "
    "; } else { echo "        #<a href=\""; if (isset($context["commit"])) { $_commit_ = $context["commit"]; } else { $_commit_ = null; } echo twig_escape_filter($this->env, strtr($this->getAttribute($this->getAttribute($_commit_, "project"), "urlpattern"), array("%commit%" => $this->getAttribute($_commit_, "sha"))), "html", null, true); echo "\">"; if (isset($context["commit"])) { $_commit_ = $context["commit"]; } else { $_commit_ = null; } echo twig_escape_filter($this->env, $this->getAttribute($_commit_, "shortsha"), "html", null, true); echo "</a> "; if (isset($context["commit"])) { $_commit_ = $context["commit"]; } else { $_commit_ = null; } echo twig_escape_filter($this->env, $this->getAttribute($_commit_, "status"), "html", null, true); echo "
    "; } } catch(Exception $e) { ob_end_clean(); throw $e; } return ob_get_clean(); } public function getTemplateName() { return "project.twig"; } public function isTraitable() { return false; } public function getDebugInfo() { return array ( 209 => 54, 199 => 52, 195 => 51, 184 => 50, 166 => 46, 159 => 43, 154 => 42, 147 => 40, 136 => 39, 131 => 36, 127 => 34, 114 => 32, 109 => 31, 105 => 29, 102 => 28, 99 => 27, 92 => 24, 89 => 23, 86 => 22, 76 => 20, 72 => 18, 69 => 17, 64 => 14, 56 => 13, 51 => 12, 46 => 11, 24 => 3, 63 => 10, 57 => 5, 47 => 14, 39 => 8, 37 => 10, 25 => 5, 19 => 1, 40 => 8, 36 => 7, 33 => 5, 27 => 3, 68 => 15, 58 => 12, 53 => 11, 48 => 10, 43 => 13, 38 => 8, 32 => 6, 29 => 5, 26 => 4, 21 => 3, 17 => 1,); } } class __TwigTemplate_14b76e673d41324f6d5061a589b59b2f extends Twig_Template { public function __construct(Twig_Environment $env) { parent::__construct($env); $this->parent = $this->env->loadTemplate("layout.twig"); $this->blocks = array( 'title' => array($this, 'block_title'), 'content' => array($this, 'block_content'), ); } protected function doGetParent(array $context) { return "layout.twig"; } protected function doDisplay(array $context, array $blocks = array()) { $this->parent->display($context, array_merge($this->blocks, $blocks)); } public function block_title($context, array $blocks = array()) { echo "Projects"; } public function block_content($context, array $blocks = array()) { echo "    "; if (isset($context["projects"])) { $_projects_ = $context["projects"]; } else { $_projects_ = null; } if ((!$_projects_)) { echo "        <p>No project yet.</p>
    "; } else { echo "        <ul id=\"projects\">
            "; if (isset($context["projects"])) { $_projects_ = $context["projects"]; } else { $_projects_ = null; } $context['_parent'] = (array) $context; $context['_seq'] = twig_ensure_traversable($_projects_); foreach ($context['_seq'] as $context["i"] => $context["project"]) { echo "                <li class=\""; if (isset($context["project"])) { $_project_ = $context["project"]; } else { $_project_ = null; } echo twig_escape_filter($this->env, $this->getAttribute($_project_, "statuscode"), "html", null, true); echo "\">
                    <div class=\"status\">"; if (isset($context["project"])) { $_project_ = $context["project"]; } else { $_project_ = null; } echo twig_escape_filter($this->env, $this->getAttribute($_project_, "status"), "html", null, true); echo "</div>
                    <a href=\""; if (isset($context["project"])) { $_project_ = $context["project"]; } else { $_project_ = null; } echo twig_escape_filter($this->env, $this->env->getExtension('routing')->getPath("project", array("slug" => $this->getAttribute($_project_, "slug"))), "html", null, true); echo "\">
                        "; if (isset($context["project"])) { $_project_ = $context["project"]; } else { $_project_ = null; } echo twig_escape_filter($this->env, $this->getAttribute($_project_, "shortname"), "html", null, true); echo "
                        "; if (isset($context["project"])) { $_project_ = $context["project"]; } else { $_project_ = null; } if ($this->getAttribute($_project_, "subname")) { echo "<small> &mdash; "; if (isset($context["project"])) { $_project_ = $context["project"]; } else { $_project_ = null; } echo twig_escape_filter($this->env, $this->getAttribute($_project_, "subname"), "html", null, true); echo "</small>"; } echo "                    </a>
               </li>
            "; } $_parent = $context['_parent']; unset($context['_seq'], $context['_iterated'], $context['i'], $context['project'], $context['_parent'], $context['loop']); $context = array_merge($_parent, array_intersect_key($context, $_parent)); echo "        </ul>
    "; } } public function getTemplateName() { return "projects.twig"; } public function isTraitable() { return false; } public function getDebugInfo() { return array ( 81 => 16, 73 => 15, 52 => 11, 44 => 9, 209 => 54, 199 => 52, 195 => 51, 184 => 50, 166 => 46, 159 => 43, 154 => 42, 147 => 40, 136 => 39, 131 => 36, 127 => 34, 114 => 32, 109 => 31, 105 => 29, 102 => 28, 99 => 27, 92 => 24, 89 => 19, 86 => 22, 76 => 20, 72 => 18, 69 => 17, 64 => 14, 56 => 13, 51 => 12, 46 => 11, 24 => 3, 63 => 13, 57 => 5, 47 => 10, 39 => 8, 37 => 10, 25 => 5, 19 => 1, 40 => 7, 36 => 6, 33 => 5, 27 => 3, 68 => 14, 58 => 12, 53 => 11, 48 => 10, 43 => 13, 38 => 8, 32 => 6, 29 => 5, 26 => 4, 21 => 3, 17 => 1,); } } } namespace { use Sismo\Sismo; use Sismo\BuildException; use Symfony\Component\Console\Application; use Symfony\Component\Console\Input\InputInterface; use Symfony\Component\Console\Input\InputArgument; use Symfony\Component\Console\Input\InputOption; use Symfony\Component\Console\Output\OutputInterface; $console = new Application('Sismo', Sismo::VERSION); $console ->register('output') ->setDefinition(array( new InputArgument('slug', InputArgument::REQUIRED, 'Project slug'), )) ->setDescription('Displays the latest output for a project') ->setHelp(<<<EOF
The <info>%command.name%</info> command displays the latest output for a project:

    <info>php %command.full_name% twig</info>
EOF
) ->setCode(function (InputInterface $input, OutputInterface $output) use ($app) { $sismo = $app['sismo']; $slug = $input->getArgument('slug'); if (!$sismo->hasProject($slug)) { $output->writeln(sprintf('<error>Project "%s" does not exist.</error>', $slug)); return 1; } $project = $sismo->getProject($slug); if (!$project->getLatestCommit()) { $output->writeln(sprintf('<error>Project "%s" has never been built yet.</error>', $slug)); return 2; } $output->write($project->getLatestCommit()->getOutput()); $now = new \DateTime(); $diff = $now->diff($project->getLatestCommit()->getBuildDate()); if ($m = $diff->format('%i')) { $time = $m.' minutes'; } else { $time = $diff->format('%s').' seconds'; } $output->writeln(''); $output->writeln(sprintf('<info>This output was generated by Sismo %s ago</info>', $time)); }) ; $console ->register('build') ->setDefinition(array( new InputArgument('slug', InputArgument::OPTIONAL, 'Project slug'), new InputArgument('sha', InputArgument::OPTIONAL, 'Commit sha'), new InputOption('force', '', InputOption::VALUE_NONE, 'Force the build'), new InputOption('local', '', InputOption::VALUE_NONE, 'Disable remote sync'), new InputOption('silent', '', InputOption::VALUE_NONE, 'Disable notifications'), new InputOption('timeout', '', InputOption::VALUE_REQUIRED, 'Time limit'), new InputOption('data-path', '', InputOption::VALUE_REQUIRED, 'The data path'), new InputOption('config-file', '', InputOption::VALUE_REQUIRED, 'The config file'), )) ->setDescription('Build projects') ->setHelp(<<<EOF
Without any arguments, the <info>%command.name%</info> command builds the latest commit
of all configured projects one after the other:

    <info>php %command.full_name%</info>

The command loads project configurations from
<comment>~/.sismo/config.php</comment>. Change it with the
<info>--config-file</info> option:

    <info>php %command.full_name% --config-file=/path/to/config.php</info>

Data (repository, DB, ...) are stored in <comment>~/.sismo/data/</comment>.
The <info>--data-path</info> option allows you to change the default:

    <info>php %command.full_name% --data-path=/path/to/data</info>

Pass the project slug to build a specific project:

    <info>php %command.full_name% twig</info>

Force a specific commit to be built by passing the SHA:

    <info>php %command.full_name% twig a1ef34</info>

Use <comment>--force</comment> to force the built even if it has already been
built previously:

    <info>php %command.full_name% twig a1ef34 --force</info>

Disable notifications with <comment>--silent</comment>:

    <info>php %command.full_name% twig a1ef34 --silent</info>

Disable repository synchonization with <comment>--local</comment>:

    <info>php %command.full_name% twig a1ef34 --local</info>

Limit the time (in seconds) spent by the command building projects by using
the <comment>--timeout</comment> option:

    <info>php %command.full_name% twig --timeout 3600</info>

When you use this command as a cron job, <comment>--timeout</comment> can avoid
the command to be run concurrently. Be warned that this is a rough estimate as
the time is only checked between two builds. When a build is started, it won't
be stopped if the time limit is over.

Use the <comment>--verbose</comment> option to debug builds in case of a
problem.
EOF
) ->setCode(function (InputInterface $input, OutputInterface $output) use ($app) { if ($input->getOption('data-path')) { $app['data.path'] = $input->getOption('data-path'); } if ($input->getOption('config-file')) { $app['config.file'] = $input->getOption('config-file'); } $sismo = $app['sismo']; if ($slug = $input->getArgument('slug')) { if (!$sismo->hasProject($slug)) { $output->writeln(sprintf('<error>Project "%s" does not exist.</error>', $slug)); return 1; } $projects = array($sismo->getProject($slug)); } else { $projects = $sismo->getProjects(); } $start = time(); $startedOut = false; $startedErr = false; $callback = null; if (OutputInterface::VERBOSITY_VERBOSE === $output->getVerbosity()) { $callback = function ($type, $buffer) use ($output, &$startedOut, &$startedErr) { if ('err' === $type) { if (!$startedErr) { $output->write("\n<bg=red;fg=white> ERR </> "); $startedErr = true; $startedOut = false; } $output->write(str_replace("\n", "\n<bg=red;fg=white> ERR </> ", $buffer)); } else { if (!$startedOut) { $output->write("\n<bg=green;fg=white> OUT </> "); $startedOut = true; $startedErr = false; } $output->write(str_replace("\n", "\n<bg=green;fg=white> OUT </> ", $buffer)); } }; } $flags = 0; if ($input->getOption('force')) { $flags = $flags | Sismo::FORCE_BUILD; } if ($input->getOption('local')) { $flags = $flags | Sismo::LOCAL_BUILD; } if ($input->getOption('silent')) { $flags = $flags | Sismo::SILENT_BUILD; } foreach ($projects as $project) { if ($input->getOption('timeout') && time() - $start > $input->getOption('timeout')) { break; } try { $output->writeln(sprintf('<info>Building Project "%s" (into "%s")</info>', $project, $app['builder']->getBuildDir($project))); $sismo->build($project, $input->getArgument('sha'), $flags, $callback); $output->writeln(''); } catch (BuildException $e) { $output->writeln("\n".sprintf('<error>%s</error>', $e->getMessage())); return 1; } } }) ; } namespace { use Symfony\Component\HttpFoundation\Response; $app->get('/css/sismo.css', function() { return new Response('/*
Copyright (c) 2009, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.net/yui/license.txt
version: 2.7.0
*/
html{color:#000;background:#FFF;}body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,button,textarea,p,blockquote,th,td{margin:0;padding:0;}table{border-collapse:collapse;border-spacing:0;}fieldset,img{border:0;}address,caption,cite,code,dfn,em,strong,th,var,optgroup{font-style:inherit;font-weight:inherit;}del,ins{text-decoration:none;}li{list-style:none;}caption,th{text-align:left;}h1,h2,h3,h4,h5,h6{font-size:100%;font-weight:normal;}q:before,q:after{content:\'\';}abbr,acronym{border:0;font-variant:normal;}sup{vertical-align:baseline;}sub{vertical-align:baseline;}legend{color:#000;}input,button,textarea,select,optgroup,option{font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;}input,button,textarea,select{*font-size:100%;}

/* Sismo CSS */
html {
    background-color: #182d33;
}

body {
    font-family: Georgia, serif;
    color: #fff;
    font-size: 16px;
}

em {
    font-style: italic;
}

strong {
    font-weight: bold;
}

h1 {
    font-size: 30px;
    margin-top: 30px;
    margin-bottom: 10px;
}

h1 a {
    color: #fff;
}

h2 {
    font-size: 26px;
}

#builds h2 {
    font-size: 21px;
}

#content, footer {
    width: 780px;
    margin: 0 auto;
    background: #274751;
    padding: 15px 24px;
}

#content {
    padding-top: 160px;
    background: #274751 url(../images/header.png) no-repeat right top;
}

a {
    text-decoration: none;
}

a:hover {
    text-decoration: underline;
}

.success {
    background: url(../images/success.png) repeat-y !important;
}

.failed {
  background: url(../images/failed.png) repeat-y !important;
}

.success a, .failed a {
    color: #fff !important;
}

#projects {
    margin: 15px 0;
    margin-top: 30px;
}

#projects li {
    position: relative;
    padding: 12px;
    margin-bottom: 5px;
    font-size: 30px;
    vertical-align: bottom;
    border: 3px solid #ccc;
}

#projects li a {
    color: #555;
}

#build {
    padding: 10px 15px;
    margin-bottom: 15px;
    border: 3px solid #ccc;
    background: url(../images/nobuild.png) repeat-y;
}

#build a {
    color: #555;
}

#output {
    margin-bottom: 15px;
}

#output pre {
    background: #111;
    color: #fff;
    padding: 8px;
    overflow: auto;
    max-height: 300px;
    width: 764px;
    font-size: 14px;
}

.meta {
    font-size: 13px;
    font-family: Georgia, serif;
}

#builds li {
    padding: 8px 12px;
    margin-bottom: 5px;
    border: 3px solid #ccc;
    background: url(../images/nobuild.png) repeat-y;
}

#builds li a {
    color: #fff;
}

#builds .meta {
    font-size: 14px;
}

.commit {
    float: right;
    padding-left: 15px;
    padding-bottom: 15px;
    color: #333 !important;
}

.commit a {
    color: #333 !important;
}

.status {
    float: right;
    padding-left: 15px;
    padding-bottom: 15px;
    color: #333 !important;
    font-size: 15px;
}

footer {
    text-align: center;
    font-size: 12px;
    font-family: Arial;
    background: #274751 url(../images/hr.png) no-repeat;
    display: block;
}

footer span {
    margin-right: 40px;
}

footer img {
    margin: 0 4px;
    vertical-align: middle;
}

footer a {
    color: #fff;
}

.clearfix:after { content: "\0020"; display: block; height: 0; clear: both; visibility: hidden; overflow: hidden; }
.clearfix { display: inline-block; }
* html .clearfix { height: 1%; }
.clearfix { display: block; }

#project_command_test {
    width: 100%;
    height: 150px;
}

.permalink {
    font-size: 60%;
}

.permalink a {
    color: #eee !important;
}

#back {
    float: right;
}

#back a {
    color: #ddd;
}

#error {
    margin-top: 30px;
    margin-bottom: 30px;
    position: relative;
    padding: 12px;
    font-size: 22px;
    vertical-align: bottom;
    border: 3px solid #ccc;
}

.ansi_color_fg_black   { color: black; }
.ansi_color_fg_red     { color: red; }
.ansi_color_fg_green   { color: green; }
.ansi_color_fg_yellow  { color: yellow; }
.ansi_color_fg_blue    { color: blue; }
.ansi_color_fg_magenta {  color: magenta; }
.ansi_color_fg_cyan    { color: cyan; }
.ansi_color_fg_white   { color: white; }
.ansi_color_bg_black   { background-color: black; padding: 2px 0; }
.ansi_color_bg_red     { background-color: red; padding: 2px 0; }
.ansi_color_bg_green   { background-color: green; padding: 2px 0; }
.ansi_color_bg_yellow  { background-color: yellow; padding: 2px 0; }
.ansi_color_bg_blue    { background-color: blue; padding: 2px 0; }
.ansi_color_bg_magenta { background-color: magenta; padding: 2px 0; }
.ansi_color_bg_cyan    { background-color: cyan; padding: 2px 0; }
.ansi_color_bg_white   { background-color: white; padding: 2px 0; }
', 200, array('Content-Type' => 'text/css')); });$app->get('/images/failed.png', function() { return new Response(base64_decode('iVBORw0KGgoAAAANSUhEUgAAAwYAAAABCAIAAADrSS6mAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAgVJREFUeNp0VolxwzAMIzRPV+j+ncqsxBdUHOfOifURBEA6+Pv5FRUAur9EIFDV87U/du3xGjzzuSxm1TaL5OIztNZ69LG1WDn32HQ95sjZfrYAj+iSuJ9ZHzxb4L/l49rRD3LHtmNfSGxFppYrAvNI0H+cNOnsoAVOwBlahtnv9mg4bftBHhTF+DjIjgdhdoSgROIh6dQEUCvr3hewjKgacJZ8xCiVWGAriYdMNvmPQMRMgHZETamZIbGjssPI+gnwaafI/jD5KWNgShNeDlSO0hqFJFudckuwQTIVwwaBaYe2LEKuANLDBODE2hNMpmS4eYGN51m/SCzlxFwZLAexSPOtcFeovLBIykFeC6JNcSt4qeyrKV/O1HEucHVAegpVVjIY1mLyi76ax2Q4IiQY9tDZBJQ9mBqVUY2uqyIcZNOuJEzBuOqry5v6Wpo2DOxNpv0Z+nrC9chqc9ZpqtorqfOU3m1ZzG+/YaipKRXpO6tmAtDmmXFSVbJVwP1KR12QbdoqsfsSojNadwii8f3dQc2cEbJA1yFlg+pF1Z2+2fJSNkK8Ifl8yzAPXafdHokf6slxPrWaq+HP/hF1+upwDJayayXJWZ7JR62UbkUkbpmn3aszxH2ffeOqcbnclUBm+uw2UGNHVcd8g1dE6ffOZz2OV4wI3v4rUEWM8i9sWVz/AgwAVqr1ag5GyKIAAAAASUVORK5CYII='), 200, array('Content-Type' => 'image/png')); });$app->get('/images/header.png', function() { return new Response(base64_decode('iVBORw0KGgoAAAANSUhEUgAAAzwAAACUCAMAAABhj9zCAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAwBQTFRFU4yNblBGqFQ1SX2AMFZdPmxxc5yUNV1kKUpUMllgZZyZRnl8mV1FZaGeJ0ZQRXV5VZKTYIJ9aqKdQG1yQXF13EATZWhnSWZp5UwRzT0TeZSKOWRqJUJLh4d5K01WSVNVUEE3hGZWOGJorW9WXGhra4SEUYKCMREHKEVNIz9IIzQzTYCBXZ2cJEBJV5SVrTURd2NcZHdyOGFmKkxVaJ6a6HAHUlVTj083ki0P7IwBAgICanNsSXx/WpmYkH1tPGZqHCsrLFBYLlJadiUOQ1tjM1phR3p9Un9+J0hRNVtibZyWOmZscXFnd4eDRhcJW4SCNl9mL1RcKkxWJ0ZOXFFNUmBaRzQrTYKEToSFKEdQSnN0TSYZdW5iMlheKEhRPGhuWnx6M0xUaGNXLE5XJD9IQ3R4RkpDSn+COV5iPGdsVn58KElSRXR3gY6BO1RcKkpTJkNNoVk+Z46KRHJ1PWZrToaIZV9NLlBYN2FoVI+QPmpvOUlKbTglPmhsPWpvWpiXO2dtJUJKLU9XVE9EMFJaY32AJURNYpqXX3p1XJGPV46NYqGfeF5IFBoZvlUwk2BKJkJLMCEaeXlvTX5/K05XFAcESVFNW5uaXJqZMFRbonhkR3h6PFleS4GDLklKL1NbLklST4iKL1JZMVJTYZWSbJaQUIaHWpuaWoeGSnZ3KUNDXp+eUnR0QnJ3NlFZLVJbP2luSXBuPVJUPWdrKkhQjGJPRG9xDxUUlWpVVXR5QW9zM1tiQ3N2VnBsXnNzgkIrumhLOj45UW5zI0BIN09NMVdfTXp6O2NpKktU6lwNLlFZWJaWmnJbRXd6Hw4JWnd8XR4LVoiIQWpsKUhSJj0+Lk1PNFZZb5+ZW5ybQG90MlZdQGxwhW9XT3Z3KUtULUxUQVBUQmBfJkVPLlFYJkROWHl2T3x9GiEgJkVODBAPJ0VPFCAhJUNNLVFaJ0VOCQoKJ0RNNFxjKUlTMFRcJUFKLE5VKklRPWluJUZPTIOGfGxdvzoTXpubYZ+eKEhSJ0dRx8uhFwAASfpJREFUeNrsnQlcVdXa/y0n1MLKAckyMw3DjIJSwgEVB8jEKVREJZwJE1McLomamnZNe9VAM0HM6lZ2NRPTN6VbVgbaX645NOh7JZVbDimKGpqJ/2dYa+2199kHD2Y36O7n7LP3PvuM+llffs/zrGetVemKY/8x8/7pDs1+KoMVFPC+AO5zcD+nYI40PIOrcC+bGR9xlS+/4yf6tXfIRz+Z/hm2do5NPy/FWrq1Up4SNrzl8Pv+KKvkNOnfnxl1dtQTYua4GLf1MtPhsf1U8NM12B0e2Dl9dw44co8SgCIOBjMSLfd8DW/Z8rPhw+8bTgThiQPPn1d6SoWGdeW3QHL06FGXh0fRCvh+NYhAhTyUIx2hn8TdQ5rOXZvZyxAoT8v77mvpKM+f3w67SkzBb1MUAuJoqXb4sMulq3JUUCAIApo8Qkh5dR7buWugyK3+OPD8V0mPxStzgcKFkIKjBTYMABtHNTjgwdWNXic+wQOCpBDNud5O3TUw5DbwwcN9uA3/DM/uw3O4t/wM9p/B7j7aOfBUZCuwBDWlemA2IiJlxCNIPLKjnmGkgWTwfx0x+q3i42KfsbX8TLt2X0vdwWOmHHgqjvQUuJUae1iOXjdKSiVIc+08YIgCJPorQHiMuz4InfMQIfe82F8hETKZoOYzR3kqGD2H3aLzu2BxoewceShFloBt3PUSoeuoPuzISXRaaux8BrrzmeO2VWR8TCH9dfHELrCpE5NdizenkgseOHYF49CuXzT0W/kRzpnurmnRz2dOzFMx8ZEZ5OslL2ze3t6wU+fevDdbWTmi34i7AvGbCzxi6HoBdMc10sOSQ3frE/e1JNkxwp/PrpUjB54/Cp/rQY5UGO+ym4HQBc+9OUOSPEGIPbk5brMLv5Wflr/ZPuOo6LOWDjwVyy5ccwij3DDva6HGRoYuHC6rV3fUY4RMmTrb2h8u/7laL+vvxU9LTmdjfYIDT4WSHw/cMdprrtlv5cU9Rd78ZWUNjK4DQKqErlQ9uho9K8emdx4bd675yg1lwIZsuGFU4yM4Gi5wGu7AU1HwIR04fMES8Xv/R6zsQqQrkCcgXb305w7JkWf4UNFO85Urz8V1Jhs7tnN63LnTCz3FZ7gndh8BNXz4cAeecsyPaLjef7CVLUF31JyeK/Cw8MejDlYLQ+dEaanG0R0Lx8WlAzSdDUsfmw4SdF3xEarEajTcgafc4ONtzpn94ehIglTqTkP7+hQrUP3rOOwbGjfup4KfKMGNG3e3jvMkryDZWRgH3pqdxalq7HOlj2wY3tJzeMyPHXjKBT+cNvMur6Yp0QWP+4csBd6u+PBuztXgcQOQgCeusxsbu9JDeDzQnvvUzoGnnOpP+YXHipGnPayW3tYCe00CF070DBUIcBgkU28R1W3b1JSudQdP53QPRzUMv2Zz4HH4KRs8TNDhsmS2PQmHxvE2jjZZrGBbsGDGp0zwnCvFcUOKuDjbY0fOgaec8XN9nTf6TP7g30GBPK2eO1qmfIJe6mNbq2BSn7Fu3ba1pXYN0dm535ZHcOAphwBdH27k6G9jFLj3ld8hre2hBrkJhTxDqBR8VtqnCzrHnV7owOMAdE1y8x+gk3tWvctUK3fN+LjPwEWvjcvX5Eecrl343HPPlVIXJyZNKCUFJ/kRTpydL+fA8yfjx4MPvs5enFErdMH7QlkU6GhZ8Ck1+9Z8/V3p6WPXjk0fm38ag6D0tc3d96sK1WF2xKwjdiJEYZAYpTpcD4SUKjnw/GkAuqK5av8579Bqno68KygTQoiPaTYFBGOtj8/YcWt9mjZtWj9qZdkH2AmGWsoJe9ykE4YTRQZQww2QHHj+JADRK8sCz+9CEOXirjYM72jZ9QfhKRin4NkA8hK3FqhpGoW7+vWbRq2MW7tyXFmK4lTII703T8pMhw+XvpwDT7m2cNo8a+R/fH7CzE/p9T1HrzWFgD1CP63cEIdqY1j9QfX5pPPKDaWO8bZFqaWBUlmLtB14yjk/an/ld0Hnd3LhzANYL5Q+3tsCz1H7igQpQeCsCWakDRokMRo7NtoKTXOQpLVxK0+rblWiB3MJLgkFB54/Ezrh4eIQXnozvx6+4XFXu474HL7gAT7aESu0bfFZOVbpjWLnl0H1hfREjR07zuy7nQZ00DAmGifF547nhLnrQj3nwFPx2QlXJ+FX3InQb2KG4iRlihq4HfdWd/GkN132kCltuJ41C1fgJvdmmoxOjG+QvwjOTqGttaoO2C+//EJH9tyix5lMwbNhw8qVG04jQHeMO33Hc6A9tvScc+D5s7ATLhAKD1cAhbs4W1e8r1lurEZoKGSOuzVPK3kumCZNABhMUwfpE6GQzhw95X0U3nHUhWYyhKeziZ0Hye6++5cH60t8Oq+k8d+nTwM3gEvzglMIjSBobdyGuPwNK+PiVm5ovnDhc88tXHgOb9c8MNWBp1zDo9uV8HCTB2cQ8HtFOixC3h7yQ68WzxwXd+DnlDc0ergfPXX6dMGpUwWn4eZiEg54pcun0p1fcNzHQOdBaXffffeDQwVOTTvnk3P3/fdxzeO+//779XH08XFjx44levIlRmtXoi4tXIj8LOQDjm9QfUAe0eTAUxHguaLJD57Yu2C/BR1RUmc7LuL4tdkpvIHhmSBD2mmycadRIU4rO3VaPs3ASSlUv+DU8bE+xM7jBjrIDtIzFPiJiurcOS5u/fqV39911114vwsgWhm38hRnDYCY06c36PAgPWIvGFp4B9LEI4XkiKFz7soRHHjKMzpXzKJjUaLfJcNmOyLv+G83G3jsTD6pZAi177S3YMfbO25tZ0oSGPB8AHY3HAGfuDgfH2JGM5SfteC9nWoOn4y8NIfwZ0P06dMcEy2kTYJE8OgUKWnSpMgIixx4KobPdl3hKb1AQObA4BT/7l+QHtnp47+NIsKhORrSAfvmpTKE7PT1Vk6g95XoaPqFG9bftb7Vg7+w5CA5H8z/nw8+QIzuWhnVtCkC00qYxEc4b6fHFYxzawtLN9euIdg78JTbHp7fjZ0rbkcXuK9HOwUbawZ6VawOZaWn+fHmhp0CdgRHOi8mU3JlTc1vaPXg0FaT5hM5k2bNmo/aM7TV+s5N60cROU+wwdkSwmf9SvwGY+RQAWG0cNw4pTvguHkOjzQHngqqPteLnTJMXn2UIHJxvDiusbMClyiI9Oe4yX8zUNFTESIh0Vc3b+/mfDUa5KfzhjigZ/4NS54dOXLWDfPnP/E9slNfQ0fgQ/TEyR+L2WvaIT2nCRoiSDDiIkPy9LlzIq1N6e3nHHjKNThXF57w3wMdu0mA7TpjrE6WhykEdt4MeihJgFc1XEpN/3kfZ4A2jM0X16JHkj3rPRZr3IidG26w4hMnvEUbd43CHgMVEQctHGdGCaExelbp8NxzDjz/TfCUVgGtLRqkrQZ0lKXHlSCVZTbLz9UwOmyG5+jpgqNHvU9562pjZ9FmA8bWrpVyxPCMXIHCE8Wyc4MwpgfhWbnSJcIi5RlnddeU8Iybwy9gn+6cuSjBgaciZwvKjo+3Cz+GsMyxsaNz7JdoPOxKkU4TFQjYQGOOoE5hDAVNn9LZoqqBLFrkBaJd2dlgsvyxcXiA688yPFE+Pj5NyWcDalpb6RFhTym2EHBaqDltepnC6dPnzlEC7o47QITu4JTcHXc48FRYeDwIfizDfex0x4yO3VrcmhTZW4FNcaf7FVOOqxCmr04HA+JNN2FDxGHIkD0Ez549e+D+84Y9RM/ascgO0LOC2anf1Mdn7MqV309CaFojPU+0Ynw47onjRF9zzvSVlupjlhZq3VBmoJRKOfBUcHjKnIw2JdkMdBgbtZqBtiy2jdGka2o8W4HdGsF9+5qjJ5vShGjdIdNOgBaLmxa9Zw9sAA7eYNuw4eefJ4/NFyKE7LSqX7++jw8K0dhWzz77BMAz6/uxM5+d9cSsJYKelc2jo5vbmi1IC9UZvWbhQnTz5oybMwfdOQGQA09FV55wV+/NM3RId9A9czE5ZNNFiOSCqrTufYHZsyswpqxG69vXrDcCH/UD+pojmQ0b9ghwYEtISACAhhRp9jNaUSIa7X9OzE9fCwe0Z5md+k3TyZ/zGbvh2VmzRm5YuxY+ceWG6GeXYNJg/QZL2AT35kxTX4WQPUjNjZQ6aZFy5xx4ymGuoGz8lJ2cK1dkz44tO+5MW2YHxWeOzQreR/vC7bD9QDiaLcT0M5RXZm+MjZdXomG5uUG50r5Oz+eLK0cu4cq2ffjSn318zo+cNWvW2rGJe9DB+zl6Q9z3EPJEu7XmfQGfvn37CiHqKztym7vrwMVKIgeeCq86LpkDDyY6YI+N0eHo30Z6CsYVzLnKsE7Vc6qvRXxBOWumsOj4UW9zLankhk3igjqSiDeNFrQgtNzc/Pz8Ro2CGgmbnb6fHgU1EuxEfY4vSvTxSQd2nkifLT+DROtnYRtwE/6egY84YigW3dfq3XGQpPfk9uU+KgeeipWhJitxK0CejNW+IFf9Eatt6/jQxLelG+enj2IfzVHOTx+ljDEXlZqkBcXmilFaE31FwwZ2V5CXIUAMu2WJiQmJRUWJXokGL2zn84ManQ/KDwrKJ3qkDUtPb5Q6bNiw1JlN27RBeJYsiYNXN/LxiQJ4Jo1FknBjrRIunm5WhJQL6SJNCI9e+uDAU/FEp6Q0eJAfpS0aRq6jFoAdrKKWS9UzOaZZOksFx7zu/WE55o2y4UPMBmhwpM8PfyZnDN0xqQSawiTmJgpkGtnZebZhw2bibSYcZ6aPnj0M7dCnbZCepkuWfA8v3O/jUx/YmbQeNMlkB8XRkDUbjGC/h+HZY6TFo82pBlX64MBTrtBxR1AJWHiJW2oMeCw9OupMZ+cw6YOaht1gp1SACsZZyel7oW9frQY7eki0xk2JEbskAiqJKCq5mgWhlJAPRgAMazSs0Xk8zjSso26TJ+84MnkH2KrMVZ06rcrs1KnT4JyIHZ2OHEn/8NN/ID2tloD0IEpNB816YtIT69M7pw9jd0/iA1978CBsYBIfTY8wiSf4AfFB6jfs2SP7l0Aw+zYXiY6+It/h7cBTPoWnRN4ZGmkMknr2GsrdpGNljIoWmeeCUvkp0PtAKZlmHrgQHa1HMUbMD8x4gdKQ36TiF45bhgkTlAAdBMeOHcAFsJEJ1hvtLG3Lep89e7YK2Dbao+3Pydl/9uz+D//5IcFz112tlnyfuf/TTx8f9MSkQYufRxu96gjbZDD4kpkzz888P+w8oioELShXalGuBMqQHOpZojMlO6LIjsyBp5x6bSUaMlYLlzyZ/LmrfP6FK9aVq5gdd2uHysXbMK9GeWmTmQf9WDplfgbPbA+llL28vBK9tNjf8MoYHGjN0LKZmR2rVq3KFHb27DLJyDbctm2rsn/w4MHbakjrgpa0e/SWLp8++c9//vOhNm2a0iiEiN0ftnl80NDFd97ZjOj5dBvbYL4PrkIfCxgCdmSZmbNnwzYbvxWJXdb7SMfJbHg8cqTjkZnDzgNl+ecp5mKjJF+iA085VZ6ScPfw6DqkBUHupMbtcnPHjx92ww3zQoqE2ewCDZ6+6K65BScaHZ0iTJuB3iA9Rs5Mi2dSGwnBQXJWodas2rFq9uxl0HaXLUOFYXKMdi+Biegc1WrSpFZR6RFgZwJ3J0UEAiH//OcLbdpEkR368B+LFw9qf+ed7ZuxbUTKauCmwAMKcVdj22BhEjB8Ah4xaHh5/7b9bFX2g9BJjIX1ruLAU37zBSVXt/ASw3+jHqLoaM/7fLjGWRUGiIo2LsehbQ6hY65sM480jXYtBfiZwSkSvZkWwWnUaOYwFc2Qh7aqEyjOKvTSkBvERmvL2MxriObfJSIifZK0qENnqlcfvXt3r78DPKA9iwU8bf65GOzO9u3vFPA8H0ic4a4L3nBTVsOkZDXohhcBLL5YgzkbPHj/YAaKUBO0OfCUE3Js4CnxhB7dk3OtNLhyFXa4ZJML0wQ1h+dwEu6waZlrKzqUlY52YYcj7yJmR5CjwElN1dIAyI3hpy0jJw3/xDMug1WD3hIh7cyZMwY7iM/o6tXXHch5nuF5qCnD89BiFJ72BjzNPoQ3Vq9eXX1IBG64Y6J060JobYEbgSU2RZn4bdvoDJXJgec/yIeHslNSUiZuDDPLztXURyt3tlkEEbuBLoi6mwJKrdlojiE9huL8XGTy1BoZIc5MlRqgzACJTeYyzgPsR3S2SakhnQGlqQ7tHls+Wq/RoyeZLTAwZeO/KbJ58skXhPAsbv/40PYET49m//gn0TO6uq1FCITwAN9kIASPtmyBp7acQZC6EFQR8KO2SAewhsTJgad8+Wwl10wOsmNLD/py0aUIjyqj4VLRAt1JM5cKiAq1w7KuUwU5VK8pqtCMMhqpOUYGuiME4JM5MwDBjUyaVRExxmDpTZ1hsWAbPRqwQesVNclKT85GTgs8//yHxE79xe3/b9Ivr76K9DwUODrQB+HJCexFhgDyvVd1ca4ZP4yoXl1+N6JFhuJXPQIohuOWLqRPXbZsQZQceP7jNQRXgcezYMcNPAYvVxglY/iYLTvexy9IbKhEwMKNMQbn1Knjh3kWN9fktNFVIshhb01Lqs2cPHnm5COTj6w6guHNKhHeUE5A+GoiqOEGa2rUaND8AwMDyVkLDDxkeG5NBvYQ9HxK8AA784e2fxVtMbyhV+A/ejRr5hOIb1ZGH9WLgBrNVOlH8Z06WmeqVzd+0Rl2/HAfscWBp3zw40mG2hPlsTXbGjcef4bEcO8PuWMu2Fy4YIiUzdBOLIAuspQKGJJzvpGUnMncwUncSHLAU8PgezB6aSIeOaN40Zt7YJPAJjlNmuQgLzk5OQ2ZnvmT5s+P+rBHs6ipjZ9/PurZZ4Gdpov/b/78/yN2XvVpEgjveb9Hj4fS4RNymgS6NQZHAmXsCCGlVyRdQsAkUg48f5SbZgNPyW8zj8ixRkICHus6o8ANPjxuOzaaR6ohOAlFCUUGOgSOQOc8YsNhDsQ4q8hVI2eNyKFsmso/IzlSZHpZ23YTwIZtKGhNTkM4iQJu2P7Ro0fjemHPR+26FDYSvLb2eO1/7wH7BV7ok5Pj06PN1JguOfQJvCPTWGrilih5xudCnOSRAHLg+QMB0hNkvx2eq7GjzynqctF24gA38wmIMgIgp4gKoH82SQ7ITSMqPxOaM3ky+mqrsFxASM62/ds4c0UBDqLjqjdNRCvPQVpC2YYOBXhCQ31ykiQ78xf36BG1dcnz/Ro0qOcfFfVL+1mLCkMK+wE89Rs2zGla/9OHFg8NDv6a0AuFmzCFY04OahpyBd8F3zqliTxjm0I3Pp2CD3v1msJOJAHkwPNHA1RSokbwXBs0CaXB434pBfN1xQulBSlYwiroKxa9QXQ27BkyZE/Cz0VaVk0U3piTA5xYU+SIvk+IcGRuIEJyg+TI1hqI7bdhk4ZgoXjHVg/EJCWFJkUNHTo0KckH7kMlPP+vB/hlbRbHBARHPhs1dH7jEL+w4MiQqZ/cc2h1hxObfvQfWf/9ffvwzQQgMaQQAi4bEpukR4G0acaq1ISImtJE8AOnUwLFj+3Vy4GnfAAkiz6vGZ6EEjXonys0o8VwZpE/cGPRMh93xVvWppkq5byvsDgZIz6x4GsIoONlAic/X6Az00hJY2cO5dWoDoY7clhxamjojO6FAX2vKdx0G0oLDUV6sMknJeUkJSVlxWf5DEWbH5U0emtjCU/7HvWDg6Na/XjiZ5+o+YvSwupt3+6bF/NMv8K8XWFhuyLTClcDOQxMEgJIDCWFMkWIZUOdphxBE3w/q5GwKRKuKVPwdApZYKADzx9pplqBsqhMCcYb2mkCjVxOGGI1pUCu+JRcCednABPxUvEmU6EpjvIOH4IFxjywALDZA5rjdVDGNwBOIxpmM2zYTMnNEdAcKlbjvNpZLrWRfZ+iOwVjbvFHHJskKA4xg9Yd7jOgpSdlJaGlJKWAZSE98+cPTclZdMk3RsDz6p1tYoJbLf5HYKjP0MYhwQ0eefTRepF5eX7Bvg22b99e75JfyODQ0Hi4hcaTwUfyQ926d0dUWYca5jC8TFETPEGkUQwVSE2IIgeePxieK6XwYfcMY6J4cTFtSABsJk/O6PMhkqLh4/jl4Wbe5HclDAlPCOcK6Q1DeFQ0D8cBX+3gQS/ORucH5RuFngAObCc7HjnZqZOBDnfmiO7PGpyPRslR2QFqjQ1BCUhpZsyYER8bn5ISDzdp69jgzCfKJyVlxaUGDXbdMPWGm25qfc897e98fOjikZsKTxyaVBhWD9h5xDcyJAzQeRRse72ANP+srJSkrKys2Kyk+PgktvgZWVmoSDOSSJdQjbqTApHm5Qh/sSEJUcOGOeIJqzVx4Ck32uNCiSYvCZKaEk/hAXoQniEGQOgfsk+ncmXiDeJrOQugWwkN8SwyJhQoojHSXl5iQA5C00gMxwHJoVJPLlgTVTfMDnaBorMWYUQ5MshRnhoKQHzsjBmxsbHFaOuSwVKS1yUjNskHkukx7ODRirDgXTFTfWNatwZ4Xr1z8eLGacEBfh36+V1qgMCEhYDz9uijDI+v34ksQQ96bUm0z6JHWUJ3LDKkXYlHnzELHMb4eEQ6Np6PeMCTGQ485Y0csy+mmjFiVAo1JnhKBA+AipZKADrE8wkaJSV7xPfxdwIfxqdhvQBtonaAcgTkruXy5AFGLyhHOUeOdMrMhG2VIOesqI2mzBrV25jICVTgdIf2WFwcO23auuRpyQxKcnJVPh5AkxcBpuRi/xNbW0/dNfWZZ5755JN72rd/sDBg+/aAtGMsPJfS6Ij2SL16vpEnsggWNHT9cIeNPx6RgJ1w4vgFeAUBYxcvFkHG+zoEeho+SJk2rZiuoTnwlEN+rs6Ie9M+Zo+ABo88Mk0OhzbQEVSUJBQZj5geLy8ai8MGbhoNzdEr1oax6HBnDrJz8mRHHBDTW9R6ZmLtAFUfc05aF50pSnK6N4SIg1rpNDQg5kBVZQfMxih9vT50XXLUMze2vhHsk08+ebV9v0hQnAaRIQH1gJcGkZG+BjvktqUgMSkpBw6sSyHfD/axeIhVGMRmpRQXpxTDk/GxKVlwuZgQiWd2ikkLWRDBpsENHgFcDjzl0GtL+O3wCEdrj6RGPCyyvJymdvLC4QO6JRyU5qXODqqxoEbhjerLwTDnZCdCp3dvzBDgndjhHEENozMnsBelB0hxulPHJbTQZGiQQmSq1pF2AO8WfA4c8A++FBOY7PPMjWwoPQvCGqC35nep3iOP1AvIC2jA6DQAdi5FHsvhgOnAwI10RMePWEjhY3HsOiYjPgVhgdOslFgiK4WemIbvmZaMbMO9mMBBuvDmwFPe4eH2DQZqkJAgWj88ogfY0pWnVaTRY5n9zIhaEujV9KEJXtIgjOE50uj6Qc2CRNenMWEasJMqhxfM7DgTB1sewTCn03uyHxQ7dGgI2bbB21SSAFME1TEprVQHQnT/RTExMTkgN8xN1QNAS9UDzM7mzXU244H2iBLhMzq4QYPg19f5tGblufGTj6fOOhaMkhMc6Qu01AvbVQ9TboSOb7DfptGjB4Pc7P7XwBSOnuDBuhROP4D+xMIBVCe5eB3IDmnQtGK4CHysI29tHcCCVOMOwUkmhKYxdY7y/NHptitXVR4x9x9JBG7YxL2spq6YJMTQnT2m60XyTYnKM6O38jFXkWNMORMk4EHVST3PQQ6NVQZyjqwi0VmWCaKDI5wFOvsH15AJtjMRKtSZIkSnO+aOf0xLSwN4EJiqDIrJ6m7cuHmjYYjQ12GXghel7F6dBxY59cYbY0LyQkKCIch5JGAXslMvMhh2SE69S8GRhR1yVocF9wsd+K/dKSnJ5LClrOPsXQpv8eiupbA/hhylsCatExdYrEgW1xWz9iQzOtPWTXOUp1wGPTbwaG2+dGMBIRSK9mgsJVpfaEzBJCMbBAczaQKdg9q8TbkCnyDprzE7RyYfwbGgYrIO0ReqjWpDdmS5p+jPoQwBxePFVU+EhKTFJAEy322ua9iECbBpJtgBmjZuPrB3QYfAdSfygi8FBEeGRE5NC94enAZiA/CEITG+uy4RQ6A6gM7XWaRUhwamrNPy3nQoppiHeCE/jTw5egLkhxhCEUoBtaGE37RkdN6m4Ybyw+rjwPOH9/Rc8Uh5rg7PQQrsvcTLEomO3NxEs3H4zzGMmpApKEifYxDzaEGNVDoNzJhr8Lyce4AnuqER1DTHTRUe30+Dp8UATBpsdkbVrDVpmAOeWjxmsorR9cGMAMGTIpnJXrNmTfaE7OwJY4AYOGSb2EF6NoILtxHinrxL2x99ZHu9AL8Qv+2Pbg/O8623vcElgicgjJy3egGAzr7Xc1JeD/YNWJQjwcmShyzqdEWUgKEs7oLNyqK+JYh8MPQBL24dHklyKFVB/prw29h5c+Aphx2lbunxKvIqFSCEhygyphLU5lQyphUMCurTpw9F/UREqrCZtEM6OH+GuQBt/rSTmBPoRMno2bNFtVpvvQe0hhrKJoflcE8oCk4OotOdGyb8/UZ06tQheHYDOGvqrkFasrPHZI8ZA3thVvFh272Jk9GPbPeNTLuEibZg8tIIGtr7hqWd+Dql36V+WTkdNp34GmHhRHUS9vgkpcBeKVEKJ685OZ0CmogdqpRkg6AIECoGqQInbV1yMoY/05KrUlD23ebv6tZ14PnDg56rRj1FCW6V56AZHZ7PzytXDUlzNVSWPsaUtY2GpWqmKjr5eGQH+mYdTyI3aKQ0NDPUskzy0EQ/jsZORIQFHQBHJgi6z5jBqlNVpNS+Y3gQmhEjEJwRY0aMIGpqC3reARVCAdqo85N0LMy3wSPcCborEqSHPDZfhieAfLe8j4GUfmFbswY+CdEOlxVwLw939tAZbPFwE7KTlZQVH0r9PrCnMCgWHLZY9NggJgPJA8az14wZAT8yG0Wy7oQ1DjzlMuxxpzwuSqMlk+WZFwtOrr0F5SpwqJ/GBI4xQedJZR0n76Bjp5M060BvEdsQO1y0Jma4Ef2gZ+RYseq9eAgno4OFN/GYEoa4QbBTt26HwsJjMbsBHYBnBDFTmzdFz/J3fvih2ztm9TmwIBIQIXoa1IsM2N6gHsGD2FzaFQYxT1jepRt9QGRGpzz5IZFDJXKhXGbAhTnME/afwgOuoMMCBJAd9NAwd4FyiDzX3rmzdu3aO2uPGAEb77LRAB8HnnJJj63uFNn5aRy/YAgjZpKFaAcnfrYXnj59tInSuZvTkBwFj8CmE2iNsk40kSdP4VlFlkmryhs2jHLUlACy5hMHzGDxzQzqZUS3B4TnO7C639VFhCaMoDZJ1GAzNQwJQoiWd+vZ86l3NL9tRQimBRo88sgjDephqOMbFsDw+Ebu8gurdykv4KWXooCGjc+/n6RZKBWyUWk1nnPmGvPfdTbX3TgBUd25fOfOncvBjAOws3On+DlETzbvMEBz4CnvyuPOaRNSk4s3KSoQ+btTHK17U5+yE1NnIs450vEIMyMMZ9CE6KZTp2W9hQlgaMoOo9BTRDnMDQU5U9R4NqxRxiIxrFnjVC/FOt8RPHXXiKaI6GBzhY2a6fLa72BjVe4byM4XT/Xs+S+pPBv3huwKqCcs4BIojR/4bL716gWHPRLg5xvs99JLLz24e/ffn9+4m028UQRQ4A2ivJHOwXchJvDdy8n4AT3eWYvoIXJ2avQgO2uyIUpz4CmfnT12Tptrao1yZmr5GjmXuerWzA3S14IypuxMTR2WOswYtUayg/M5C715T6CDE9ECPJm9BTxy+ls1uaaouumiZh9gcnhkTg53gyI2JDdIDOCSTaTQn/Ouy2t17dq2clu0ynDoSmfL237RFVvxF1980RWMTr5Y/g7YFz3Hv/3UwH+RjUzzC5Y5ad9LkS814Ax1cMCj2yMDwmIAnv99p2ezfw3UTCYhxtR+B4Opd2AvFA4ZkeAsVwzVJpp3KuEhnAU+KDx1nYRBuVWfq0c8B8305Cp09LxzH3nJcNjQTRNjbzivhgfpqSnVycxUhdFnz/YWmYEq2yzooKsmUgOBvVTZTWj30BmUV0MXDTWGmIFWWAtgqTxqVEZG/4sDBkyc+BpYJd3m4Qa7Sl99Vem1ryp99Te2e8m6/fBDz7ffHN8T4Xnwxl1pfmECn4CwRx6liKee76XtDXYF7JoK8NzTrOdAF2N6DI5EfCUQwvtyqYDosAlmxHHMCBnz1BYBkANPeYfHXnoO6uxIry3XAo85rQYxTqpgh4RHpdVmdpyJ4LzX6aQVHTl1tKiNVvOsk9gYWtPEGATavXv3GbLOkz20OofWj9zaGGxWq6j3gZ3KowCd/oDORAs68+YBOLB184lagusizoqK+uhe5IjsbbKePce/WW18z57/+9JLgE9eMNMT3KBBPWVhvmEAzyefLB448H26megZOAHucHzf5xDaxjFKf1Bslgt8hBe3U57WFmdKjJgtB56KA0+Re+GxOmf6ElHDdLOkpDvO5GE4J6k6DWsFOol0mlyiYJs0MX0zKc4WObcauWlT1KAczEbP4K4cygzU+W6t/yI/P79ItF1gMbN8gB3QHWbne6Bq5FcETqV5fwF65nW7q598A72+cdS9Bjw90WY1HV/t9ptAW166MSYkrJ7VfIPrhU39BKx9z55PPfXRyI+eAgPR6vZDN7IffvjiX1Ej8Uuwwidvkf/nPuwvCqtstrZ0bzsqo0VGxqhRo/rDb4eTjAzYZ2Q48FRUv02k2RgXV3jsMgPmNaOw+2bHjpPvZWa+Z0gNZ9O0NQrEoAKjD5RcNWM+QgFPEyk7GOMUTxOdOV8vystLSwshS0vL80MiGr+fgeiQ7nTIg2s95yn7aqQfvL6QXl9IbwB+WpnY+XdkZL+oHp+8RDY1BLXHt56vAAeT1b71AmI+ueeee1699damjSMjW+Gb4K1vvy0k7N+zYiLhW0KUpfn7SOUDgP9Cdou4KxPq+JqwiRMHDBhw0YGnnNJjUxla5MqO2V2zFZ5GFnDIQROuWe9MUy7AWKBAI4ax2dJly5aI6goaGlgwRXhr3RkbBGcGluxT+SSOLdirt1G2vMhdkUMlO5U6YCdpz3ksOvPm/bDI5fVpfoDbU9Jn6wlAoCzFfHwj0xPjR8xw8OOLB4x9duHMba8O7RcJlGy9lZjD938F/PR8Ai66fEuHgdJrVPiYDbhhgAQ6r+E/YYADT/mnx1V6jDE2Jm5EzY2N19aR9ebke2QqrNF0poqJFzEf8xm8GZOtS6URQY6IcmaQqxY7LZaiHMpCf7dmzZq62Xu5kR474b96xev7Vu/tsIDxiayP7FSS8LwtZOevPRdxU17gv2Lf6PTXV+z98RjiE7mrX09m51awVggUOHVTCZ8b/XyRlwCSHkoaoBQFP/PqPa1jEJ2QkEUv3Mr40Gf8u59E59iCEz8u2FQo6ClcX4lzFYyxmRtNeSop5cHNgafcOm6u9NixYyxW2AfNuiSupfPTBI/WeWMENQY4Edrst72mYC5ND26683QDosJTdN6sQaNEdK1aXUdTszzx9c6MixeJlkqVslcXIg2RzaZPb/dWu+ntCJ55r7zy669z506fu5ea8eov/grGPN07+gRc8tvVmOBBdm5tzHoE+IS1xrDHF6OcYILnEnaThoEOBQR/HCMFJq8pvkvg8xF4bPSjVuz+AmKpt7sNPOR/jPFZoXtuGIEZ9BBAAh6zGjmNtiLC42USHlXsqUc8IqVmA4+uO5wb0AIbrLLZQsvinJE10YzOFDWpGifUBDbc41m37po1nI1GbLpS3N0B26T/qIkiJY1RxC231D2G9Nzw1lvf3n//u/f7IzxvvAh2880330vsDLwZ7TbYbrvt5po1534OFyN3vfDmm2+OHz++WbNmQp0ogIr5+BNgBXjhPh8sDfWN3HUpIMwPLC0tBnUlbdbzip5/x0SCFoX8mCR8OLIfVhRq9PAOGYIfe8sDaF9++eUDX07/cvr06Xj2AF6/xYGnfONTWj+pHTpBfbSVC2U+2sxOx44EDycIrP2eRA8nBHB5mgjy1sTMzL2MpICRjRaaU0ewQ92fDA8lrepgm1yQoeIb+AuOzbE2XPaLmQfsAD0SHgLmdWzCh25DaOgmbAXSNqsa2u23394DlaMwJo/kx88vDLBBeAJkRXVAGqAGepOWF9P6GVKZfrjMyHiyfqQ7n4//q9le/pHo2T33Mtivv97/Kx4vw897F3/k/b8ufeWVpe3atSN4gJ4HJD1/ceApt9rjWqFj57YFaeuk58qOHdmVM8xU7XmSY55MI1eg8gSDjVhnS8SWLlonjghzAsFnw0lwZWaguFiW2lDlAMCzRsLTleAZNZj+nA8YoLpCUXmg6e3DZt/mW2ia70p4iJ2b/TES+ettyhifh9/YhLQJdp5+HH2xvBtv/DjGrxDlJywA4LkUzBXVYZcuRbIw+eHUOs/E4OmiHvC+2/H9k4gdn2+EGd80l0Ry0xs3owS+ePnFy8LevR/xWfrtUoannZUeB54KAE+CPTy67nANQR+Fjua06YXSBjy68lSRK+ZuAW62nDFV2/SaIkwmoznaQXgAHcNry1a6w+yM2ocNsqnRF0peGzhBA0B68iah1ybhYXZuxr//i2pa4fnmm89RepoxO09PIh5o+oLWU/NC0kLCfC/tCqMBPfWCwwKCOc75+MYbEZ6p5OC1eZrpGR8TCc+mS3R0fuZiaBXyOv2MF4GeFxU9ZEtBe155hcRnOtHzgANPBZIeO3gspTh9VAFOqkl4Zkp0OrrAIyujt4nxOFuEnTH342i5NYInNnZGcSwHPOy0rSHdIXSAna6IDsOT1nmiSBWIkAcDCP/CwrzGJDwm5XnYCs9tDzM9Tx0rPOb3ELPzNOULYsTUOa1RSYIRmDABDwtP4VSGpzVFM7OeZnqewIDH/7FvdJNf9QO+8tgbDA8as/Pu5fvBi/sV3La3XnlLem4PKHoceCoQPaZeHld2+vQxwZNqgecku216b6icC1cozxZOs1nYmWIkC6TuyByb0J01WrYAIx4qX0O3LW0rwqOxg5F3pb+99tU8IOcywVO4aK6AB32nvH8LZKRhC8dEATZ/gOdOyhd8fKO0GOx8DRHwhO1CjjAeyvsY2bnpJnp1v6eZnhhE7clq1WzYue02yvQdUuwIelh4fgXpQe1h4dEcNweeiig9Xi5umw5PIzuv7aTw2jJNmTapPDWE8nThjh2z19ZEFeCIXEGxmR2hPCPYaevK9WsZmDBIy1vSn7MFBjzT273SjiOed1/EMGfRm5xfw8xASNqip1zY+UYmCwCCO/MInmee0ehB20Vjr3eFoUvXOiYtLy/mY2Dnpn7kxN1J9LTBXh9/YKeanfZ0o9TgzRbpuXw/hz3fYtzzFsIj/DYHngoOj6vwED2pMuQxVePIcaGiFMfIUmudo5xos4Q8qlNU9YjS3LMaPJryaF5bRsYJqsn5cdahFq+JiIe8NoDnrW+/JeW5TPDMFfB8wTU8W6N61nSFRwjPoELKFzwjrHWM6OXEOdt8d2FCgDSndeuPPwZ2/oc7hQYRPE9gv88hAtGGHnIajzE8N2v0vMspt28BHhH0qKjnFgeeigxPkK3wpJry1DLPJtjRA56zltICggfxibCUrk0xaqa5ZLpYsFNHdfGMEDEP9/EgPBcDuaItLc9v0dYlh97vVukvqDwoPUsxUY34GMrz8MO3PbxXlMDlLeq3JOqjW998mOGppsHzBOULCJyPp8ZE5mFKeiqoj98lHIKdlxaSJ7BCdP7ng/kc9JD0NEav7VZih29melbjK9+/2dCeyyZ6IOp56xXMuH2pdfc48FSkrh6XoCeotHyBNdVG43Xe0yKes0Yvj1ZasEVfIXSKpWi6O0+rqY0IrWvkCzBN3VUO2cm4+LqqCM3DQulF/RpP8rkXGt9bby0ldqTb9iLDc9sbHfTX+0XG9JsV9cKb1Qyv7c47OV9wk1CXqVOntkaM4D0BAZcCdsFzUyU6yM4Hd1NB0CKE5+l+4LVtEp8G5FSzaM8hBY90217U4AHlWUopg3a64+bAU97gueJeerxcMwa68phHu7mm2ggezWvrbaM81ENK80qbnTaz8kwz+ni4k8eIeITyZFwECzwhKy8LDSJGfvqlUB7qJGXlIc/p4ZqfH1MFoYI4ICiqmRIezhdMBTSe0aw1ptsCAjDVVthaoYPs3M1Bz2KgpwcWnXa4vVo1hY/kh5XnfQMei9vG0rMUpWepuavUgadiKE+Cm3SbDTy619bRRXk6afBY/DajvOCMHvJoyx1iB6lW0KbmIpDCU4vTBaQ8WNA2cbT/JlONdBoS0c9n6VKqzpHwXEblIZv3dYdCy+sjIyMbNxPpgsWYLyhsfROZQQ8gtQvgwTJQforQAXZ+mUUfM9QVnm+qWTy3gRa3zRAeQ3uWgva80s7w2xx4yhk8V0rz21yybUHulMeSp+5ojLK2em1VtCE7BI9eEEq6M0WtFDrDlGzjIdaG8mghD7KD8Lw2sXLy63s7LDhmIIH8bH3gW+olZXguv6jgAXv7/c/xDfrrIyPrMzycLwA0bjLZ1JCQyICAMODqYyaH0bn7l1+G0vc2tlOeauaoR4PHlK0W8Pz6LRoWGrD4OPCUe+0pVXkOWmYrsE5SYDeZlFgFRB/FYxopyuN29CkLqY+niVZKPUNLVWvKo8OD9PS/KIeLvlap0sRRtSYEAkSbJA5bX1mKvhDB88blyzfXfNhsb8zr+a9Dn/v/yMwBbm3Ia+N8wQcfIB8aQK0LQ/JIePr9jyCH0fll0OMi6AF6EJ4fDXg0x+22b8xumw07qDxgb7WTnT0OPBUInqKEq+SqVcYgtXR4OhlDEc6edSkMrUEF1QSPa5q6oRiHEFustOc7Vdi2U2WqOdt2UYdH1PLf8rfl+ygMyst7aOm3Sw14aqI97GqPvf3+XhrT49fPyBf0QziYH2ngtwVDxLOIwUFyGJ3H22xVQQ/Cs0mHh8TnMUlPukV5yG17UbDz7v2G8Exv58Q8FVJ5bHpJXRw3czdPR3PGgGYqsMzCpsOD3aT65B56rk3W5sQWa6N4BD3ZWtBD/TzSb5uow4OVobeMJter8dJvX7n/V4Lnr5drEj0PW/B5DDaw8XuJnjYqX9AY0PjAMAQGoPIDp22+JIfQGfR4mzZtlpB0TQJ4tmIlwgsmeqo9Vu0x6bbttcJD9DA8sqtnaTutuNqBp5zTk+B50BNkrc6x6SKV0+O4h6dLjS5q6Ggvl9k9unOFQbFGT1UXeLpW5l5SIT1Ez2uVtCKD3VRJ8CUWvDA8NZW58IP2JtXttMJ8AanQDXcL+0AxND9EUiXIQXSAnYce+ogcv60ATyuEZ0k1s7HyAD010b/bZKQLLrP2KK8NqwxeESEPC88DDjwVOOjJdQl6+rgfymOalU2EPNapC0RldYRW3Dall16a012bHadqVTUWjjt6alOyGvFhevz9/ZtnuDhu0OYeoNGhb7RrR/CkLfrrr7/WnDv3jWe3rl49EJ23mhZ4HvuIxrQ9/fTTnC94EOG422woSYskOOSwoew89NALT56QPT1tEJ4fzcpTDT6d6aF8wV4NHq4LVbk2hAd7SY3iUEd5Klw/qftkdZDFbRtmEp6OOj2Zvc3zfuiD4Uz5AspUT9EKDLSOHlFWLepzlPTUkt2kmFSufVHQI+vbCB9SkvHTIXpgeOb+OhfgwWTCXkN/ahrw3IrwjAR4WhEIgwYN+kWYgqcfyMaDzM2gQYzOQ4DOC08+yWO7H4d3k8/3keayMT3fEEDUP7vRUl/wriE8HPLotaGO8lQkelz7Se17ekqpzjG5bTYjSXGpgwgV81Q3jSHtLvp5xITt1tpQOScoaw/Qg61xsAx7XnutkkEPNtQF87BQp4MBz1wsLjvxhubCKe35N8KzBJo/Rf/9AI3HERGFENgkcNqIGwSHRYfQefKpdA564N1RIVbpeYyk57FvbvvGhyYemat5bYodDnjux26edrI01CnP+bMpT5AW9LgM5jH5bWryD1d4jBl0lfY0MQmPHEWqpwx4GPaanUp72gp4OhhZA4OeiRi5dLjlywe+/BLhWfDXV15BeFbzUOiaNefW1Awb93qEJ+r2p5+m4dIjAY3HhQ1StiBkK19qw+QwOk8+9dT7HPQAPD3o7Vs1cJidx755uOcxOSJBFue8a0FHpdqmf2lUhjrwVCx6vDxJVqfSVO56VbXrVNS9S5nDQJsPtJdWnqNiHipu0/t6KGeQrcbD0RwG1MPyen+mxxhO+pe/4NCDkFY0swbBMw/+mAM+G+mP/zzAqKbZxuMnFd56++09KF8QBWS0YXvcMP+QH/naQ0yOQKdbt24U9Czo8fTTtzclEXqWs2wEjoCnJ/U/daipOW3vyoAH6PkWe0gxXWAMSXDgqRDwlLiDx2VAXB/zOGxLysDc1WPSHtO0oKI41Oq3KXq6i9VCBD11xExtRsZtp+jsobLQwtc17WF8viYp6EaJN4KnEk5MM/0NyiOE/HjvXGUoQnNrvu1PQ21uv/32f1C+4KMXHmJro9vIkMKmkhsCB9FBdrpx0ENjscntC9nb7DGz+RA7hfdqY7DfVbrDpTmgO2/JAQlqCh0HnookPQm2/aS57moMNHpOmh03e3q2YaZa0FP9jGVAj5Fw48Jqw3UzhpOuMYaTdm1bi6tCf8R52yZK/ckYzZXTSzj3hg82VaJRPtOnb+TJCFd88VeDnzfuXU8KVvjkm2/efhd93r9fEPaQZh+BS/b9CyZwiJxu997LQU8rGopKHIZsWj/eIOfNv/PFQurjuWwIj9HDA/Bwoq2d0h0Hngoe9VwFHvNwONeoh/CpYoaHp23Didwto+GmGMojqgyMrlIsrq5DNW6kPqrDp84CUVF9wn9189dfpzlDRclah79x3w/BMwCXFMGbGMIQsglnGE1PT9+3wv+EqInzeRPsWZKgJ4W9oBmyc8xHPiPA4YVJ7h1YKJXr9tvHMyghx/Ye+nvPN94c/5TP5z+KH7kb0RFOmxbukNO2FMty9IJqZyRpxcy3eXm5padPKdJjvwCPJerRKqst9Oh+m02+mqefErO3YX8PqU+dDiH2tjdDzFpL8PSvBCB9hUvypB+zf/2mQzRNNbXzz58ie1K39+GZTT664AA6LQQ895ICbsIJqCSAjMsxrVr1xBcP3/yw7OHR+ncoV7DUqAfVAh4QTgeeChT1eDCox92QnpMdbaSntys8MuYxJdx6mRZC4PlzdM9NrZMotEeMyK7Vdd8CGxRORMgUwmuIQ+Go1/4Gp7SK1Tv+ha6vL9z7DkHwBT23m9l4SjdMx3XQwGkhyRkA2wAKekI+QnTA/m5DdOG+N26+uebly5cNh40SBd/eby6l5nBH+GzO7DkVu6vn4MHS+nosymPKGGjDemyHJZjp0aZ2764S1ibtQcdNjirNlr7bzlpddw5Wnpdw4fYGjro4YKIo3Nm3tbH/6v4IzkSxCNzyfR1MI4COddg3RijI7mNgC95p0aKbi2ECb68Ax7D+bKPxfcfW45ShhI+Pv1ngfvz87Zo1LxsmAh3uGH3rraVvyfGjWqrAmbftzyM9uVeXHtOYHmP1N5kyqGKmp4uYgKpXdfvxpDJnbdRXK3zq1s2Wg+PIeatVZ/Trq/eirX49sG5lXBQq4+LFAQOIH7S/TSR0BgyAbQCcVJ4AbyDbF3GgK1wT8PyAC5MuV2iY6MEU3goDm4wMwga/Ch7h2m8D/6XWt7r33ndGr+5wYsGmYwsWdPB/fSCt0PAAwjH9V5po6lcx1SGgs3Qpjx61yo6YrNppqBUpW+1x2JOqrzxqF/aY4bE4bq7aIxdJ0ItENfmZpg/voWWuBT48rQGvvVZ5FA1WoJrr/ggQCdDfJtJKUQNo58buVda/RX9wylwNa7X3KXIyiJ4MAQ/ZD2wsTvBBLV5uu/zll/82gAVvANFLhou/4Xv7I9L462AvfwdCj+PLL/bPwAGzDjwVuszA2lVqrtGx1oeetPb1uOAj+3p44tDqxtAEvGlLjIgx2fEz4uNj9amoVJcpz6hDwY8o2REzuvEobQaoPzVEaJoXB/QnMeIWys1UXIB9/wH9FTv9+5M35kpPKHh7X7fIsFoLCzwv/9DiZXoMn0Wfj+DwDr/qIjLX3/wJfMdfLO5kuNyiA0/F6ygtLexxMwGVSXqE+LjMWW3y3LYYM7iZMtaW4T3d42nZ62JjNirlvamp32XJG5UetNXxgXZK/hX9qecHtGIpoATX6E88G7Z20gvjseRCHveGhCyobMuNQc/LYFo0ZFK3i4Rwf0lPf4EKfpKQS0GNYseBp0JKT5Hrur52NTo2s+i4wpNpA49Gj75cggUfdNxgi4/nWtFkEz6G/uyUZiiQQiiD2+cobqDY3vnvfn/heRmssFy0aGG5YvhtISGFo/FklKJnlHt4YANBu6iRM4B4NekOEyO1RmmOYMdx2ypg1GPtKrVOZyCLdFJTr1ZeXRo9NdTkoRFGrYG+EKkhP0hPPMU+xVV1fuqKsgOeEnEErtZO/DBEbbvKlaf1RokNflSG1W1qUaqNGgVITACvbd/LZPKzWsBtVAugBXiB3cuATlsBDzE4oH9/wzW8yBfg2/j7NE5QaypbwBnlwFMhpcdee2hhX7uwJ9VupRF39JgWJsUCUVrk6owuPoFTrOsrcuYAi61lxVsdJT8CHxkD6W6ckUfQTWumOjTU/jVciA16LbznZXChOoSE+NMHvEw7ZOjlUS+brW1bUp5RiGcL1LWLwjW8OEB4iBkZKrDh7IbltwloxGXHbav48FjnM+hjnc3AfdZAx8co1KmBAImhcRG4vqI2gyiJzxSb0dndZ3DwI+Snjil/UFcU72QrCSL5YSdOQoQcwQ13Uo9efrmyaPjy2IIfma1t2xUQ8NRuq6yyIEi9gs7pk/HtCEcLDrIy2FmDPflrSFblUZIOgscMkEGQA0+FwccjemwG9piyBjPd5tzk4Lht28wzUYkVFiNcVrtqwuqT0zAnx5K5LjZy19KHM3IIooBHFZBiGoEQEsEQeXMmBKjNi4cvC2Fpa7auXQMLQ45lwXstJLal1yqA8CJRhOyoxBz3CFGQxaIjgazctrKdqeedhEG5tXAzPgmlzB7qlp7U1NRU99OBID07OhnFbgY8et6Npq6OME0iqqXeeD7EnO7ID8c/sbGi7o26T6cZCBmdQDKPLXuCeJNSxDXZXWX7tzXJCVutruC0NZePlpsR0kCkg5hXTqYp6Iai0z9DeGujNF5dP6RtZY1eB55ySw8Y0RMu8SmxzOLm3nMLMktPqt1aPYTPjh07TOPjXCcR5WVKIyLMS171CgwMVCv3qPQB8zNjhlF9YCgQS5BpbnjVFVR7p4yFdi5fjgmF5bW62puAZrnFIgpDTtQ2XdHeYWJOMDDKFFsRQBlGFq2yhVTNqRRPdiXBc+Apz/yUAEAedffYxD2NLOJjWRib4Om4Y4fCx7TSoqE920Sf6Rlhlsy1ufBAn2QHJzvgEafT3GiQrIOTyTgy5mh5LSQIbsutoIjHiBy8cDmSB9Y8JGTFcomfwKiWRlDbrlKu2nbVPEKFkOjL0b3ErtInVG/sqp5gwavlwFPuAVLac3V8zFkDi/i40tOx4w4NHxH8nDVNwrvNyFtvMfCRNW+9jOyBufiAuoBieeBP7DSIg2ItkRAD9B3l4gChbKyHEyTVrq10iDiqTayoa3RW22odQo6lKPxUzxIipOclNCmqLBnimqHKih0VSMm3tK1lUj2WPvpYB56KlTrwYKVF68zv9vQAPmQ7zPRocyHqmYMaYpyChMe00rxefWBJwtHYHzFFb7E2elsM3ha9QTIbB1pUNxucuWxGaIySo9pjNE7wHJ4fk509ZgxsI+BlI8Yc2BQy2PpCgod9ONH+aykO2mp9tbK3SXhsXRU7tYgd41QPs/CjHHgqjgRB1KPxU1TkrlTHfrkrl7SBpGiHKfDJdBmcraIfLnjbYguQkUEwprYWSQRTKs4EkOhPBRmq893mzQZCdSdMWJMNUIwBA0RGjMmm8+zsCQgMncE5GkoW3cd02DRhTDYSReIFrzfcQHL1KB9BRyFGtQQ+nEYQeb3KAhymq5bkTYkXQsPvhrOdDjwVDSDDvIrs14uT8LhXH+ZHW71HC3xcqt00/THqDhQ+LgSZHDnFkfDkKBSaoZIJ0/RcAsjQ5s1GrxAQVJcAmbAGIFkzwWL6y4C4zQtW46uz8dVrkKls5MwIoiA6Wk7wkBIZ+FTuSth0FekEAmR5Lekf1pYRGTIpQrQ1JIxIbF0HngoYBJkI8vJyGeETlOtm0R6DnpkdXZLXNvj0tk5xwNk3GfzoDBkEmQMhPRcnhgLpM15bOoTANoOhK4dStBmB2KyDRBelfbdZPQhdEMooCaLA/0N6jDyE4sEImNA35C7b2sAZCRpWQ6Btrltn83fwYw4cOMC/jn5qskx/8HmxA09F6/wJJyP3rSiB715eXm5WK3WlZ6bkJzUVCbIsNG+eWceyik+NGkblzhZJkEmDmCFOY5s0SEslNFSzIBgEwS45OZmnQ1C2+bvNdTYTS8L0c3pcR16pW/dr/7qWZ5E+2iFRrFUT6m6mT66KW1XCgr5V3vlCMl48kHxgWjKSw8QUJ1dlduiXVkVywBx4KmD3j5Z+QxUqMquPucfUdcU47vVhllCAzPgAQJmdTPjQDDuW8Idm2dkiTEF0RhEUaAAUOCWwicmJk11CokMoPpYHBcVOo+l4kquKv/XQunEjO4C2mR4c4M0wfvrnrw8cgLceSE4+AB+QLGxdcuw6PKyLXVecnIyAFkubJqAlJuAN+FZ8QTLzhB8BH4u/qBheUSxdTMq6J7P4THPgqXjsmPp+VA7BXZ+Pi/gQQfKcXbeZquf0Peank1l+tBnha2gKhFNb87Ikrrk4Sz6ul9YnZF52QUAk0tpYHEcNFNsqwbFuHWzrqHVjA4eT5HUEBltKbGxKbFbs4NCs0NCkpKT4UGFJWWwpWSlggGhKCrw6NjYLkxbFpHmAEnwO0AOkTEP2pjE3xB4SQ6jBS5Hu4hk4+CIef2n30O7dQ0O7x3d34PmzwCNycKZJ4AU/jTRjZjSSLFVvkh6z+tiM1hZTvPGY7S6aCFU/44Yfm4w2AxTK+bj4pFhSImSINuQiHgkIzYIDspHEu1A+w2P3GaHxeKasIe5ycuRDpCmejOGMLRaD9wCLdeuKi/l76PsIlNj4GfHABbwLYjT+pSSjgepfYfzjHHgqJD4lrmau3TFy10G5XGfdxwJPo2FUb23OXxv1BjL4odUXzctgDTanDwREEiDdf7PrEjIyClxfOkVz6rDUNAdOFF5NcnKa4A4MgWgYmoNgIBqcgBCz+eBpDtFopCckR0kID/PDoqFcR/oC8CkDycsUUGAZeRfaInDO+wj5B0L9qahhnDrwVMyoxwKOS+Gol8taJLoEpfJhmDQtga0V7LD6uHpv21wDICVCqmVFEE9nupxRVXHVjcMZN+IUyNES/qHHmAlbNv3dxxOEA1ASddxkdJZDpd1N8BlDKPA9dG5coi84AzhsgV88eD8Y/APwUKWK2FXZv+zsssxlstIcTpYt6917mbSzZ+Hps2TL4H8BDg48FVV7wt0O+NHcN2bHWnXdx6i/1iiimXbMZQfvmdbCEgSddWEIxQjL4Ew2eDBp1OAag7UQCZQJ/5yzWTy86qrklBkSHIkD0QCQyOyDCZRA+VLhVKFgDAYDHs4umz179rLMVcKOHIHtyI7ZeA5PzM7MhDvt5U4+mp1pULQMN4Qp8yxdIJKWLXPgqaBhj6v+uIPHdXJRPjPycVKQzEJkLsDmaEhz6DItSzO6mAmkGjX0RDdJU4R08yJsiuY0s71IT5wBAgGRGvtBQZbNXrZsNnAx+chksCN0dkQe1Z4N/jCsWrWDaZq9arYEazbzZFzYscqwTNzon22IkwNPBcbHCo9popAEa92bWsU0V5nSH5MEET+USrAM3X7vPZVOMKauEnGRsCrSv9MXPBXdRCaCahjJBjnk4Yzu3LGCVBcixUJCzhZwgioAjXzVZCTlCNEymYE/f56PyP9kvOGODM/ZjhhkTeabuKqdTZ7MD3Z0QqlCFV7FjixyBDsHngqPkPukgav6HDQS2LmJLvhoGQUjoa2XkRqp7JOKHgTIBJHVdF0SI+y2IQM1cCdiJnhAoZMki67jG87i33eQgdk7sFnvAAYkIZIOPAid5MMwuQl0tJcP0x7gM/x6zdSHwmlHpbzqf2DmZDowfjiKEHFy4Kn4CIW7i3yKXFw3xCfRkCKyIHP8o9EjAbJOvcMUdXqPPThdhXrbMSQzDaYuI3Ehk/+g7+i04yT8fZegSjBQSUBLzudT+z5PZjBwXrR+A4JUfgmc5ePL88H4iXy+qqyRiw2D588PM71II0tPq8g/KJMnO/D8CdNvWtrNlZ5Eiy9n8KN1p5oAMkuQNQbqhHkFOpEX3nsvk49yB3fSLBp/p+GhfcWwVNWKG2EJBN6hQTdqRDTkEwf51LbxBB7CE/ja8zoAzL+8lA832Ofny2d5M1mjoEb2FqR2xu/S3VoiyYHnzwHPkCGldPyYCq9NNLkQRPzILiHLOFQTRppD52IzJRszZZ8SWx/ZxlXL1TpwOfSyNOagoHztUb4wACQ/Pyg/yPJS/gCw/CBzSBdE6ZFcs7MqznL5lF8UpGLCICOhorOmwzRsmAPPn4ehISXhV4+BirRybC8vG7/O6sz1MdUnGJ1EEghqU7KRBpkTErm5+kcedElUuJjtcxIMoQXaq4OCFAdBspRc4iAtMRHviUacB2deeEX+LTkIp4mJB/FIZ/RELmdXLMjlmkFy4PnzyZBZhcwAiWtFbowaVKJmuS6WaDlyA7WY11U/ItH8Cbk6YcjuQfeEmfHUP9bldyQWFdn8kVCVtEVi0/8H+JGX9Y0EVaKZfgee/yKOwKKjo4dIw8d79sC2xy1MRa7NSjJWJDMQstWb25qXxOag/Bsu/qYrouDqwUQby9W5w4fGn34paxqU/MUHvdwZ/+CEIunAJpTJXIfr0j9B/B4Hnj85PAoTBU+0ejCkZIhNcYLUKOZqT1HRHtsW9DuaAFEwSYEZ7XMlrKWCYgMI1i+VXINpvWauk0Z4HXTg+TPT4yI+Gjnm7lVqXjZ/ebUZFou0Rqr5P9pFi/9XpLlJRdb3sGtURGPJE7S3ekQXa0lpMkL/mpLrZAkKpCKTS+fA81+QiFPaY89OSalVcuXGisTA2SJzDJdwjZCElwwJ1/57hngqREUGQQ48/yXOm2fNw/zn9vfGQZWEl46uqyaWhREmJNxiosbpSriLwf8Vv9zi8Fpq2BGg/y/AAPU/5mo2+jWRAAAAAElFTkSuQmCC'), 200, array('Content-Type' => 'image/png')); });$app->get('/images/hr.png', function() { return new Response(base64_decode('iVBORw0KGgoAAAANSUhEUgAAAzwAAAACCAIAAAASDE75AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAARNJREFUeNrsWFsSwiAMJB3v4lH89v536VrIg5e11LYfOlmmkIZNgNQxGW73xzOcAZomFbG8pV5m9vnJ9MKQismaICoyc5KBjEA2MlMkSlKa5SbUpZ+o5cQDshBnZYUoiDtWWhwsGo2+DpTutjo+lYTeZDN6TMY8j1s5HA6H488BoNfNGLTtXLCM2ErH9gIEa0hPnoEMrEx+eCeqEXJSmibmNTHX2UTTrnAb1EGzSbPNO2FC/QRYBZMlLW+KeKwE660OwCmf8Yq8TtrTgYrtq4UP2dN5Z2/3M1g/aSF4qGLjn7WVbv5P5XA4HA65X7D7CGyUHn1urukD6VauQ4IsXFusFDEIu4obavMuPqZ0+v3P+BJgAMcOofYE4u86AAAAAElFTkSuQmCC'), 200, array('Content-Type' => 'image/png')); });$app->get('/images/nobuild.png', function() { return new Response(base64_decode('iVBORw0KGgoAAAANSUhEUgAAAwYAAAABCAIAAADrSS6mAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAchJREFUeNqUVFuSJCEIBO69fxN7bFl5iqI1sVUR1bZikqQp+OfnLyIBMAAyD5g/iDnuzwyuSzOYmXWLPHN8LOVfkiwweKBEow0kAH11DIVFeW2eJBffODiy7AoyNkk4kTkyFm76deZSa2RE2yr1SmljIFlSDQoQQ0QX5yiTGMYMFxCQVybJVUqGWb4sBkm8CVXLnAETmjRwQpv4cQSGMzJWgg126SOJ/EtSXUCryGDBevrKP4KHh0SwrBKadI5MM4WM52Cl0GJj4zog/YqkoR5YesPM2vfqirXYZTdwtY/v0jqAB9ukKZDy2gCLabVYcFgFQSO6BeOL0jIzaV1AoaFT5V3/tVSc4zOkTNRvVQSKq5TPwxvkIhjgvjdt/8EKC5bZCcJgAGURljE2MgiPm460+/m4Mttf3O5yHEXyx1rIkWhdIoRHp0Jd5+3Qq5h59kq6i1abSW0pBXwrv/oZrzZ4+KTMH331qz905KOyo1+1WzBSuw5yEMbmxmvwh2OzCfdy8o5c3dIkuljrSH14plO6Ev6Vf93V5epMrmyPjB835dh1LeHVfPrkta6XqteO0ZvS97m/YF/kX0f/v2brOn8gHPrMwT8BBgDMkjfuxvEtbAAAAABJRU5ErkJggg=='), 200, array('Content-Type' => 'image/png')); });$app->get('/images/success.png', function() { return new Response(base64_decode('iVBORw0KGgoAAAANSUhEUgAAAwYAAAABCAIAAADrSS6mAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAjdJREFUeNpkVQF2JSEIAy+4R+kpey2pCglhtu91/oyCQBLQf37/bQs3i7Dl/t49LJb5Pkvn42xZ/t+/Y5Nf5+cYvzdf5/0a3y1Pu2fh8MvFiPB0zxPP+/PysqmT7ZntE8sqQK4EnukIvwwRzPC43eRzcVdsh3XsyBrOiy8vpwimcMvPzxfsPuwt5OZ7XUyjkGBsq3PKIV6VN4qzdqDz3AqB81yLgL+s9n2cDBO9AFA3fy9kz+bGeeuSALiMcWs3XRPhjPISCGNdYAeVVIaJAxG+CtnhkEJBB95JVp5OQl2qzjQAaClnKTLEnpyKwJYD6/2quI6en5dN8GW7ZFBUFpksUEgA17noV3QlCUVjJXS5vgbCt5wNMV9KqKuztdA+4ADtEKJ8UhOdDGQgu4nOoiXbzVX9qChr7tAObXwTQA7KUQWNJqt0Mql0nNNiMZLoQwnsF9aFmZCauPR0/zRNLStjszwQuFelwcbRzdk7oLWroKhccs2TqcY7BruEkjJFq5r5jAsUJsh0rYV75nCjBWeg2KhiG9EgAoK0NiAEOfSMrkfJPZqLGml8OuqY1VFOMuLlv3wMPvaLDEbXwwsWV+VPd+sSVCp9oKmEwYjp1dBzo5tLND36WkYN25MHfkYo7yBq+9O2oopGyVS3nIffA1VCNsbCOOV/nYihzdpN5wEwnzcUrT76mTHnDOe1pdSMG9OGYhvSUX4QJWsDG3CJZihA1/vF6D97rCnWAa4Kt3Hl6fBP/z8BBgBV6/vMFgEx6QAAAABJRU5ErkJggg=='), 200, array('Content-Type' => 'image/png')); });$app->get('/images/sensio-labs-product.png', function() { return new Response(base64_decode('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'), 200, array('Content-Type' => 'image/png')); });} namespace { use Symfony\Component\HttpFoundation\Response; use Symfony\Component\HttpKernel\Exception\NotFoundHttpException; $app->get('/', function() use ($app) { return $app['twig']->render('projects.twig', array('projects' => $app['sismo']->getProjects())); })->bind('projects'); $app->get('/{slug}', function($slug) use ($app) { if (!$app['sismo']->hasProject($slug)) { throw new NotFoundHttpException(sprintf('Project "%s" not found.', $slug)); } $project = $app['sismo']->getProject($slug); $commits = $project->getCommits(); $latest = array_shift($commits); return $app['twig']->render('project.twig', array( 'project' => $project, 'commit' => $latest, 'commits' => $commits, )); })->bind('project'); $app->get('/dashboard/cctray.xml', function() use ($app) { $content = $app['twig']->render('ccmonitor.twig.xml', array('projects' => $app['sismo']->getProjects())); return new Response($content, 200, array('content-type' => 'text/xml')); })->bind('ccmonitor'); $app->get('/{slug}/{sha}', function($slug, $sha) use ($app) { if (!$app['sismo']->hasProject($slug)) { throw new NotFoundHttpException(sprintf('Project "%s" not found.', $slug)); } $project = $app['sismo']->getProject($slug); if (!$commit = $app['storage']->getCommit($project, $sha)) { throw new NotFoundHttpException(sprintf('Commit "%s" for project "%s" not found.', $sha, $slug)); } return $app['twig']->render('project.twig', array( 'project' => $project, 'commit' => $commit, )); })->bind('commit'); } namespace { if ('cli' === php_sapi_name()) { $console->run(); } else { $app->run(); } } 